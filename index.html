<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <link rel="icon" href="data:,">
  <base target="_top">
<script 
  src="https://cdn.jsdelivr.net/npm/@twemoji/api@latest/dist/twemoji.min.js"
  onload="window.twemojiLoaded = true"
></script>
<style>
:root {--app-height: 100vh;}
body {height: var(--app-height); min-height: var(--app-height);height: 100dvh; /* Fallback moderne */ min-height: 100dvh;}
.section.active { height: var(--app-height); min-height: var(--app-height);}    
:root {--brown-primary: #8B6F47; --beige-light: #F5E8C7; --beige-background: #F8F1E9; --green-primary: #A8D5BA; --green-light: #DDE6D5; --green-pale: #d4edda; --green-dark: #355E3B; --green-medium: #8BC34A; --green-bright: #4CAF50; --green-gradient-start: #66BB6A; --green-gradient-end: #81C784; --green-subtle-1: #f9fdf9; --green-subtle-2: #f5faf5; --green-subtle-3: #f0f8f0; --green-subtle-4: #ebf5eb; --pink-primary: #FDC1C5; --pink-pale: #f8d7da; --pink-light: #f8e7e6; --red-progress: #ff6b6b; --red-progress-light: #ff8e8e; --pink-subtle-1: #fdfafa; --pink-subtle-2: #fcf5f5; --pink-subtle-3: #faf0f1; --pink-subtle-4: #f8ebec; --white: #FFFFFF; --gray-very-light: #E8ECEF; --gray-light: #e0e0e0; --gray-medium: #ccc; --gray-dark: #636E72; --gray-text: #3c3f41; --blue-light: #d1e7ff; --blue-dark: #1a3c66; --blue-gradient-start: #E0F7FA; --yellow-pale: #fff3cd; --yellow-dark: #664d1a; --orange-pale: #ffe4b5; --orange-dark: #663b1a; --shadow-brown-light: rgba(139, 111, 71, 0.3); --shadow-brown-medium: rgba(139, 111, 71, 0.4); --shadow-brown-strong: rgba(139, 111, 71, 0.5); --shadow-black-light: rgba(0, 0, 0, 0.1); --shadow-black-medium: rgba(0, 0, 0, 0.15); --shadow-black-strong: rgba(0, 0, 0, 0.2); --shadow-black-dark: rgba(0, 0, 0, 0.25); --overlay-white-10: rgba(255, 255, 255, 0.1); --overlay-white-20: rgba(255, 255, 255, 0.2); --overlay-white-30: rgba(255, 255, 255, 0.3); --overlay-white-50: rgba(255, 255, 255, 0.5); --overlay-bg: rgba(248, 241, 233, 0.95); --overlay-green-08: rgba(168, 213, 186, 0.08); --overlay-green-05: rgba(168, 213, 186, 0.05); --overlay-green-03: rgba(139, 111, 71, 0.03); --overlay-green-10: rgba(168, 213, 186, 0.1); --overlay-green-20: rgba(168, 213, 186, 0.2); --overlay-green-30: rgba(168, 213, 186, 0.3); --overlay-green-40: rgba(168, 213, 186, 0.4); --overlay-green-50: rgba(168, 213, 186, 0.5); --overlay-pink-10: rgba(253, 193, 197, 0.1); --overlay-pink-50: rgba(253, 193, 197, 0.5); --overlay-red-10: rgba(220, 53, 69, 0.1); --overlay-green-success: rgba(40, 167, 69, 0.1);
}
html {touch-action: pan-x pan-y; -ms-touch-action: pan-x pan-y;}
* {user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;}
body {background: var(--beige-background); font-family: 'Noto Sans JP', sans-serif; color: var(--brown-primary); font-family: sans-serif; text-align: center; padding: 0.5em 1em 1em 1em; margin: 0; height: 100vh; overflow: hidden; display: flex; flex-direction: column;}
body::before {content: ''; position: absolute; top: 0; left: 0; background: url('https://www.transparenttextures.com/patterns/paper-fibers.png'); opacity: 0.1; z-index: -1;}
h1 {margin: 0.5em 0; font-size: 1.8em; text-align: center; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light);}
h2 {margin: 0.1em 0; font-size: 2.5em; text-align: center; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light); margin-bottom: 5px;}
.menu {gap: 15px;}
#welcome {display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100dvh; min-height: 100dvh; text-align: center;}
.panda-logo {font-size: 12em;cursor: pointer;transition: transform 0.3s ease, opacity 0.6s ease; animation: pandaPulse 2s ease-in-out infinite; opacity: 0;}
.panda-logo.loaded { opacity: 1;}
.panda-logo:hover {transform: scale(1.1);}
@keyframes pandaPulse {0%, 100% { transform: scale(1);} 50% { transform: scale(1.20); }}
.welcome-title {font-size: 2.5em; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light); margin-top: 50px; margin-bottom: 5px;}
.welcome-subtitle {font-size: 1.2em; color: var(--brown-primary); opacity: 0.8;}
.loading-dots {font-size: 1.5em; color: var(--brown-primary); margin-top: 30px; animation: loadingDots 1.5s infinite; margin-bottom: 1px;}
@keyframes loadingDots {0% { opacity: 0.2; } 20% { opacity: 1; } 100% { opacity: 0.2; }}
.hidden {display: none !important;}
#unlock-progress-container{position:fixed!important;top:12px;left:50%;transform:translateX(-50%);width:90vw;max-width:600px;margin:0 auto;padding:6px 10px;background:var(--overlay-white-10);border-radius:12px;box-sizing:border-box}
.unlock-progress-bar{position:relative;height:12px;background:var(--gray-light);border:2px solid var(--gray-medium);border-radius:10px;overflow:hidden}
.unlock-progress-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--red-progress),var(--red-progress-light));border-radius:8px;transition:width .4s ease;position:relative}
.unlock-progress-fill.proche-deblocage{animation:pulse-unlock 1s infinite}
@keyframes pulse-unlock{0%,100%{box-shadow:0 0 8px rgba(255,107,107,.6)}50%{box-shadow:0 0 20px rgba(255,107,107,1)}}@keyframes pulse-unlock {0%, 100% { background: linear-gradient(90deg, var(--green-bright), var(--green-gradient-start)); } 50% { background: linear-gradient(90deg, var(--green-gradient-start), var(--green-gradient-end)); }}
#progressBarContainer {display: flex; align-items: center; justify-content: space-between; gap: 0.5em; margin: 1em auto 0.3em auto; max-width: 50ch; width: 100%; margin-bottom: 10px;}
.progress-bar-track {position: relative; height: 16px; background: linear-gradient(to right, var(--blue-gradient-start), var(--green-dark)); border-radius: 6px; flex: 1; box-shadow: 0 2px 4px var(--shadow-black-light);}
.progress-marker {position: absolute; top: 45%; left: 0; transform: translate(-50%, -50%); font-size: 2em; transition: left 1.5s ease; color: var(--gray-dark);animation: pulse 2s ease-in-out infinite;}
.side-emoji {font-size: 1.6em; line-height: 1; color: var(--gray-dark);}
@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); } 
  50% { transform: translate(-50%, -50%) scale(1.15); }}
.level {font-size: 1.6em; margin: 0.4em 0; margin-bottom: 50px;}
.level-hiraganas {margin: 1em auto; max-width: 800px; flex-shrink: 0; margin-bottom: 25px;}
.hiraganas-grid {display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-bottom: 0.5em;}
.hiragana-card {text-align: center; transition: all 0.3s ease; position: relative; padding: 10px; background: var(--white); border-radius: 8px; box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium);}
.hiragana-card.completed {background: var(--green-light); animation: completedPulse 2s ease-in-out infinite;}
@keyframes completedPulse {0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); }}
.hiragana-char {font-size: 2.2em; font-weight: bold; margin-bottom: 6px; color: var(--brown-primary); text-shadow: 0 0 3px var(--shadow-brown-light);}
.hiragana-card.completed .hiragana-char {color: var(--green-primary); text-shadow: 0 0 5px var(--overlay-green-50); animation: starGlow 2s ease-in-out infinite;}
.stars-container {display: flex; justify-content: center; gap: 2px;}
.star {width: 12px; height: 12px; background: var(--gray-very-light); clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); transition: all 0.3s ease;}
.star.filled {background: var(--pink-primary);}
.star.new-star {animation: starFill 0.5s ease-in-out;}
.hiragana-card.completed .star.filled {background: var(--green-primary); animation: starGlow 2s ease-in-out infinite;}
@keyframes starFill {0% { transform: scale(0) rotate(180deg); } 100% { transform: scale(1) rotate(0deg); }}
@keyframes starGlow {0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); }}
.firework {position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 0.5em; height: 0.5em; background: transparent; pointer-events: none; animation: fireworkExplosion 700ms ease-out forwards; z-index: 100000;}
@keyframes fireworkExplosion {0% { box-shadow: 0 0 #ff0, 0 0 #f00, 0 0 #0ff; opacity: 1; transform: translateX(-50%) scale(1); } 100% { box-shadow: 0 -40px #ff0, 30px -30px #f00, 40px 0 #0ff, 30px 30px #0f0, 0 40px #00f, -30px 30px #f0f, -40px 0 #fff, -30px -30px #ff0; opacity: 0; transform: translateX(-50%) scale(0.5); }}
.sakura {position: absolute; width: 100px; height: 10px; background: var(--pink-primary); border-radius: 50%; pointer-events: none; animation: sakuraFall 3s linear forwards; z-index: 10;}
@keyframes sakuraFall {0% { transform: translateY(0) rotate(0deg); opacity: 1; } 100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }}
.quiz-container { position: relative; flex: 1; display: flex; flex-direction: column; justify-content: space-between; min-height: 0; padding-bottom: 2em;}
.question {font-size: 4em; font-weight: bold; margin: 0.5em 0; height: 1.2em; display: flex; align-items: center; justify-content: center; color: var(--brown-primary); text-shadow: 1px 1px 2px var(--shadow-brown-medium); margin-bottom: 53px;}
.answers {display: flex; flex-wrap: wrap; justify-content: center; gap: 0.8em; margin-bottom: 1em;}
.sakura {width: 12px; height: 12px;}
.arcade-button {position: relative; background: var(--beige-light); border: 2px solid transparent; border-radius: 10px; padding: 0.8em 1.5em; color: var(--brown-primary); font-size: 1.4em; line-height: 1.2; white-space: normal; font-weight: bold; cursor: pointer; box-shadow: 0 4px 8px var(--shadow-black-strong), inset 0 2px 2px var(--overlay-white-30); transition: all 0.15s ease; text-shadow: 0 0 8px var(--shadow-brown-strong); overflow: hidden; min-width: 120px; text-align: center;}
.arcade-button::before {content: ''; position: absolute; top: 0; left: 0; right: 0; height: 50%; background: linear-gradient(to bottom, var(--overlay-white-20), rgba(255, 255, 255, 0)); border-top-left-radius: 10px; border-top-right-radius: 10px; pointer-events: none;}
.arcade-button:hover {transform: translateY(-2px) scale(1.02); box-shadow: 0 6px 10px var(--shadow-black-dark), inset 0 2px 2px var(--overlay-white-30);}
.arcade-button:active {transform: translateY(2px) scale(0.98); box-shadow: 0 2px 4px var(--shadow-black-strong), inset 0 1px 1px var(--overlay-white-30);}
.arcade-button:disabled {cursor: not-allowed; opacity: 0.8;}
.arcade-button.clicked {opacity: 1 !important; cursor: default;}
.arcade-button.clicked-glow {text-shadow: 0 0 12px var(--green-primary), 0 0 4px var(--green-primary); animation: glowPulse 1s ease-in-out infinite;}
.arcade-button.correct {background: var(--overlay-green-50) !important; color: var(--brown-primary); border-color: var(--green-primary); background-image: none !important; animation: correctGlow 0.6s ease-in-out; opacity: 1 !important;}
.arcade-button.correct::before {display: none;}
.arcade-button.incorrect {background: var(--overlay-pink-50) !important; color: var(--brown-primary); border-color: var(--pink-primary); background-image: none !important; animation: incorrectShake 0.6s ease-in-out; opacity: 1 !important;}
.arcade-button.incorrect::before {display: none;}
@keyframes glowPulse {0%, 100% { text-shadow: 0 0 12px var(--green-primary), 0 0 4px var(--green-primary); } 50% { text-shadow: 0 0 18px var(--green-primary), 0 0 6px var(--green-primary); }}
@keyframes correctGlow {0% { box-shadow: 0 4px 8px var(--shadow-black-strong), inset 0 2px 2px var(--overlay-white-30); } 50% { box-shadow: 0 6px 10px var(--shadow-black-dark), 0 0 20px rgba(168, 213, 186, 0.6); } 100% { box-shadow: 0 4px 8px var(--shadow-black-strong), inset 0 2px 2px var(--overlay-white-30); }}
@keyframes incorrectShake {0% { transform: translateX(0); } 10% { transform: translateX(-8px); } 20% { transform: translateX(8px); } 30% { transform: translateX(-6px); } 40% { transform: translateX(6px); } 50% { transform: translateX(-4px); } 60% { transform: translateX(4px); } 70% { transform: translateX(-2px); } 80% { transform: translateX(2px); } 90% { transform: translateX(-1px); } 100% { transform: translateX(0); }}
.result {animation: fadeIn 0.4s ease-in; font-size: 1.3em; line-height: 1.4em; margin: 0.5em 0 0.2em 0; min-height: 4.5em; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: var(--brown-primary);}
.result-line.highlight {color: var(--brown-primary);}
@keyframes fadeIn {from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); }}
#continueBtn {visibility: hidden; margin: 0.5em auto; display: block; width: fit-content;}
#boutonInstaller {margin: 0.5em auto; height: 3em; display: none;}
@keyframes confettiFall {0% { transform: translateY(0); } 100% { transform: translateY(110vh) rotate(720deg); }}
body.shake {animation: screenShake 0.4s ease-in-out;}
@keyframes screenShake {0% { transform: translate(0px, 0px); } 25% { transform: translate(4px, -4px); } 50% { transform: translate(-4px, 4px); } 75% { transform: translate(4px, 4px); } 100% { transform: translate(0px, 0px); }}
.hamburger {position: fixed; background: var(--white); border: none; border-radius: 8px; color: var(--brown-primary); padding: 12px; cursor: pointer; z-index: 1000; box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;}
.menu.active ~ .hamburger {display: none;}
.hamburger-icon {display: flex; flex-direction: column; gap: 4px; width: 20px; height: 16px;}
.hamburger-bar {width: 100%; height: 3px; background: var(--shadow-brown-light); border-radius: 2px; transition: all 0.3s ease;}
#menu-message {text-align: center !important; font-size: 2.5em !important; font-weight: 700 !important; color: var(--brown-primary) !important; border: none !important; padding: 15px !important; margin-bottom: 30px !important; border-radius: 8px !important; line-height: 1.3 !important; display: block; z-index: 1001; opacity: 0; transform: translateY(-10px); transition: opacity .45s ease, transform .45s ease;}
.menu.active #menu-message {opacity: 1; transform: translateY(0);}
.menu {position: fixed; top: 0; right: 0; width: 100%; height:100%; background: var(--overlay-bg); display: flex; flex-direction: column; justify-content: center; align-items: center; transform: translateX(100%); transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; opacity: 0; z-index: 999;}
.menu.active {transform: translateX(0); opacity: 1;}
.menu .arcade-button {width: 300px !important; height: 80px !important; min-height: 80px !important; max-height: 80px !important; line-height: 80px !important; padding: 0 1.5em !important; font-size: 1.6em !important; box-sizing: border-box !important;}
.options-menu .arcade-button,
.options-sub .arcade-button { width: 300px !important; height: 80px !important; min-height: 80px !important; max-height: 80px !important; line-height: 80px !important; padding: 0 1.5em !important; font-size: 1.6em !important; box-sizing: border-box !important;}
.options-sub .arcade-button { height: auto !important; min-height: 80px !important; line-height: 1.2 !important; padding: 0.6em 1.2em !important; white-space: normal !important;}
.arcade-button.disabled {background: var(--gray-light) !important; color: #999999 !important; cursor: not-allowed !important; opacity: 0.6; border-color: var(--gray-medium) !important;}
.arcade-button.disabled:hover {transform: none !important; box-shadow: 0 4px 8px var(--shadow-black-strong) !important;}
.options-menu, .options-sub {display: flex; flex-direction: column !important; align-items: center; gap: 15px; width: 100%;}
.options-menu,
.options-sub { flex: 1; justify-content: center;}
.menu .arcade-button,
.options-menu .arcade-button,
.options-sub .arcade-button { font-size: 1.6em !important;}
.options-sub .arcade-button:first-child {margin-bottom: 20px;}
.options-sub {opacity: 0; transform: translateY(10px); transition: opacity 0.3s ease, transform 0.3s ease;}
.options-sub.active {opacity: 1; transform: translateY(0);}
.section {display: none;}
.section.active {display: flex; flex-direction: column; height: 100vh;}
#revision-question {font-size: 1.5em; margin-top: 50px; margin-bottom: 30px; color: var(--brown-primary); text-shadow: 1px 1px 2px var(--shadow-brown-medium);}
.char-correct {background-color: var(--green-pale); border-radius: 5px; padding: 2px 4px;}
.char-incorrect {background-color: var(--pink-light); border-radius: 5px; padding: 2px 4px;}
.pulsing {animation: revisionPulse 0.8s infinite;}
@keyframes revisionPulse {0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); }}
#revision-input-display {font-size: 2em; margin: 0 auto 10px auto; height: 25px; padding: 10px; border: 2px solid transparent; border-radius: 12px; width: 300px; text-align: center; background: var(--white); box-shadow: 0 4px 8px var(--shadow-black-light); display: flex; align-items: center; justify-content: center; overflow: hidden;}
.revision-keyboard {display: grid; grid-template-columns: repeat(5, 60px); gap: 8px; justify-content: center; margin-bottom: 10px; margin-top: 0;}
.revision-key {width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; border: 2px solid transparent; border-radius: 10px; cursor: pointer; font-family: 'Poppins', sans-serif; font-weight: 500; font-size: 2.5em; font-weight: bold; position: relative; overflow: hidden; touch-action: manipulation; background: linear-gradient(145deg, var(--overlay-white-30), var(--overlay-white-10)); box-shadow: inset 0 2px 4px var(--shadow-black-light), 0 4px 8px var(--shadow-black-medium); text-shadow: 0 1px 2px var(--shadow-black-strong);}
.revision-key:active, .revision-key.active {animation: pressAndRelease 0.3s ease forwards;}
.revision-key::after {content: ''; position: absolute; width: 100px; height: 100px; background: linear-gradient(45deg, transparent, var(--overlay-white-50), transparent); transform: translateX(-100%) rotate(45deg); transition: transform 0.3s ease; pointer-events: none;}
.revision-key:active::after, .revision-key.active::after {transform: translateX(100%) rotate(45deg);}
@keyframes pressAndRelease {0% { transform: translateY(0); box-shadow: inset 0 2px 4px var(--shadow-black-light), 0 4px 8px var(--shadow-black-medium); } 50% { transform: translateY(3px); box-shadow: inset 0 2px 4px var(--shadow-black-strong), 0 1px 2px var(--shadow-black-light); } 100% { transform: translateY(0); box-shadow: inset 0 2px 4px var(--shadow-black-light), 0 4px 8px var(--shadow-black-medium); }}
.revision-key:nth-child(-n+5) {background-color: var(--blue-light); color: var(--blue-dark);}
.revision-key:nth-child(6), .revision-key:nth-child(7) {background-color: var(--yellow-pale); color: var(--yellow-dark);}
.revision-key:nth-child(8) {background-color: var(--blue-light); color: var(--blue-dark);}
.revision-key:nth-child(9), .revision-key:nth-child(10) {background-color: var(--pink-light); color: #661a1a;}
.revision-key:nth-child(n+11):nth-child(-n+15) {background-color: var(--green-pale); color: #1a6642;}
.revision-key:nth-child(n+16):nth-child(-n+20) {background-color: var(--orange-pale); color: var(--orange-dark);}
.revision-key:nth-child(n+21):nth-child(-n+24) {background-color: var(--gray-light); color: var(--gray-text);}
.revision-key:nth-child(25) {background-color: var(--white); color: #333333;}
#revision-message {margin-top: 10px; margin-bottom: 10px; font-size: 1.8em; color: var(--brown-primary); min-height: 1.5em;}
.char-card {  display: inline-flex; padding: 15px; /* Garde le padding symétrique pour l'espace intérieur */ margin: 5px; border-radius: 8px; min-width: 60px; /* Garde une largeur minimale pour éviter qu'elles soient trop étroites */ aspect-ratio: 3 / 4; /* ✅ NOUVEAU : Ratio width/height = 3:4 → height = (4/3) * width → plus haute que large. Ajuste si besoin (ex: 2/3 pour plus vertical) */ text-align: center; font-size: 2.2em;font-weight: bold;color: var(--brown-primary);text-shadow: 0 0 3px var(--shadow-brown-light);background: var(--white); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); transition: all 0.4s ease; align-items: center; justify-content: center; box-sizing: border-box; /* ✅ AJOUT : our inclure padding dans les dimensions */}
.char-correct-1 {background: var(--green-subtle-1); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 2px rgba(139, 195, 74, 0.1);}
.char-correct-2 {background: var(--green-subtle-2); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 3px rgba(139, 195, 74, 0.15);}
.char-correct-3 {background: var(--green-subtle-3); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 4px rgba(139, 195, 74, 0.2);}
.char-correct-4 {background: var(--green-subtle-4); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 5px rgba(139, 195, 74, 0.25);}
.char-incorrect-1 {background: var(--pink-subtle-1); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 2px var(--overlay-pink-10);}
.char-incorrect-2 {background: var(--pink-subtle-2); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 3px rgba(253, 193, 197, 0.15);}
.char-incorrect-3 {background: var(--pink-subtle-3); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 4px rgba(253, 193, 197, 0.2);}
.char-incorrect-4 {background: var(--pink-subtle-4); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium), inset 0 0 5px rgba(253, 193, 197, 0.25);}
.pulsing {animation: pulse-revision 1.8s infinite ease-in-out;}
@keyframes pulse-revision {0% { transform: scale(1); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); } 50% { transform: scale(1.08); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3), 0 4px 8px var(--shadow-black-strong), 0 0 8px var(--shadow-brown-light); } 100% { transform: scale(1); box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); }}
#mode2 .title {margin: 0.5em 0; font-size: 1.8em; text-align: center; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light);}
.account-section {padding: 2em; max-width: 500px; margin: 0 auto; text-align: center;}
.pseudo-display {font-size: 2.5em; font-weight: bold; color: var(--brown-primary); margin: 1em 0; padding: 0.5em; background: var(--white); border-radius: 12px; box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); min-height: 1.5em; display: flex; align-items: center; justify-content: center;}
.pin-input-container {margin: 2em 0;}
.pin-input {font-size: 2em; padding: 0.5em; width: 200px; text-align: center; border: 2px solid var(--brown-primary); border-radius: 8px; background: var(--white); box-shadow: 0 4px 8px var(--shadow-black-light);}
.pin-input:focus {outline: none; border-color: var(--green-primary); box-shadow: 0 6px 12px var(--overlay-green-40);}
.pin-label {font-size: 1.2em; color: var(--brown-primary); margin-bottom: 0.5em; display: block;}
.account-info {margin: 2em auto; padding: 1em; background: var(--overlay-white-50); border-radius: 8px; max-width: 460px; width: 100%; text-align: center; box-sizing: border-box;}
.account-info-line {font-size: 1.2em; color: var(--brown-primary); margin: 0.8em 0;}
.button-group {display: flex; flex-direction: column; gap: 1em; margin: 2em auto 0; max-width: 400px; width: 100%; padding: 0 1em; box-sizing: border-box;}
.error-message {color: #dc3545; font-size: 1.1em; margin: 1em auto; padding: 0.5em; background: var(--overlay-red-10); border-radius: 8px; max-width: 400px; text-align: center;}
.success-message {color: #28a745; font-size: 1.1em; margin: 1em 0; padding: 0.5em; background: var(--overlay-green-success); border-radius: 8px;}
/* Loader zen */
html,body{height:100%;margin:0;padding:0}body{display:flex;align-items:center;justify-content:center;min-height:100dvh;overflow:hidden}
.zen-loader-container{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:9999;opacity:1;transition:opacity .6s ease}.zen-loader-container.hidden{opacity:0;pointer-events:none}
.zen-circle-loader { width: 120px; height: 120px; border: 4px solid rgba(139, 111, 71, 0.2); border-top-color: var(--brown-primary); border-radius: 50%; animation: zen-spin 1.5s ease-in-out infinite; display: flex; align-items: center; justify-content: center; }
.bamboo-leaf { font-size: 3em; animation: leaf-float 2s ease-in-out infinite; }
@keyframes zen-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
@keyframes leaf-float { 0%, 100% { transform: translateY(0px) rotate(0deg); } 50% { transform: translateY(-10px) rotate(180deg); } }
.zen-loader-text { margin-top: 30px; font-size: 1.3em; color: var(--brown-primary); animation: pulse-text 1.5s ease-in-out infinite; }
@keyframes pulse-text { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
.welcome-animation-container {display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; width: 100vw; position: fixed; top: 0; left: 0; background: var(--beige-background) !important; overflow: hidden; z-index: 9999;}
.welcome-user-title {font-size: 3em; color: var(--brown-primary); text-shadow: 0 0 20px var(--overlay-pink-50); animation: welcome-fade-in 1s ease-out; z-index: 10; text-align: center; padding: 0 20px;}
.welcome-user-subtitle {font-size: 1.5em; color: var(--brown-primary); opacity: 0.8; margin-top: 20px; animation: welcome-fade-in 1s ease-out 0.5s both; z-index: 10; text-align: center; padding: 0 20px;}
@keyframes welcome-fade-in {0% { opacity: 0; transform: translateY(30px); } 100% { opacity: 1; transform: translateY(0); }}
.sakura-rain {position: absolute; width: 100%; height: 100%; pointer-events: none;}
.stats-filters {display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 2em auto 1em auto; max-width: 1000px; padding: 0 1em;}
.filter-btn {font-size: 1em !important; padding: 0.6em 1.2em !important; min-width: auto !important; height: auto !important; line-height: normal !important;}
.filter-btn.active {background: var(--overlay-green-30) !important; border-color: var(--green-primary) !important;}
.stats-table-container {padding-top: 70px; margin: 1em auto 2em auto; max-width: 1000px; padding: 0 1em; max-height: 60vh; overflow-y: auto; position: relative; padding: 1em; box-sizing: border-box;}
.stats-table {width: 100%; background: var(--white); border-radius: 12px 12px 0 0; box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); border-collapse: separate; border-spacing: 0; box-shadow: none;}
.stats-table thead {background: rgba(139, 111, 71, 0.1); position: sticky; top: 0;}
.stats-table th {padding: 1em; text-align: center; font-weight: bold; color: var(--brown-primary); border-bottom: 2px solid rgba(139, 111, 71, 0.2); background: rgba(139, 111, 71, 0.1);}
.stats-table td {padding: 1em; color: var(--brown-primary); text-align: center; border-bottom: 1px solid rgba(139, 111, 71, 0.1); font-size: 1.2em;}
.stats-table tbody tr {transition: background 0.2s ease;}
.stats-table tbody tr:hover {background: rgba(139, 111, 71, 0.05);}
.status-emoji {font-size: 1.8em; display: inline-block;}
.stats-table tbody tr.acquired {background: var(--overlay-green-08);}
.stats-table tbody tr.review {background: var(--overlay-green-05);}
.stats-table tbody tr.progress {background: var(--overlay-green-03);}
.pseudo-input-wrapper {margin: 20px auto; display: flex; justify-content: center; width: 100%; padding: 0 20px; box-sizing: border-box;}
.pseudo-input {width: 100%; max-width: 300px; padding: 15px 20px; font-size: 1.8em; font-weight: bold; text-align: center; color: var(--brown-primary); background: var(--overlay-green-10); border: 3px solid var(--brown-primary); border-radius: 15px; outline: none; transition: all 0.3s ease; font-family: inherit; box-sizing: border-box;}
.pseudo-input:focus {background: var(--overlay-green-20); border-color: var(--green-primary); box-shadow: 0 0 15px var(--overlay-green-50); transform: scale(1.02);}
.pseudo-input::placeholder {color: var(--shadow-brown-medium); font-style: italic;}
.secondary-button {background: rgba(139, 111, 71, 0.1) !important; border: 2px solid var(--brown-primary) !important; color: var(--brown-primary) !important; font-size: 0.9em !important;}
.secondary-button:hover {background: rgba(139, 111, 71, 0.2) !important; transform: scale(1.02);}
.onboarding-step {display: none; opacity: 0; transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1); width: 100%; max-width: 500px; margin: 0 auto; padding: 20px; box-sizing: border-box;}
.onboarding-step.active {display: block; opacity: 1;}
.onboarding-title {font-size: 2em; color: var(--brown-primary); text-align: center; margin-bottom: 30px; text-shadow: 0 2px 4px var(--shadow-black-light);}
.onboarding-content {background: var(--overlay-green-05); border-radius: 20px; padding: 30px 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.05);}
.onboarding-subtitle {text-align: center; font-size: 1.2em; color: var(--brown-primary); margin-bottom: 30px; opacity: 0.8;}
.onboarding-buttons {display: flex; flex-direction: column; gap: 15px; margin: 30px auto 0; max-width: 400px; width: 100%; box-sizing: border-box;}
.large-button {font-size: 1.3em !important; padding: 20px 30px !important; min-height: 70px;}
.primary-button {background: linear-gradient(135deg, var(--green-primary), var(--green-medium)) !important; box-shadow: 0 4px 15px var(--overlay-green-40);}
.primary-button:hover {transform: scale(1.05); box-shadow: 0 6px 20px rgba(168, 213, 186, 0.6);}
.small-button {font-size: 0.9em !important; padding: 10px 20px !important;}
.confirmation-box {background: var(--overlay-green-10); border: 2px solid var(--green-primary); border-radius: 15px; padding: 25px; margin: 20px 0; text-align: center;}
.confirmation-question {font-size: 1.1em; color: var(--brown-primary); margin-bottom: 10px;}
.confirmation-date {font-size: 1.8em; font-weight: bold; color: var(--brown-primary); margin: 10px 0;}
.warning-box {background: var(--overlay-pink-10); border: 2px solid var(--pink-primary); border-radius: 10px; padding: 15px; margin: 20px 0; text-align: center;}
.warning-box p {color: #dc3545; font-weight: bold; margin: 0; font-size: 0.95em;}
.pin-example {font-size: 0.9em; color: var(--brown-primary); margin-top: 10px; text-align: center; opacity: 0.7;}
.birthdate-selectors {display: flex; gap: 15px; justify-content: center; margin: 20px 0;}
.selector-group {display: flex; flex-direction: column; gap: 8px; flex: 1; max-width: 150px;}
.selector-label {font-size: 0.9em; color: var(--brown-primary); font-weight: bold; text-align: center;}
.birthdate-select {width: 100%; padding: 12px 10px; font-size: 1.2em; font-weight: bold; text-align: center; color: var(--brown-primary); background: var(--overlay-green-10); border: 3px solid var(--brown-primary); border-radius: 10px; outline: none; cursor: pointer; transition: all 0.3s ease; font-family: inherit; box-sizing: border-box;}
.birthdate-select:focus {background: var(--overlay-green-20); border-color: var(--green-primary); box-shadow: 0 0 15px var(--overlay-green-50); transform: scale(1.02);}
.birthdate-select option {background: var(--beige-background); color: var(--brown-primary); padding: 10px;}
.result-line { display: flex; flex-direction: column; align-items: center; text-align: center; padding-top: 0; /* ❌ SUPPRIME le padding-top: 5vh qui décalait tout */}
.result-emoji { font-size: 4rem; line-height: 1; margin-top: 1rem; /* Espace entre texte et emoji */}
.result-text { font-size: 3rem; font-weight: bold; margin-bottom: 0; z-index: 10 !important;/* ❌ SUPPRIME le margin-bottom: 3vh */}
/* Animation COMBO Pop + Pulse + Sparkles */
.anim-combo { position: relative;}
.anim-combo .result-text { animation: comboPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); z-index: 9998 !important;}
.anim-combo .result-emoji { animation: comboPulseWiggle 0.6s ease-out 0.1s backwards;}
@keyframes comboPop { 0% { opacity: 0; transform: scale(0);} 60% {transform: scale(1.15);} 100% { opacity: 1; transform: scale(1); }}
@keyframes comboPulseWiggle { 0% { opacity: 0; transform: scale(0) rotate(0deg); filter: brightness(0.5);}40% { transform: scale(1.3) rotate(-8deg); filter: brightness(1.5); }60% { transform: scale(1.1) rotate(8deg); }80% { transform:scale(1.05) rotate(-4deg); } 100% {opacity: 1; transform: scale(1) rotate(0deg); filter: brightness(1); }}
/* Étincelles / Sparkles */
.sparkle { position: absolute; pointer-events: none; animation: sparkleFloat 0.8s ease-out forwards; will-change: transform, opacity; z-index: 10 !important;}
@keyframes sparkleFloat { 0% { opacity: 0;transform: translate(0, 0) scale(0) rotate(0deg);}50% { opacity: var(--sparkle-opacity); transform: translate(var(--tx), var(--ty)) scale(1.2) rotate(180deg);}100% {opacity: 0; transform:translate(calc(var(--tx) * 1.5), calc(var(--ty) * 1.5)) scale(0.5) rotate(360deg); }}
/* Important : assurez-vous que #result a position: relative */
#result {position: absolute; /* Sera positionné par JS */ display: flex;align-items: center;justify-content: center;overflow: visible; pointer-events: none;transition: opacity 0.5s ease;z-index: 9998 !important;}
@media (min-width: 769px) { .hamburger {top: 20px; left: 20px; width: 44px; height: 44px;}.hamburger:hover .hamburger-bar {background: var(--brown-primary);}.hamburger:hover {box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3), 0 4px 8px var(--shadow-black-strong); transform: translateY(-1px);}#unlock-progress-container{top:16px}.unlock-progress-bar{height:16px}}
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {h1 {font-size: 1.4em; margin: 0.1em 0;} h2 {font-size: 1.4em; margin: 0 0;} .menu {gap: 10px;} .panda-logo {font-size: 8em;} .welcome-title {font-size: 1.4em;} .welcome-subtitle {font-size: 1em;} .loading-dots {font-size: 1.4em;} #unlock-progress-container{top:10px;padding:5px 8px}.unlock-progress-bar{height:8px;border-width:1px} #progressBarContainer {max-width: 90%; margin: 1.5em auto 0.5em auto; gap: 1em;} .progress-bar-track {height: 12px; border-radius: 4px;} .progress-marker {font-size: 2.0em; top: 45%; transform: translate(-50%, -50%);} .side-emoji {font-size: 2em;} .level {font-size: 1.0em; margin: 0.4em 0; margin-bottom: 25px;} #quiz {overflow-x: hidden; width: 100%; box-sizing: border-box;} .level-hiraganas {width: 100%; padding: 0; margin: 0; box-sizing: border-box;} .hiraganas-grid {width: 95%; margin: 0 auto; display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; box-sizing: border-box;} .hiragana-card {flex: 1 1 calc((100% - 24px) / 5); min-width: 0; height: 80px; text-align: center; transition: all 0.3s ease; position: relative; padding: 8px 2px; background: var(--white); border-radius: 6px; box-shadow: 0 2px 4px var(--shadow-black-strong), 0 1px 2px var(--shadow-black-light); display: flex; flex-direction: column; justify-content: space-between; box-sizing: border-box;} .hiragana-char {font-size: 1.4em; margin-bottom: 0; line-height: 1.2; word-wrap: break-word; overflow-wrap: break-word; flex-grow: 1; display: flex; align-items: center; justify-content: center;} .stars-container {display: flex; justify-content: center; gap: 1px; width: 100%; padding: 0; margin-top: auto;} .star {width: 10px; height: 10px; flex-shrink: 0;} .quiz-container {flex: 1; display: flex; flex-direction: column; justify-content: flex-start; min-height: 0; padding-bottom: 2em;} .question {font-size: 3em; font-weight: bold; margin: 75px; height: 1.2em; display: flex; align-items: center; justify-content: center; text-shadow: 1px 1px 2px var(--shadow-brown-medium);} .answers {display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; width: 98%; padding: 0; margin: 0 auto 0.6em auto; box-sizing: border-box;} .answers .arcade-button {flex: 1; min-width: 0; width: 100%; font-size: 1.30em; aspect-ratio: 1 / 0.6; box-sizing: border-box; padding: 6px 4px; border-radius: 3px; border: 1px solid transparent; display: flex; align-items: center; justify-content: center; text-align: center;} button, a, input, textarea {-webkit-tap-highlight-color: transparent;} .sakura {width: 10px; height: 10px;} .result {margin-top: 1em; text-align: center; word-break: break-word; white-space: normal; display: block; min-height: auto;} .result > * {width: 100%;} .result-line {font-size: 1.2em; width: 100%; text-align: center;} .result-line.highlight {line-height: 1.0; margin-top: 0.5em; font-size: 1.0em;} #continueBtn {margin-top: 1em; margin-bottom: 1em; height: 3em; border-radius: 8px; border: 4px solid transparent;} #boutonInstaller {margin-top: 1em; margin-bottom: 1em; height: 3em;} .hamburger {position: fixed !important; bottom: 10px !important; right: 10px !important; left: auto !important; top: auto !important; width: 40px !important; height: 40px !important; padding: 10px; display: flex; box-sizing: border-box;} .hamburger-icon {width: 30px; height: 22px; gap: 6px;} .hamburger-bar {height: 4px; background: var(--shadow-brown-medium);} #menu-message {font-size: 1.2em !important; padding: 10px !important; margin-bottom: 100px !important; line-height: 1.2 !important;} .menu .arcade-button {width: 700px !important; font-size: 1.4em !important; padding: 0.2em 1em !important; line-height: 60px !important; height: 60px !important; max-height: 60px !important; border: 2px solid transparent;} @supports (-webkit-appearance: none) {.menu .arcade-button {width: min(80vw, 700px) !important; height: 60px !important; max-height: 60px !important; line-height: 60px !important; padding: 0.2em 1em !important; border: 2px solid transparent;}} #revision-question {font-size: 1em; margin-top: 35px;} #revision-input-display {height: 35px; font-size: 1.8em; width: 80%; padding: 05px; position: fixed; bottom: calc(85vw + 93px); left: 50%; transform: translateX(-50%);} #revision-message {position: fixed; bottom: calc(85vw + 130px); left: 50%; transform: translateX(-50%); width: 80%; text-align: center; line-height: 1.0; font-size: 1.0em; margin-bottom: 0; font-weight: bold;} .revision-keyboard {gap: 7px; grid-template-columns: repeat(5, 1fr); width: 85%; padding: 0 5px; position: fixed; bottom: calc(70px - 3vw); left: 50%; transform: translateX(-50%);} .revision-key {width: 100%; height: auto; aspect-ratio: 1; min-width: 50px; font-size: clamp(2.5em, 8vw, 5em); font-weight: bold; line-height: 1;} .char-card {display: inline-flex; padding: 5px; margin: 5px; border-radius: 8px; min-width: 60px; aspect-ratio: 3 / 4; text-align: center; font-size: 2.2em; font-weight: bold; color: var(--brown-primary); text-shadow: 0 0 3px var(--shadow-brown-light);} #mode2 .title {margin: 0.1em 0; font-size: 1em; text-align: center; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light);} .account-section {padding: 1em;} .pseudo-display {font-size: 1.8em; padding: 0.4em;} .pin-input {font-size: 1.5em; width: 150px;} .pin-label {font-size: 1em;} .account-info-line {font-size: 1em;} .zen-circle-loader {width: 80px; height: 80px; border: 3px solid rgba(139, 111, 71, 0.2); border-top-color: var(--brown-primary);} .bamboo-leaf {font-size: 2em;} .zen-loader-text {font-size: 1em; margin-top: 20px;} .welcome-user-title {font-size: 1.8em;} .welcome-user-subtitle {font-size: 1.1em; margin-top: 15px;} .stats-filters {gap: 5px; margin: 1em auto 0.5em auto;} .filter-btn {font-size: 0.85em !important; padding: 0.5em 0.8em !important;} .stats-table-container {box-shadow: 0 6px 12px var(--shadow-black-dark), 0 3px 6px var(--shadow-black-medium); border-radius: 12px; background: white; margin: 0.5em auto 1em auto; max-height: 50vh;} .stats-table th, .stats-table td {padding: 0.6em 0.3em; font-size: 0.9em;} .stats-table th {font-size: 0.8em; padding: 0.8em 0.3em;} .status-emoji {font-size: 1.5em;} .onboarding-step {padding: 15px 10px;} .onboarding-title {font-size: 1.4em; margin-bottom: 20px;} .onboarding-content {padding: 20px 15px;} .onboarding-subtitle {font-size: 1em; margin-bottom: 20px;} .large-button {font-size: 1em !important; padding: 15px 20px !important; min-height: 55px; width: 100%; box-sizing: border-box;} .small-button {font-size: 0.85em !important; padding: 8px 15px !important;} .pseudo-input-wrapper {padding: 0 10px;} .pseudo-input {font-size: 1.4em; padding: 12px 15px; max-width: 100%;} .pin-input {font-size: 1.8em; padding: 12px 15px; max-width: 200px;} .confirmation-date {font-size: 1.3em;} .confirmation-box {padding: 20px 15px;} .warning-box {padding: 12px;} .warning-box p {font-size: 0.85em;} .onboarding-buttons {gap: 12px; margin-top: 20px;} .birthdate-selectors {gap: 10px;} .selector-group {max-width: 130px;} .birthdate-select {font-size: 1em; padding: 10px 8px;}}
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {h1 {font-size: 2.2em; margin: 0.15em 0;} h2 {font-size: 2.5em; margin: 0.15em 0;} .menu {gap: 15px;} .panda-logo {font-size: 15em;} .welcome-title {font-size: 3em;} .welcome-subtitle {font-size: 2em;} .loading-dots {font-size: 2.5em;} .unlock-progress-bar{height:14px} #progressBarContainer {max-width: 80%; margin: 1.2em auto 0.3em auto; gap: 1em;} .progress-bar-track {height: 20px; border-radius: 8px;} .progress-marker {font-size: 3.2em; top: 45%; transform: translate(-50%, -50%);} .side-emoji {font-size: 3.0em;} .level {font-size: 1.2em; margin: 0.4em 0; margin-bottom: 30px;} #quiz {overflow-x: hidden; width: 100%; box-sizing: border-box;} .level-hiraganas {width: 100%; padding: 0; margin: 0; box-sizing: border-box;} .hiraganas-grid {width: 95%; margin: 0 auto; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; box-sizing: border-box;} .hiragana-card {flex: 1 1 calc((100% - 40px) / 5); min-width: 0; height: 120px; text-align: center; transition: all 0.3s ease; position: relative; padding: 8px 2px; background: var(--white); border-radius: 6px; box-shadow: 0 2px 4px var(--shadow-black-strong), 0 1px 2px var(--shadow-black-light); display: flex; flex-direction: column; justify-content: space-between; box-sizing: border-box;} .hiragana-char {font-size: 2.8em; margin-bottom: 0; line-height: 1.2; word-wrap: break-word; overflow-wrap: break-word; flex-grow: 1; display: flex; align-items: center; justify-content: center;} .stars-container {display: flex; justify-content: center; gap: 4px; width: 100%; padding: 0; margin-top: auto;} .star {width: 16px; height: 16px; flex-shrink: 0;} .quiz-container {flex: 1; display: flex; flex-direction: column; justify-content: flex-start; min-height: 0; padding-bottom: 0.5em;} .question {font-size: 5em; font-weight: bold; margin: 120px; height: 1.2em; display: flex; align-items: center; justify-content: center; text-shadow: 1px 1px 2px var(--shadow-brown-medium);} .answers {display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; width: 95%; padding: 0; margin: 0 auto 0.5em auto; box-sizing: border-box;} .answers .arcade-button {flex: 1; min-width: 0; width: 98%; font-size: 2.5em; aspect-ratio: 1 / 0.5; box-sizing: border-box; padding: 8px 4px; border-radius: 8px; border: 4px solid transparent; display: flex; align-items: center; justify-content: center; text-align: center;} button, a, input, textarea {-webkit-tap-highlight-color: transparent;} .sakura {width: 10px; height: 10px;} .result {margin-top: 1em; text-align: center; word-break: break-word; white-space: normal; display: block; min-height: auto;} .result > * {width: 100%;} .result-line {font-size: 1.8em; width: 100%; text-align: center;} .result-line.highlight {line-height: 1.8; margin-top: 0.4em; font-size: 1.8em;} #continueBtn {
  font-size: 1.8em; 
  margin-top: 1em; 
  margin-bottom: 0.1em; 
  height: 2.4em; 
  border: 4px solid transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
} #boutonInstaller {margin-top: 1em; margin-bottom: 1em; height: 3em;} .hamburger {position: fixed !important; bottom: 20px !important; right: 20px !important; left: auto !important; top: auto !important; width: 66px !important; height: 66px !important; padding: 20px; display: flex; box-sizing: border-box;} .hamburger-icon {width: 36px; height: 28px; gap: 6px;} .hamburger-bar {height: 4px; background: var(--shadow-brown-medium);} #menu-message {font-size: 2.6em !important; padding: 8px !important; margin-bottom: 120px !important; line-height: 1.2 !important;} .menu .arcade-button {width: 400px !important; font-size: 2.6em !important; padding: 0.2em 1em !important; line-height: 100px !important; height: 100px !important; max-height: 100px !important; border: 5px solid transparent;} @supports (-webkit-appearance: none) {.menu .arcade-button {width: min(80vw, 400px) !important; height: 100px !important; max-height: 100px !important; line-height: 50px !important; padding: 0.2em 1em !important; border: 5px solid transparent;}} #revision-question {font-size: 1em; margin-top: 50px;} #revision-input-display {height: 50px; font-size: 3.2em; width: 55%; padding: 05px; position: fixed; bottom: calc(60vw + 120px); left: 50%; transform: translateX(-50%);} #revision-message {position: fixed; bottom: calc(60vw + 185px); left: 50%; transform: translateX(-50%); width: 60%; text-align: center; line-height: 1.0; font-size: 1.5em; margin-bottom: 0; font-weight: bold;} .revision-keyboard {gap: 7px; grid-template-columns: repeat(5, 1fr); width: 60%; padding: 0 5px; position: fixed; bottom: calc(120px - 5vw); left: 50%; transform: translateX(-50%);} .revision-key {width: 100%; height: auto; aspect-ratio: 1; min-width: 50px; font-size: clamp(2.5em, 8vw, 5em); font-weight: bold; line-height: 1;} .char-card {display: inline-flex; padding: 3px; margin: 3px; border-radius: 8px; min-width: 100px; aspect-ratio: 3 / 4; text-align: center; font-size: 4em; font-weight: bold; color: var(--brown-primary); text-shadow: 0 0 3px var(--shadow-brown-light);} #mode2 .title {margin: 0.1em 0; font-size: 1em; text-align: center; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light);} .pseudo-display {font-size: 2.2em;} .pin-input {font-size: 1.8em; width: 180px;} .zen-circle-loader {width: 100px; height: 100px;} .bamboo-leaf {font-size: 2.5em;} .zen-loader-text {font-size: 1.2em;} .welcome-user-title {font-size: 2.5em;} .welcome-user-subtitle {font-size: 1.3em;} .filter-btn {font-size: 1.2em !important; padding: 0.7em 1em !important;} .stats-table-container {max-height: 55vh;} .stats-table th, .stats-table td {padding: 0.9em; font-size: 1.1em;} .status-emoji {font-size: 1.6em;} .onboarding-buttons {width: 400px !important; display: flex; flex-direction: column; gap: 15px; margin-top: 30px;}}
@media screen and (max-width: 768px), screen and (-webkit-min-device-pixel-ratio: 2) {#mode2 .title {margin: 0.1em 0; font-size: 1em; text-align: center; color: var(--brown-primary); text-shadow: 0 1px 2px var(--shadow-brown-light);}}  
@supports(padding-top:env(safe-area-inset-top)){#unlock-progress-container{top:max(12px,env(safe-area-inset-top))}}
/* ====================== MON JARDIN ====================== */
#stats h1 { margin-bottom: 0.2em; font-size: 2.2em; }
.garden-legend { position: sticky; top: 0; background: var(--beige-background); padding: 0.6em 1em; font-size: 1em; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); z-index: 10; opacity: 0; transition: opacity 0.4s; display: flex; justify-content: center; gap: 2em; border-bottom: 2px solid var(--brown-primary); }
.garden-legend.visible { opacity: 1; }
.garden-container { flex: 1; overflow-y: auto; background: #F8F1E9; position: relative; -webkit-overflow-scrolling: touch; }
.garden-ground { min-height: 100%; padding: 2em 1em 2em; display: flex; flex-direction: column-reverse; gap: 4em; align-items: center; background: #F8F1E9; overflow: visible; }
.garden-level { display: grid; grid-template-columns: repeat(5, 1fr); gap: 1.8em; justify-items: center; max-width: 100%; }
.garden-item { display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.2s; width: 100%; aspect-ratio: 1; min-width: 0; }
.garden-item:hover { transform: scale(1.15); }
.garden-plant { font-size: 3.4em; margin-bottom: 0.1em; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2)); transition: all 0.4s ease; }
.garden-hiragana { font-size: 1.4em; font-weight: bold; color: var(--brown-primary); }
.garden-decor { position: absolute; font-size: 3em; opacity: 0.4; pointer-events: none; z-index: 1; }
.garden-bug { display: flex; align-items: center; justify-content: center; opacity: 0.85; }
.garden-modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s; pointer-events: none; }
.garden-modal.visible { opacity: 1; visibility: visible; pointer-events: auto; }
.garden-card { background: var(--white); padding: 2em 2.5em; border-radius: 20px; text-align: center; max-width: 90%; box-shadow: 0 20px 40px rgba(0,0,0,0.3); }
.garden-card h2 { margin: 0 0 0.5em; font-size: 3.5em; }
.garden-card .katakana { font-size: 2.2em; margin: 0.6em 0; color: #8B6F47; }
.garden-card .romaji { font-size: 1.8em; margin: 0.8em 0; color: #555; }
.garden-card .info { margin: 1em 0; font-size: 1.2em; }
.garden-card .close-btn { margin-top: 1.5em; padding: 0.8em 2em; font-size: 1.2em; }
@media (max-width: 480px) and (-webkit-min-device-pixel-ratio: 2) { .garden-plant { font-size: 2.0em; } .garden-bug { font-size: 0.8em; } .garden-hiragana { font-size: 1.0em; } .garden-level { gap: 0.5em; grid-template-columns: repeat(5, 1fr); padding: 0 0.5em; width: 95%; } .garden-item { aspect-ratio: 1; } }
@media (min-width: 481px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) { .garden-plant { font-size: 2.7em; } .garden-hiragana { white-space: nowrap; font-size: 1.2em; } .garden-level { gap: 3.5em; grid-template-columns: repeat(5, 1fr); padding: 0 0.5em; width: 90%; } .garden-legend { gap: 1em; font-size: 0.9em; } }
/* Animation pour le changement de statut de la plante (bloom/rotation subtile) */
.plant-status-change{animation:plantBloom .5s ease-in-out}@keyframes plantBloom{0%{transform:scale(1) rotate(0deg);opacity:.8}50%{transform:scale(1.2) rotate(5deg);opacity:1}100%{transform:scale(1) rotate(0deg);opacity:1}}.score-sparkle{animation:sparkle .6s ease-in-out;color:#FFD700}@keyframes sparkle{0%{transform:scale(1);opacity:1;text-shadow:0 0 5px #FFD700}50%{transform:scale(1.1);opacity:.7;text-shadow:0 0 10px #FFD700}100%{transform:scale(1);opacity:1;text-shadow:0 0 5px #FFD700}}#mode2.active #garden-modal,#mode2 #garden-modal.visible{z-index:9999!important;position:fixed!important;top:50%!important;left:50%!important;transform:translate(-50%,-50%)!important}#mode2 .revision-keyboard,#mode2 #revision-input-display,#mode2 #revision-message{z-index:100!important}#modal-portal{position:fixed!important;top:0!important;left:0!important;width:100%!important;height:100%!important;z-index:99999!important;display:none;align-items:center;justify-content:center;pointer-events:none}#modal-portal.active{display:flex!important;pointer-events:auto!important}#modal-portal .revision-flashcard{padding:2.8em 3.2em;border-radius:28px;box-shadow:0 30px 60px rgba(0,0,0,.5);text-align:center;max-width:90%;background-color:#fff;animation:popIn .6s ease-out forwards}@media (max-width:480px) and (-webkit-min-device-pixel-ratio:2){#modal-portal .revision-flashcard{padding:2em 2.5em;border-radius:20px;max-width:85%}#modal-portal .revision-flashcard .romaji-display{font-size:3em!important}#modal-portal .revision-flashcard .score-display{font-size:2em!important}#modal-portal .revision-flashcard .plant-display{font-size:3.5em!important}#modal-portal .revision-flashcard .char-display{font-size:1.8em!important}}@media (min-width:481px) and (max-width:1024px) and (-webkit-min-device-pixel-ratio:2){#modal-portal .revision-flashcard{padding:2.5em 3em;max-width:80%}}@keyframes popIn{from{opacity:0;transform:scale(.7)}to{opacity:1;transform:scale(1)}}@keyframes rollUp{from{top:0}to{top:-70px}}@keyframes rollDown{from{top:0}to{top:70px}}@keyframes rollInUp{from{top:70px}to{top:0}}@keyframes rollInDown{from{top:-70px}to{top:0}}.contact-form-container,.contact-inbox-container{max-width:600px;margin:0 auto;padding:1em;overflow-y:auto;overflow-x:hidden;max-height:calc(100vh - 2em);box-sizing:border-box}.contact-subtitle{font-size:1.1em;color:var(--brown-primary);margin-bottom:1.5em;text-align:center}.contact-category{margin-bottom:1.5em}.contact-category label{display:block;font-weight:bold;color:var(--brown-primary);margin-bottom:.5em;font-size:1.1em}.contact-select{width:100%;padding:.8em;font-size:1.1em;border:2px solid var(--brown-primary);border-radius:8px;background:var(--white);color:var(--brown-primary);font-family:inherit;cursor:pointer}.contact-textarea{width:100%;min-height:150px;padding:1em;font-size:1.1em;border:2px solid var(--brown-primary);border-radius:8px;background:var(--white);color:var(--brown-primary);font-family:inherit;resize:vertical;box-sizing:border-box;word-wrap:break-word;overflow-wrap:break-word}.contact-textarea.small{min-height:100px}.contact-textarea:focus,.contact-select:focus,.contact-input:focus{outline:none;border-color:var(--green-primary);box-shadow:0 0 8px var(--overlay-green-30)}.char-counter{text-align:right;font-size:.9em;color:var(--gray-dark);margin-top:.3em;margin-bottom:1em}.contact-field{margin-bottom:1.5em}.contact-field label{display:block;font-weight:bold;color:var(--brown-primary);margin-bottom:.5em;font-size:1.1em}.contact-input{width:100%;padding:.8em;font-size:1.1em;border:2px solid var(--brown-primary);border-radius:8px;background:var(--white);color:var(--brown-primary);font-family:inherit;box-sizing:border-box;word-wrap:break-word;overflow-wrap:break-word}.contact-file-input{width:100%;max-width:100%;padding:.8em;font-size:1em;border:2px dashed var(--brown-primary);border-radius:8px;background:var(--beige-light);cursor:pointer;box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.file-info{font-size:.9em;color:var(--gray-dark);margin-top:.5em}.error-message{background:var(--pink-pale);border:2px solid var(--pink-primary);color:var(--brown-primary);padding:1em;border-radius:8px;margin:1em 0;text-align:center;font-weight:bold}.success-message{background:var(--green-pale);border:2px solid var(--green-primary);color:var(--green-dark);padding:1em;border-radius:8px;margin:1em 0;text-align:center;font-weight:bold}#contact-inbox-btn{position:relative}#contact-inbox-btn .notification-badge{position:absolute;top:-5px;right:-5px;background:var(--red-progress);color:var(--white);font-size:.8em;font-weight:bold;padding:.2em .5em;border-radius:50%;min-width:20px;text-align:center}.inbox-empty{text-align:center;padding:3em 1em;color:var(--gray-dark);font-size:1.2em}.inbox-messages{display:flex;flex-direction:column;gap:1em;overflow-y:auto;max-height:calc(100vh - 200px);padding-right:.5em}.message-card{background:var(--white);border:2px solid var(--brown-primary);border-radius:12px;padding:1.2em;box-shadow:0 4px 8px var(--shadow-black-medium);transition:all .3s ease}.message-card.unread{background:var(--green-subtle-2);border-color:var(--green-primary)}.message-card:hover{transform:translateY(-2px);box-shadow:0 6px 12px var(--shadow-black-strong)}.message-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:.8em;padding-bottom:.8em;border-bottom:1px solid var(--gray-light)}.message-type{font-size:.9em;font-weight:bold;color:var(--brown-primary);padding:.3em .8em;background:var(--beige-light);border-radius:20px}.message-date{font-size:.85em;color:var(--gray-dark)}.message-content{color:var(--gray-text);line-height:1.6;margin-bottom:1em;word-wrap:break-word;overflow-wrap:break-word;max-width:100%}.message-response{background:var(--green-subtle-3);border-left:4px solid var(--green-primary);padding:1em;border-radius:8px;margin-top:1em}.response-header{font-weight:bold;color:var(--green-dark);margin-bottom:.5em;display:flex;align-items:center;gap:.5em}.response-text{color:var(--gray-text);line-height:1.6;word-wrap:break-word;overflow-wrap:break-word;max-width:100%}@media (max-width:480px) and (-webkit-min-device-pixel-ratio:2){.contact-form-container,.contact-inbox-container{padding:.5em;max-height:none;min-height:100dvh;overflow-y:auto}.contact-textarea{font-size:1em;min-height:120px}.message-card{padding:1em}.inbox-messages{max-height:calc(100vh - 150px)}}body,html{margin:0;padding:0;height:100%;overflow:hidden;font-family:sans-serif}#rotation-toast{position:fixed;inset:0;background:rgba(0,0,0,.88);color:#fff;display:none;align-items:center;justify-content:center;flex-direction:column;z-index:9999}.phone{width:84px;height:150px;border:6px solid #fff;border-radius:16px;position:relative;margin-bottom:32px;animation:rot 2.5s infinite ease-in-out}.phone::before{content:"";position:absolute;top:12px;left:50%;transform:translateX(-50%);width:36px;height:6px;background:#fff;border-radius:3px}.phone::after{content:"";position:absolute;bottom:14px;left:50%;transform:translateX(-50%);width:44px;height:44px;background:#fff;border-radius:50%;opacity:.15}@keyframes rot{0%,100%{transform:rotate(0deg)}50%{transform:rotate(-90deg)}}.text{font-size:18px;text-align:center}.small{font-size:14px;margin-top:8px;opacity:.8}@media screen and (orientation:landscape) and (max-width:1024px){#rotation-toast{display:flex}}.sound-controls{padding:2em 1em;max-width:400px;margin:0 auto}.sound-control-item{background:var(--overlay-green-05);border-radius:20px;padding:2em 1.5em;margin-bottom:1.5em;display:flex;flex-direction:column;align-items:center;gap:1.2em;transition:all .3s ease}.sound-control-item:hover{background:var(--overlay-green-08);transform:translateY(-2px)}.sound-label{display:flex;flex-direction:column;align-items:center;gap:.5em}.sound-icon{font-size:4em;filter:grayscale(20%);transition:all .3s ease}.sound-control-item:hover .sound-icon{filter:grayscale(0%);transform:scale(1.1)}.sound-label span:last-child{font-size:1.1em;font-weight:600;color:var(--brown-primary);text-shadow:0 1px 2px var(--shadow-brown-light)}.sound-toggle{display:flex;align-items:center;gap:1em}.sound-status{font-size:1.8em;transition:all .3s ease}.switch{position:relative;display:inline-block;width:70px;height:40px}.switch input{opacity:0;width:0;height:0}.slider-round{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,var(--gray-light) 0%,var(--gray-medium) 100%);transition:.4s;border-radius:40px;box-shadow:inset 0 2px 4px var(--shadow-black-light)}.slider-round:before{position:absolute;content:"";height:32px;width:32px;left:4px;bottom:4px;background:linear-gradient(135deg,var(--white) 0%,var(--beige-light) 100%);transition:.4s;border-radius:50%;box-shadow:0 2px 4px var(--shadow-black-medium)}input:checked + .slider-round{background:linear-gradient(135deg,var(--green-gradient-start) 0%,var(--green-gradient-end) 100%)}input:checked + .slider-round:before{transform:translateX(30px);box-shadow:0 2px 6px var(--shadow-black-strong)}input:focus + .slider-round{box-shadow:0 0 8px var(--green-bright)}.difficulty-stars{display:inline-flex;gap:4px;margin-left:8px;vertical-align:middle}.difficulty-star{font-size:.8em;transition:all .3s ease}.difficulty-star.lit{color:#FFD700;text-shadow:0 0 10px #FFD700,0 0 20px #FFA500;filter:brightness(1.5)}.difficulty-star.unlit{color:rgba(139,111,71,.3);filter:grayscale(100%)}.arcade-button.difficulty-selected{background:linear-gradient(135deg,rgba(168,213,186,.3),rgba(253,193,197,.3))!important;border-color:var(--green-primary)!important;box-shadow:0 6px 12px var(--shadow-black-dark),inset 0 0 20px rgba(168,213,186,.2)!important}@keyframes kawaii-bounce{0%,100%{transform:scale(1) rotate(0deg)}25%{transform:scale(1.1) rotate(-5deg)}50%{transform:scale(1.2) rotate(5deg)}75%{transform:scale(1.1) rotate(-3deg)}}@keyframes sparkle{0%,100%{opacity:0;transform:scale(0) rotate(0deg)}50%{opacity:1;transform:scale(1) rotate(180deg)}}.unlock-flashcard{background:linear-gradient(135deg,#d4edda 0%,#f8f1e9 100%);padding:3em;border-radius:24px;text-align:center;position:relative;overflow:hidden}.unlock-emoji{font-size:5em;animation:kawaii-bounce 1s ease-in-out infinite;display:inline-block;margin-bottom:.3em}.unlock-sparkles{position:absolute;font-size:2em;animation:sparkle 2s ease-in-out infinite}.unlock-sparkles:nth-child(1){top:10%;left:10%;animation-delay:0s}.unlock-sparkles:nth-child(2){top:10%;right:10%;animation-delay:.3s}.unlock-sparkles:nth-child(3){bottom:15%;left:15%;animation-delay:.6s}.unlock-sparkles:nth-child(4){bottom:15%;right:15%;animation-delay:.9s}.unlock-title{font-size:2em;font-weight:bold;color:var(--brown-primary);margin:.5em 0;text-shadow:0 2px 4px rgba(0,0,0,.1)}.unlock-message{font-size:1.3em;color:var(--gray-dark);margin-top:1em}.menu-emoji-header{display:flex;align-items:center;justify-content:center;height:25vh;min-height:90px;pointer-events:none}.menu-emoji-header span{display:inline-block;font-size:6.5rem;line-height:1;opacity:0;transform:scale(.9);transition:opacity .6s ease,transform .6s ease}.menu.active .menu-emoji-header span{opacity:1;transform:scale(1);animation:zen-breath 7s ease-in-out infinite}@keyframes zen-breath{0%{transform:scale(1)}50%{transform:scale(1.035)}100%{transform:scale(1)}}.contact-emoji-buttons{display:flex;flex-direction:column;justify-content:center;align-items:center;gap:1.5em;margin:2em 0}.emoji-button{font-size:4.5em;background:none;border:none;cursor:pointer;transition:all .3s ease;padding:.3em;border-radius:20px;position:relative;filter:drop-shadow(0 4px 8px rgba(0,0,0,.15))}.emoji-button:hover{transform:scale(1.15) rotate(-5deg);filter:drop-shadow(0 8px 16px rgba(0,0,0,.25))}.emoji-button:active{transform:scale(.95)}.emoji-button .notification-badge{position:absolute;top:0;right:0;background:#dc3545;color:#fff;font-size:.35em;font-weight:bold;border-radius:50%;width:1.2em;height:1.2em;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 4px rgba(0,0,0,.3)}img.emoji{display:inline-block;height:1em;width:1em;margin:0 .05em 0 .1em;vertical-align:-.1em}.result-emoji img.emoji{width:4rem;height:4rem;vertical-align:middle}.panda-logo img.emoji{width:1em;height:1em}.menu-emoji-header img.emoji{width:6.5rem;height:6.5rem}.emoji-button img.emoji{width:1em;height:1em}.garden-plant img.emoji{width:1em;height:1em}.unlock-emoji img.emoji{width:1em;height:1em}.progress-marker img.emoji{width:1em;height:1em}.side-emoji img.emoji{width:1em;height:1em}@keyframes plantShake{0%,100%{transform:translate(0,0) rotate(0deg)}25%{transform:translate(-3px,0) rotate(-3deg)}50%{transform:translate(3px,0) rotate(3deg)}75%{transform:translate(-3px,0) rotate(-3deg)}}@keyframes plantPop{0%{opacity:0;transform:translate(-50%,-50%) scale(0) rotate(0deg);filter:brightness(.5)}60%{transform:translate(-50%,-50%) scale(1.3) rotate(-5deg);filter:brightness(1.5)}80%{transform:translate(-50%,-50%) scale(.95) rotate(5deg)}100%{opacity:1;transform:translate(-50%,-50%) scale(1) rotate(0deg);filter:brightness(1)}}@keyframes plantShakeCrescendo{0%{transform:translate(0,0) rotate(0deg)}10%{transform:translate(-1px,0) rotate(-1deg)}20%{transform:translate(1px,0) rotate(1deg)}30%{transform:translate(-2px,0) rotate(-2deg)}40%{transform:translate(2px,0) rotate(2deg)}50%{transform:translate(-3px,0) rotate(-3deg)}60%{transform:translate(3px,0) rotate(3deg)}70%{transform:translate(-5px,0) rotate(-5deg)}80%{transform:translate(5px,0) rotate(5deg)}90%{transform:translate(-7px,0) rotate(-7deg)}100%{transform:translate(7px,0) rotate(7deg)}}@keyframes plantPop{0%{opacity:0;transform:translate(-50%,-50%) scale(0) rotate(0deg);filter:brightness(.5)}60%{transform:translate(-50%,-50%) scale(1.3) rotate(-5deg);filter:brightness(1.5)}80%{transform:translate(-50%,-50%) scale(.95) rotate(5deg)}100%{opacity:1;transform:translate(-50%,-50%) scale(1) rotate(0deg);filter:brightness(1)}}.wobble{animation:wobbleFlashcard 500ms ease-in forwards}@keyframes wobbleFlashcard{0%{transform:translate(0) rotate(0)}20%{transform:translate(-1px) rotate(-1deg)}40%{transform:translate(1px) rotate(1deg)}60%{transform:translate(-3px) rotate(-3deg)}80%{transform:translate(4px) rotate(4deg)}100%{transform:translate(-6px) rotate(-6deg)}}.explode{transition:transform .12s ease-out,opacity .12s,filter .12s;transform:scale(2) rotate(160deg);opacity:0;filter:blur(14px) brightness(2.5)}.pop{animation:popFlashcard .45s cubic-bezier(.68,-.55,.25,1.55) forwards}@keyframes popFlashcard{0%{opacity:0;transform:scale(0) rotate(0);filter:brightness(.6)}60%{transform:scale(1.3) rotate(-6deg);filter:brightness(1.6)}100%{opacity:1;transform:scale(1) rotate(0);filter:brightness(1)}}.jelly{animation:jellyFlashcard 1.25s cubic-bezier(.25,1.6,.4,1)}@keyframes jellyFlashcard{0%{transform:scale(1,1) rotate(0)}15%{transform:scale(1.45,.6) rotate(-14deg)}35%{transform:scale(.8,1.3) rotate(10deg)}55%{transform:scale(1.25,.9) rotate(-8deg)}75%{transform:scale(.95,1.05) rotate(4deg)}100%{transform:scale(1,1) rotate(0)}}.sparkle-flashcard{position:absolute;font-size:22px;pointer-events:none;animation:sparkleFlashcard 1.3s ease-out forwards}@keyframes sparkleFlashcard{from{opacity:1;transform:translate(0,0) scale(1)}to{opacity:0;transform:translate(var(--x),var(--y)) scale(.2) rotate(360deg)}}.shine-flashcard{position:absolute;inset:-30px;background:linear-gradient(120deg,transparent 100%,rgba(255,255,255,.95) 50%,transparent 60%);animation:shineFlashcard .8s ease-out;pointer-events:none;z-index:1}@keyframes shineFlashcard{from{transform:translateX(-180%)}to{transform:translateX(180%)}}.plant-emoji{display:inline-block}.insect-card{background:linear-gradient(180deg,#f7fff5,#fff)}

/* Highlight temporaire pour le tuto - VERSION RADAR CONTINU */
.tutorial-highlight {
  animation: tutorialPulse 1s ease-out infinite !important;
  z-index: 10 !important;
  position: relative;
  border-radius: 12px !important;
}

@keyframes tutorialPulse {
  0% { 
    box-shadow: 0 0 0 0 rgba(168, 213, 186, 1),
                0 0 30px 8px rgba(168, 213, 186, 0.8),
                inset 0 0 20px 2px rgba(168, 213, 186, 0.3);
    transform: scale(1);
  }
  100% { 
    box-shadow: 0 0 0 30px rgba(168, 213, 186, 0),
                0 0 60px 25px rgba(168, 213, 186, 0),
                inset 0 0 0 0 rgba(168, 213, 186, 0);
    transform: scale(1.0);
  }
}

/* Point actif du tuto */
.tutorial-dot {
  width: 10px;
  height: 10px;
  background: var(--gray-light);
  border-radius: 50%;
  transition: background 0.3s;
}
.tutorial-dot.active {
  background: var(--green-primary);
}


/* Fade-in doux pour la carte tuto */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}
.hamburger.tutorial-highlight {
  position: static !important;  /* ou revert, ou la valeur d'origine */
  transform: none !important;
  left: auto !important;
  top: auto !important;
}
/* Animation spéciale pour la démo du tuto */
.tutorial-demo-glow {
  animation: demoGlow 2s ease-in-out infinite;
}

@keyframes demoGlow {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(168, 213, 186, 0.6),
                inset 0 0 10px rgba(168, 213, 186, 0.3);
  }
  50% { 
    box-shadow: 0 0 40px rgba(168, 213, 186, 0.9),
                inset 0 0 20px rgba(168, 213, 186, 0.5);
  }
}
/* Highlight spécial pour le bouton hamburger (garde le position fixed) */
.tutorial-highlight-hamburger {
  animation: tutorialPulse 1.2s ease-out infinite !important;
  z-index: 1001 !important; /* Au-dessus du menu */
  border-radius: 12px !important;
  /* ❌ PAS de position: relative ici */
}  

.quiz-flash-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--beige-background);
  z-index: 1;
}

.quiz-flash-header {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
  text-align: center;
}

.quiz-flash-counter {
  font-size: 1.8em;
  font-weight: bold;
  color: var(--white);
  background: var(--brown-primary);
  padding: 8px 20px;
  border-radius: 25px;
  margin-bottom: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.quiz-flash-group {
  font-size: 1.2em;
  color: var(--white);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.quiz-flash-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10;
  perspective: 1000px;
}

.quiz-flash-card {
  width: 400px;
  height: 450px;
  position: relative;
  animation: subtlePulse 2s ease-in-out infinite;
}

.flash-card-inner {
  width: 100%;
  height: 100%;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

.quiz-flash-card.flipped .flash-card-inner {
  transform: rotateY(180deg);
}

.flash-card-front,
.flash-card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  background: var(--white);
  
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.flash-card-back {
  transform: rotateY(180deg);
}

.flash-hiragana {
  font-size: 12em;
  font-weight: bold;
  color: var(--brown-primary);
  line-height: 1;
}

.flash-hiragana-small {
  font-size: 4em;
  font-weight: bold;
  color: var(--brown-primary);
  margin-bottom: 20px;
}

.flash-romaji {
  font-size: 5em;
  font-weight: bold;
  color: var(--brown-primary);
}

.quiz-flash-timer {
  margin-top: 50px;
  width: 400px;
  height: 24px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 12px;
  position: relative;
  overflow: hidden;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
}

/* Timer simplifié et performant */
.timer-bar {
  height: 100%;
  width: 100%;
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  border-radius: 10px;
  transition: width 0.1s linear, background 0.3s;
  position: relative;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.6),
              inset 0 2px 6px rgba(255, 255, 255, 0.4);
  will-change: width;
}

/* Pulse léger */
@keyframes timerPulse {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.2); }
}

@keyframes timerShine {
  0% { left: -100%; }
  100% { left: 150%; }
}

/* Flash initial quand la barre apparaît */
.timer-bar.flash-start {
  animation: flashGlow 0.3s ease-out;
}

/* Gardez juste le flash initial */
@keyframes flashGlow {
  0% { 
    filter: brightness(2.5);
    transform: scale(1.05);
  }
  100% { 
    filter: brightness(1);
    transform: scale(1);
  }
}

.timer-bar.warning {
  background: linear-gradient(90deg, #FFC107, #FFB300);
  box-shadow: 0 0 20px rgba(255, 193, 7, 0.6),
              inset 0 2px 6px rgba(255, 255, 255, 0.4);
  animation: timerPulseWarning 1s ease-in-out infinite;
}

@keyframes timerPulseWarning {
  0%, 100% { 
    box-shadow: 0 0 15px rgba(255, 193, 7, 0.4),
                inset 0 2px 6px rgba(255, 255, 255, 0.3);
    filter: brightness(1);
  }
  50% { 
    box-shadow: 0 0 30px rgba(255, 193, 7, 0.8),
                inset 0 2px 6px rgba(255, 255, 255, 0.5);
    filter: brightness(1.2);
  }
}

.timer-bar.danger {
  background: linear-gradient(90deg, #FF5722, #F44336);
  box-shadow: 0 0 20px rgba(255, 87, 34, 0.8),
              inset 0 2px 6px rgba(255, 255, 255, 0.4);
  animation: timerPulseDanger 0.6s ease-in-out infinite;
}

@keyframes timerPulseDanger {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(255, 87, 34, 0.5),
                inset 0 2px 6px rgba(255, 255, 255, 0.3);
    filter: brightness(1);
  }
  50% { 
    box-shadow: 0 0 40px rgba(255, 87, 34, 1),
                inset 0 2px 6px rgba(255, 255, 255, 0.6);
    filter: brightness(1.3);
  }
}

@keyframes subtlePulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

@media (max-width: 480px) {
  .quiz-flash-card {
    width: 320px;
    height: 380px;
  }
  
  .quiz-flash-timer {
    width: 320px;
    margin-top: 50px;
  }
  
  .flash-hiragana {
    font-size: 10em;
  }
  
  .flash-hiragana-small {
    font-size: 3em;
  }
  
  .flash-romaji {
    font-size: 4em;
  }
  
  .quiz-flash-counter {
    font-size: 1.4em;
  }
  
  .quiz-flash-group {
    font-size: 1em;
  }
}

.timer-bar.no-transition {
  transition: none !important;
}
.timer-bar.flash-start {
  animation: flashGlow 0.3s ease-out, subtlePulse 0.3s ease-out;
}
.timer-bar.no-shine::after {
  animation: none !important;
  opacity: 0; /* optionnel : fait disparaître la lueur complètement */
}

.timer-pop-effect {
  animation: timerPopBounce 0.3s ease-out;
}

@keyframes timerPopBounce {
  0% { transform: scale(1.1, 1.8); }

  100% { transform: scale(1); }
}

</style>
</head>
<body>
    <div id="rotation-toast">
    <div class="phone"></div>
    <div class="text">
      🔒</div>
    </div>
  </div>

  <script>
  console.log('🔍 TEST - Langue navigateur:', navigator.language);
  console.log('🔍 TEST - localStorage avant:', localStorage.getItem('appLanguage'));
</script>
  <!-- Bouton hamburger  <button class="hamburger" onclick="toggleMenu()">☰</button>  -->
<!-- Bouton hamburger -->
<button class="hamburger" onclick="toggleMenu()">

  <div class="hamburger-icon">
    <div class="hamburger-bar"></div>
    <div class="hamburger-bar"></div>
    <div class="hamburger-bar"></div>
  </div>
</button>
<!-- Menu -->
<nav class="menu" id="menu">
<div id="menu-emoji-header" class="menu-emoji-header">
  <span id="menu-emoji"></span>
</div>
  
    <button class="arcade-button" onclick="showSection('quiz')" data-i18n="menu_learn">Apprendre</button>
  <button class="arcade-button" id="revision-button" onclick="showSection('mode2')" data-i18n="menu_revision">Mode révisions</button>
  <button class="arcade-button" onclick="showQuizFlashMenu()" data-i18n="menu_quiz_flash">Quiz Flash</button>
  <button class="arcade-button" onclick="showSection('stats')" data-i18n="menu_stats">Mes stats</button>
  <button class="arcade-button" onclick="showSection('options')" data-i18n="menu_options">Options</button>
</nav>

<!-- Section Page d'accueil -->
<div id="welcome" class="section active">
  <div class="panda-logo" onclick="">🐼</div>
  <h1 class="welcome-title" data-i18n="welcome_title">🎌🌸 Kanas-Zen-Garden 🌸🎌</h1>
  <p class="welcome-subtitle" data-i18n="welcome_subtitle">Apprenez à lire le Japonais</p>
  <div class="loading-dots" id="loadingText" data-i18n="welcome_loading_dots">(Chargement... )</div>

<!-- ✅ NOUVEAU : Barre de progression -->
<div id="loading-progress-container" style="display: none; width: 80%; max-width: 400px; margin: 20px auto;">
  <div style="background: rgba(139, 111, 71, 0.2); border-radius: 10px; overflow: hidden; height: 10px;">
    <div id="loading-progress-fill" style="background: linear-gradient(90deg, #d4edda, #d4edda); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
  </div>
<!--   <div id="loading-message" style="text-align: center; margin-top: 10px; font-size: 1em; color: #8B6F47;"></div> -->
</div>
</div>
  <!-- Section Menu -->


<!-- Section Quiz -->
<div id="quiz" class="section">
<!--   <h1 data-i18n="quiz_title">🎌⛩️ Apprenez les Kanas ⛩️🎌</h1>  -->
  <div id="progressBarContainer"></div>
  <div class="level" id="levelDisplay"><span data-i18n="quiz_level_display">Niveau actuel :</span> <span id="levelNumber">1</span></div>
    <div class="level-hiraganas">
      <div class="hiraganas-grid" id="hiraganaCards"></div>
    </div>
    <div class="quiz-container">
      <div class="question" id="question" data-i18n="quiz_question_load">load...</div>
      <div>
        <div class="answers" id="choices1"></div>
        <div class="answers" id="choices2"></div>
      </div>
      <div>
        <div class="result" id="result"></div>
  <button class="arcade-button" id="continueBtn" onclick="nextQuestion()" data-i18n="quiz_continue">🌱 OK... j'ai capté 🌱</button>
  <button class="arcade-button" id="boutonInstaller" data-i18n="quiz_install">Ajouter à l'écran d'accueil</button>
</div>
    </div>
  </div>

  <!-- Section Mode Katakana -->
<!-- Section Mode révisions -->
<div id="mode2" class="section">
<!--  <h2 data-i18n="revision_title">🎌⛩️ Réviser les Kanas ⛩️🎌</h2>  -->
<div id="unlock-progress-container" class="unlock-progress-container" style="display: none;">
  <div class="unlock-progress-bar">
    <div class="unlock-progress-fill" id="unlock-progress-fill"></div>
  </div>
</div>

  <div id="revision-question"></div>
  
  <div id="revision-input-display"></div>
    <div class="revision-keyboard">
    <div class="revision-key">a</div>
    <div class="revision-key">i</div>
    <div class="revision-key">u</div>
    <div class="revision-key">e</div>
    <div class="revision-key">o</div>
    <div class="revision-key">k</div>
    <div class="revision-key">g</div>
    <div class="revision-key">y</div>
    <div class="revision-key">h</div>
    <div class="revision-key">f</div>
    <div class="revision-key">t</div>
    <div class="revision-key">ts</div>
    <div class="revision-key">d</div>
    <div class="revision-key">b</div>
    <div class="revision-key">p</div>
    <div class="revision-key">s</div>
    <div class="revision-key">sh</div>
    <div class="revision-key">z</div>
    <div class="revision-key">j</div>
    <div class="revision-key">ch</div>
    <div class="revision-key">m</div>
    <div class="revision-key">n</div>
    <div class="revision-key">r</div>
    <div class="revision-key">w</div>
    <div class="revision-key" id="revision-back">←</div>
  </div>

</div>

<!-- Section Options -->
<div id="options" class="section">
  <h1 data-i18n="options_title">Options</h1>
  <div class="options-menu">
    <button class="arcade-button" onclick="showSubOptions('difficulty')" data-i18n="options_difficulty">Difficulté</button>
    <button class="arcade-button" onclick="showSubOptions('sound')" data-i18n="options_sound">Son</button>
    <button class="arcade-button" onclick="showSubOptions('language')" data-i18n="options_language">Langue</button>
    <button class="arcade-button" onclick="showSubOptions('contact')" data-i18n="contact_title">📨 Contact</button>
    <button class="arcade-button" onclick="showSection('account')" data-i18n="account_title">Mon compte</button>
  </div>

<!-- Sous-rubrique Difficulté -->
<div id="options-difficulty" class="options-sub hidden">
  <h2 data-i18n="options_difficulty">Difficulté</h2>
    <button class="arcade-button difficulty-btn" onclick="setDifficulty(6)" data-difficulty="6">
       <span class="difficulty-stars">
      <span class="difficulty-star">⭐</span>
    </span>
  </button>  
  <button class="arcade-button difficulty-btn" onclick="setDifficulty(8)" data-difficulty="8">
    <span class="difficulty-stars">
      <span class="difficulty-star">⭐</span>
      <span class="difficulty-star">⭐</span>
    </span>
  </button>
    <button class="arcade-button difficulty-btn" onclick="setDifficulty(10)" data-difficulty="10">
      <span class="difficulty-stars">
      <span class="difficulty-star">⭐</span>
      <span class="difficulty-star">⭐</span>
      <span class="difficulty-star">⭐</span>
    </span>
  </button>  
</div>

<!-- Sous-rubrique Son -->
<div id="options-sound" class="options-sub hidden">
<!--  <button class="arcade-button" onclick="backToOptions()" data-i18n="options_back">← Retour</button> -->
  <h2 data-i18n="options_sound">Son</h2>
  
  <div class="sound-controls">
    <!-- Contrôle des sons du jeu -->
    <div class="sound-control-item">
      <div class="sound-label">
        <span class="sound-icon">🙉</span>
        <span data-i18n="sound_game_effects">Sons du jeu</span>
      </div>
      <div class="sound-toggle">
        <label class="switch">
          <input type="checkbox" id="sound-slider" checked onchange="toggleSound(this.checked)">
          <span class="slider-round"></span>
        </label>
        <span id="sound-status" class="sound-status">🔊</span>
      </div>
    </div>
    
    <!-- Contrôle des synthèses vocales -->
    <div class="sound-control-item">
      <div class="sound-label">
        <span class="sound-icon">🙊</span>
        <span data-i18n="sound_voice_synthesis">Synthèses vocales</span>
      </div>
      <div class="sound-toggle">
        <label class="switch">
          <input type="checkbox" id="voice-slider" checked onchange="toggleVoice(this.checked)">
          <span class="slider-round"></span>
        </label>
        <span id="voice-status" class="sound-status">🔊</span>
      </div>
    </div>
  </div>
</div>
  
<!-- Sous-rubrique Langue -->
<div id="options-language" class="options-sub hidden">
<!--  <button class="arcade-button" onclick="backToOptions()"><span data-i18n="options_back">← Retour</span></button> -->
  <h2 data-i18n="options_language">Langue</h2>
  <button class="arcade-button" onclick="setLanguage('fr')">🇫🇷 Français</button>
  <button class="arcade-button" onclick="setLanguage('en')">🇬🇧 English</button>
  <button class="arcade-button" onclick="setLanguage('es')">🇪🇸 Español</button>
</div>
  <!-- Sous-rubrique Contact -->
<div id="options-contact" class="options-sub hidden">
<!--  <button class="arcade-button" onclick="backToOptions()"><span data-i18n="options_back">← Retour</span></button> -->
  <h2 data-i18n="contact_title">Contact & Support</h2>
  
  <div class="contact-emoji-buttons">
    <button class="emoji-button" onclick="showContactForm('message')" data-i18n="contact_send_message">
      💬
    </button>
    <button class="emoji-button" onclick="showContactForm('bug')" data-i18n="contact_report_bug">
      🐛
    </button>
    <button class="emoji-button" id="contact-inbox-btn" onclick="showContactInbox()" data-i18n="contact_my_messages">
      📬
    </button>
  </div>
</div>
<!-- Sous-rubrique Quiz Flash -->
<div id="options-quiz-flash-choice" class="options-sub hidden">
  <h2 data-i18n="quiz_flash_choice_title">Quiz Flash</h2>
  
  <button class="arcade-button" onclick="startQuizFlash(1, 'hiragana')" data-i18n="quiz_flash_hiragana">
    🌸 Hiragana
  </button>
  
  <button class="arcade-button" onclick="startQuizFlash(1, 'katakana')" data-i18n="quiz_flash_katakana">
    ⛩️ Katakana
  </button>
</div>
</div>
<!-- ========================================
     HTML À AJOUTER APRÈS LA SECTION OPTIONS
     ======================================== -->

<!-- Section Mon compte -->
<div id="account" class="section">
  <h1 data-i18n="account_title">Mon compte</h1>
  
  <div class="account-section">
    <div class="account-info">
      <div class="account-info-line">
  <strong data-i18n="account_pseudo_label">Pseudo :</strong> <span id="account-pseudo" data-i18n="account_default_value">-</span>
</div>
<div class="account-info-line">
   <strong data-i18n="account_level_label">Niveau :</strong> <span id="account-level" data-i18n="account_default_value">-</span>
</div>
    </div>

    <div class="button-group">
      <button class="arcade-button" onclick="showChangeDevice()" data-i18n="account_change_device">
        📱 Changer d'appareil
      </button>

    </div>
  </div>
</div>

<!-- Section Création de compte - ÉTAPE 1 : Choix du  -->
<div id="create-account" class="section">
  <div id="onboarding-step-1" class="onboarding-step active">
    <h1 class="onboarding-title" data-i18n="onboarding_welcome">Bienvenue ! 🌸</h1>
    
    <div class="onboarding-content">
      <p class="onboarding-subtitle" data-i18n="onboarding_subtitle">Commençons ton voyage zen</p>
      
      <div class="onboarding-buttons">
        <button class="arcade-button large-button" onclick="goToStep(2)" data-i18n="onboarding_create">
          🎋 Créer un compte
        </button>
        <button class="arcade-button secondary-button large-button" onclick="showLoginFromOnboarding()" data-i18n="onboarding_login">
          🔐 J'ai déjà un compte
        </button>
      </div>
    </div>
  </div>

  <!-- ÉTAPE 2 : Choix du pseudo -->
  <div id="onboarding-step-2" class="onboarding-step">
    <h1 class="onboarding-title" data-i18n="onboarding_pseudo_title">Choisissons ton pseudo zen 🐼</h1>
    
    <div class="onboarding-content">
      <div class="pseudo-input-wrapper">
<input 
  type="text" 
  id="pseudo-input" 
  class="pseudo-input" 
  data-i18n-placeholder="pseudo_input_placeholder"
  placeholder="Ton pseudo..."
  maxlength="20"
/>
      </div>
<!-- ✅ AJOUTÉ : Honeypot (piège à bot) -->
<input 
  type="text" 
  id="website" 
  name="website" 
  style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;"
  tabindex="-1"
  autocomplete="off"
  aria-hidden="true"
/>
      <div id="create-error" class="error-message" style="display: none;"></div>

      <div class="onboarding-buttons">
        <button class="arcade-button" onclick="generateNewPseudo()" data-i18n="onboarding_regenerate">
          🔄 Changer de pseudo
        </button>
        <button class="arcade-button primary-button" onclick="validatePseudoAndContinue()" data-i18n="onboarding_next">
          Suivant ➡️
        </button>
      </div>
    </div>
  </div>

<!-- ÉTAPE 3 : Saisie du PIN -->
<div id="onboarding-step-3" class="onboarding-step">
  <h1 class="onboarding-title" data-i18n="onboarding_pin_title">Sécurise ton compte 🔐</h1>
  
  <div class="onboarding-content">
    <p class="onboarding-subtitle" data-i18n="onboarding_pin_subtitle">Entre ta date de naissance</p>
    
    <div class="birthdate-selectors">
      <div class="selector-group">
        <label class="selector-label" data-i18n="onboarding_day">Jour</label>
        <select id="birth-day" class="birthdate-select">
          <option value="">--</option>
        </select>
      </div>
      
      <div class="selector-group">
        <label class="selector-label" data-i18n="onboarding_month">Mois</label>
        <select id="birth-month" class="birthdate-select">
          <option value="">--</option>
        </select>
      </div>
    </div>

    <div id="pin-error" class="error-message" style="display: none;"></div>

    <div class="onboarding-buttons">
      <button class="arcade-button secondary-button small-button" onclick="goToStep(2)">
        ← <span data-i18n="onboarding_back">Retour</span>
      </button>
      <button class="arcade-button primary-button" onclick="validateBirthdateAndContinue()" data-i18n="onboarding_next">
        Suivant ➡️
      </button>
    </div>
  </div>
</div>

  <!-- ÉTAPE 4 : Confirmation -->
  <div id="onboarding-step-4" class="onboarding-step">
    <h1 class="onboarding-title" data-i18n="onboarding_confirm_title">Confirme ta date 📅</h1>
    
    <div class="onboarding-content">
      <div class="confirmation-box">
        <p class="confirmation-question" data-i18n="onboarding_confirm_question">Tu es né(e) le</p>
<p class="confirmation-date">
  <span id="confirm-date-display" class="date-value"></span>
  <span> ?</span>
</p>


        </div>

      <div class="warning-box">
        <p data-i18n="onboarding_warning">⚠️ Cette date te servira à récupérer ton compte</p>
      </div>

      <div class="onboarding-buttons">
        <button class="arcade-button secondary-button" onclick="goToStep(3)" data-i18n="onboarding_correct">
          ✏️ Corriger
        </button>
        <button class="arcade-button primary-button" onclick="finalizeAccount()" data-i18n="onboarding_confirm">
          ✅ C'est correct
        </button>
      </div>
    </div>
  </div>
</div>
<!-- Écran de chargement création compte -->
<div id="account-creation-loader" class="section" style="display: none;">
  <div class="zen-loader-container">
    <div class="zen-circle-loader">
      <div class="bamboo-leaf">🍃</div>
    </div>
    <p class="zen-loader-text" data-i18n="loader_preparing">Préparation de ton jardin zen...</p>
  </div>
</div>

<!-- Écran de bienvenue -->
<div id="welcome-screen" class="section" style="display: none;">
  <div class="welcome-animation-container">
    <div class="sakura-rain"></div>
    <h1 class="welcome-user-title"></h1>
    <p class="welcome-user-subtitle" data-i18n="welcome_journey_starts">Ton voyage commence maintenant 🌸</p>
  </div>
</div> 
  
</div>

<!-- Section Connexion (changement d'appareil) -->
<div id="login" class="section">
  <h1 data-i18n="login_title">Connexion 🔐</h1>
  
  <div class="account-section">
    <p data-i18n="login_subtitle">Retrouve ton compte</p>

      <!-- Pseudo -->
      <div class="pseudo-input-wrapper">
  <!--        <label class="selector-label" data-i18n="login_pseudo_label">Ton pseudo</label> -->
        <input 
  type="text" 
  id="login-pseudo" 
  class="pseudo-input" 
  data-i18n-placeholder="login_pseudo_placeholder"
  placeholder="ton pseudo"
/>
      </div>

      <!-- Date de naissance (même style que l'onboarding) -->
     <p data-i18n="login_pin_label">Ta date d'anniversaire :</p>

      <div class="birthdate-selectors" style="margin-top: 20px;">
        <div class="selector-group">
          <label class="selector-label" data-i18n="onboarding_day">Jour</label>
          <select id="login-birth-day" class="birthdate-select">
            <option value="">--</option>
          </select>
        </div>
        
        <div class="selector-group">
          <label class="selector-label" data-i18n="onboarding_month">Mois</label>
          <select id="login-birth-month" class="birthdate-select">
            <option value="">--</option>
          </select>
        </div>
      </div>

      <div id="login-error" class="error-message" style="display: none;"></div>
      <div id="login-success" class="success-message" style="display: none;"></div>

      <div class="onboarding-buttons">
        <button class="arcade-button primary-button" onclick="loginUser()" data-i18n="login_connect">
          🎋 Me connecter
        </button>
      
      </div>
    </div>
  </div>
</div>

<div id="login-loader" class="section" style="display: none;">
  <div class="zen-loader-container">
    <div class="zen-circle-loader">
      <div class="bamboo-leaf">🍃</div>
    </div>
    <p class="zen-loader-text" data-i18n="loader_preparing">Préparation de ton jardin zen...</p>
  </div>
</div>
    <!-- Section Mes Stats -->
<!-- Section Mon Jardin -->
<div id="stats" class="section">
<!--  <h1 data-i18n="stats_title">Mon Jardin</h1>  -->

<!-- Légende sticky -->
<div id="garden-legend" class="garden-legend">
  <span><span>🌱</span> <span data-i18n="garden_legend_learning">En cours</span></span>
  <span><span>🌿</span> <span data-i18n="garden_legend_practice">À entretenir</span></span>
  <span><span>🌸</span> <span data-i18n="garden_legend_mastered">Maîtrisé</span></span>
</div>

  <!-- Jardin scrollable -->
  <div class="garden-container">
    <div class="garden-ground" id="garden-ground">
      <!-- Généré par JS -->
    </div>

    <!-- Quelques décors fixes (tu peux en ajouter/supprimer) -->
<!-- Décors zen en vrais émojis (tu peux en ajouter/supprimer à l'infini) -->
<!-- 
<div class="garden-decor" style="top:8%;left:4%;font-size:3.8em;transform:rotate(-12deg);">🎋</div>
<div class="garden-decor" style="bottom:12%;right:6%;font-size:4.2em;transform:rotate(20deg);">🌾</div>
<div class="garden-decor" style="top:25%;left:2%;font-size:3em;">🌵</div>
<div class="garden-decor" style="bottom:30%;right:2%;font-size:3.5em;transform:rotate(8deg);">🌳</div>
<div class="garden-decor" style="top:45%;right:8%;font-size:2.8em;transform:rotate(-15deg);">🍂</div>
<div class="garden-decor" style="bottom:5%;left:10%;font-size:4.5em;opacity:0.5;">🎋</div>
<div class="garden-decor" style="top:15%;left:12%;font-size:3.2em;transform:rotate(25deg);">🎍</div>
  </div>
-->
<!-- Flashcard modale zen -->
<div id="garden-modal" class="garden-modal" onclick="closeGardenModal()">
  <div class="garden-card" onclick="event.stopPropagation()"> <!-- empêche la fermeture si on clique dedans -->
    <div id="modal-plant" style="font-size:4.2em; margin-bottom:0.6em;"></div>
<h2 id="modal-hiragana" style="margin:0 0 0.35em 0; font-size:4em; font-weight:bold; line-height:1.1;"></h2>
<div class="katakana" id="modal-katakana" style="font-size:3.4em; color:#6B5D4F; font-weight:bold; margin:0 0 0.35em 0; line-height:1.1;"></div>
    <div class="romaji" id="modal-romaji" style="font-size:3.6em; color:#8B6F47; font-weight:bold; margin:0 0 0.6em 0; line-height:1.1;"></div>
    <div class="info">
  <span data-i18n="garden_level"></span>
  <span id="modal-level"></span> •
  <span data-i18n="garden_score"></span>
  <span id="modal-validation"></span>
</div>
  </div>
</div>

<!-- Flashcard modale insecte test -->  
<div id="insect-modal" class="garden-modal">
  <div class="garden-card insect-card">
    <div id="insect-emoji" class="garden-plant"></div>
    <div id="insect-text" class="garden-hiragana"></div>
  </div>
</div>

    
</div>
</div>  
 <!-- ========================================
     PORTAL POUR TOUTES LES MODALES
     ======================================== -->
<div id="modal-portal"></div>
<!-- Section Contact Form -->
<div id="contact-form-modal" class="section" style="display: none;">
  <div class="contact-form-container">
 <!--   <button class="arcade-button" onclick="closeContactForm()" style="margin-bottom: 20px;">
      <span data-i18n="options_back">← Retour</span>
    </button> -->
    
    <h2 id="contact-form-title" data-i18n="contact_send_message">💬 Envoyer un message</h2>
    
    <!-- Message simple -->
    <div id="message-form" class="contact-form-content" style="display: none;">
      <p class="contact-subtitle" data-i18n="contact_message_subtitle">
        Partage tes idées, suggestions ou questions 🌸
      </p>
      
      <div class="contact-category">
        <label data-i18n="contact_category_label">Catégorie :</label>
        <select id="message-category" class="contact-select">
          <option value="suggestion" data-i18n="contact_cat_suggestion">💡 Suggestion</option>
          <option value="question" data-i18n="contact_cat_question">❓ Question</option>
          <option value="feedback" data-i18n="contact_cat_feedback">⭐ Retour d'expérience</option>
          <option value="other" data-i18n="contact_cat_other">📝 Autre</option>
        </select>
      </div>
      
      <textarea 
        id="message-text" 
        class="contact-textarea" 
        maxlength="500" 
        placeholder="Ton message (max 500 caractères)..."
        data-i18n-placeholder="contact_message_placeholder"
      ></textarea>
      
      <div class="char-counter">
        <span id="char-count">0</span>/500
      </div>
      
      <div id="message-error" class="error-message" style="display: none;"></div>
      <div id="message-success" class="success-message" style="display: none;"></div>
      
      <button class="arcade-button primary-button" onclick="submitMessage()" data-i18n="contact_send">
        ✉️ Envoyer
      </button>
    </div>
    
<!-- Bug report -->
<div id="bug-form" class="contact-form-content" style="display: none;">
  <p class="contact-subtitle" data-i18n="contact_bug_subtitle">
    Aide-nous à améliorer l'application 🐛
  </p>
  
  <div class="contact-field">
    <label data-i18n="contact_email_label">Email :</label>
    <input 
      type="email" 
      id="bug-email" 
      class="contact-input" 
      placeholder="ton@email.com"
      data-i18n-placeholder="contact_email_placeholder"
    />
  </div>
  
  <div class="contact-field">
    <label data-i18n="contact_bug_description_label">Description du bug :</label>
    <textarea 
      id="bug-description" 
      class="contact-textarea" 
      maxlength="500" 
      placeholder="Décris le problème en quelques lignes..."
      data-i18n-placeholder="contact_bug_description_placeholder"
    ></textarea>
    <div class="char-counter">
      <span id="bug-char-count">0</span>/500
    </div>
  </div>
  
  <div class="contact-field">
    <label data-i18n="contact_bug_steps_label">Étapes pour reproduire (optionnel) :</label>
    <textarea 
      id="bug-steps" 
      class="contact-textarea small" 
      maxlength="300" 
      placeholder="1. Je clique sur...&#10;2. Ensuite..."
      data-i18n-placeholder="contact_bug_steps_placeholder"
    ></textarea>
  </div>
  
<div class="info-box" style="background: var(--blue-light); border: 2px solid var(--blue-dark); padding: 1em; border-radius: 8px; margin: 1em 0;">
  <p style="margin: 0; color: var(--blue-dark); font-size: 0.95em;">
    <span data-i18n="contact_bug_screenshot_title">📷 Screenshot nécessaire ?</span><br>
    <span data-i18n="contact_bug_screenshot_text">Si nous avons besoin d'une capture d'écran, nous te contacterons par email.</span>
  </p>
</div>
  
  <div id="bug-error" class="error-message" style="display: none;"></div>
  <div id="bug-success" class="success-message" style="display: none;"></div>
  
  <button class="arcade-button primary-button" onclick="submitBugReport()" data-i18n="contact_send">
    ✉️ Envoyer
  </button>
</div>
  </div>
</div>

<!-- Section Inbox (Messages reçus) -->
<div id="contact-inbox-modal" class="section" style="display: none;">
  <div class="contact-inbox-container">
<!--   <button class="arcade-button" onclick="closeContactForm()" style="margin-bottom: 20px;">
      <span data-i18n="options_back">← Retour</span>
    </button> -->
    
    <h2 data-i18n="contact_inbox_title">📬 Mes messages</h2>
    
    <div id="inbox-loading" class="zen-loader-container" style="display: none;">
      <div class="zen-circle-loader">
        <div class="bamboo-leaf">🍃</div>
      </div>
      <p class="zen-loader-text" data-i18n="contact_loading">Chargement...</p>
    </div>
    
    <div id="inbox-empty" class="inbox-empty" style="display: none;">
      <p data-i18n="contact_inbox_empty">📭 Aucun message pour le moment</p>
    </div>
    
    <div id="inbox-messages" class="inbox-messages">
      <!-- Généré dynamiquement par JS -->
    </div>
  </div>
</div>
<!-- TUTORIEL MODE QUIZ – VERSION CORRIGÉE -->
<div id="quiz-tutorial-overlay" style="
  display: none;
  position: fixed;
  inset: 0;
background: transparent;
  z-index: 9997;
  pointer-events: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
">
  <div id="quiz-tutorial-card" style="
    background: var(--white); /* Fond blanc */
    padding: 22px 30px;
    border-radius: 20px;
    box-shadow: 0 12px 30px var(--shadow-black-strong);
    max-width: 88%;
    width: 380px;
    text-align: center;
    pointer-events: all;
    animation: fadeIn 0.5s ease; /* Fade-in doux */
  ">
    <h2 id="tutorial-title" style="font-size: 1em; margin: 0.5em 0; color: var(--brown-primary);"></h2>
    <p id="tutorial-text" style="font-size: 0.9em; margin: 0.9em 0 1.8em; line-height: 1.2; color: var(--brown-primary);"></p>

    <div style="display: flex; justify-content: center;">
      <button class="arcade-button primary-button" id="tutorial-next">Suivant →</button>
    </div>

    <div id="tutorial-progress-dots" style="margin-top: 25px; display: flex; justify-content: center; gap: 10px;"></div>
  </div>
</div>

<div id="quiz-flash" class="section">
  <div class="quiz-flash-overlay"></div>
  
  <div class="quiz-flash-header">
    <div class="quiz-flash-counter" id="flashCounter">1/15</div>
    <div class="quiz-flash-group" id="flashGroupName">Groupe 1</div>
  </div>
  
  <div class="quiz-flash-container">
    <div class="quiz-flash-card" id="flashCard">
      <div class="flash-card-inner">
        <!-- Face avant : Hiragana -->
        <div class="flash-card-front">
          <div class="flash-hiragana" id="flashHiragana">あ</div>
        </div>
        
        <!-- Face arrière : Hiragana petit + Romaji -->
        <div class="flash-card-back">
          <div class="flash-hiragana-small" id="flashHiraganaSmall">あ</div>
          <div class="flash-romaji" id="flashRomaji">a</div>
        </div>
      </div>
    </div>
    
    <div class="quiz-flash-timer">
      <div class="timer-bar" id="flashTimerBar"></div>
    </div>
  </div>
</div>
</body>

<script 
  src="https://cdn.jsdelivr.net/npm/@twemoji/api@latest/dist/twemoji.min.js"
  onload="window.twemojiLoaded = true"
></script>

<script>
"use strict";
// ============================================================================
// 🌍 SECTION 1 : TRADUCTIONS & INTERNATIONALISATION
// 👤 SECTION 2 : AUTHENTIFICATION & UTILISATEUR
// 📊 SECTION 3 : DONNÉES & GESTION DE CACHE
// 🌐 SECTION 4 : API & COMMUNICATION SERVEUR
// 🎵 SECTION 5 : SYSTÈME AUDIO
// 📈 SECTION 6 : PROGRESSION & NIVEAUX
// 🎮 SECTION 7 : MODE QUIZ (APPRENTISSAGE)
// 🔄 SECTION 8 : MODE RÉVISION
// 🌸 SECTION 9 : MON JARDIN (STATISTIQUES)
// 🎨 SECTION 10 : ANIMATIONS & EFFETS VISUELS
// 💬 SECTION 11 : FLASHCARDS & MODALES
// 🎯 SECTION 12 : NAVIGATION & UI GÉNÉRALE
// ⚙️ SECTION 13 : OPTIONS & PARAMÈTRES
// 📱 SECTION 14 : CONTACT & SUPPORT
// 🎨 SECTION 15 : EMOJIS & TWEMOJI
// 🚀 SECTION 16 : INITIALISATION & CHARGEMENT
// 🎬 SECTION 17 : DÉMARRAGE APPLICATION
// 🐼 SECTION 18 : ÉVÉNEMENTS PANDA & ÉCRAN D'ACCUEIL
//    SECTION 19 : TUTORIEL
//    SECTION 20 : FLASH QUIZ
// ============================================================================
// ============================================================================
// 🌍 SECTION 1 : TRADUCTIONS & INTERNATIONALISATION
// ============================================================================
// ============================================================================  
  const translations = {
  fr: {
    // Menu
    menu_learn: "Apprendre",
    menu_revision: "Mode révisions",
    menu_options: "Options",
    menu_stats: "Mon jardin",
    
    // Page d'accueil
    welcome_title: "🎌🌸 Kanas-Zen-Garden 🌸🎌",
    welcome_subtitle: "Apprenez à lire le Japonais",
    welcome_loading: "Chargement...",
    welcome_touch: "Touchez le panda pour entrer !",
    welcome_loading_dots: "(Chargement... )",
    welcome_user: "Bienvenue",
    welcome_back: "Bon retour",
    welcome_journey_starts: "Ton voyage commence maintenant 🌸",
    
    // Quiz
    quiz_level: "Niveau actuel :",
    quiz_level_display: "Niveau actuel :",
    quiz_continue: "🌱 OK... j'ai capté 🌱",
    quiz_install: "Ajouter à l'écran d'accueil",
    quiz_question_load: "load...",
    quiz_current_level: "Niveau actuel :",
    quiz_correct_answer: "👉 Bonne réponse :",
    
    // Options
    options_title: "Options",
    options_difficulty: "Difficulté",
    options_sound: "Son",
    options_language: "Langue",
    options_back: "← Retour",
    sound_game_effects: "Sons du jeu",
    sound_voice_synthesis: "Synthèses vocales",
    
    // Messages
    msg_perfect: "Correct !",
    msg_validated: "Validé !",
    msg_correct: "👉 Bonne réponse :",
    msg_level_up: "BRAVO !!!",
    
    // Messages menu
    menu_msg_blocked: "Mode Apprendre bloqué",
    menu_msg_unblocked: "Mode Apprendre débloqué !",
    menu_msg_still_blocked: "Mode Apprendre encore bloqué",
    menu_msg_revision_unlocked: "🎮 Mode révisions débloqué 🎮",
    
    // Révision
    revision_available_level4: "Mode révision disponible à partir du niveau 4",
    revision_no_items: "Aucun item disponible pour révision",
    revision_ok: "OK",
    revision_wrong: "Faux",
    revision_correct_answer: "👉 Bonne réponse :",
    
    // Mon compte
    account_title: "Mon compte",
    account_change_device: "Changer de compte",
    account_pseudo_label: "Pseudo :",
    account_level_label: "Niveau :",
    account_default_value: "-",
    account_level_in_progress: "(en cours)",
    
    // Onboarding
    onboarding_welcome: "Bienvenue ! 🌸",
    onboarding_subtitle: "Commençons ton apprentissage",
    onboarding_create: "Créer un compte",
    onboarding_login: "J'ai déjà un compte",
    onboarding_pseudo_title: "Choisis ton pseudo 🐼",
    onboarding_regenerate: "?",
    onboarding_next: "OK",
    onboarding_back: "Retour",
    onboarding_pin_title: "Sécurise ton compte 🔐",
    onboarding_pin_subtitle: "Entre ta date de naissance",
    onboarding_confirm_title: "Confirmation",
    onboarding_confirm_question: "Tu es né(e) le",
    onboarding_warning: "⚠️ Cette date te servira à récupérer ton compte en cas de besoin",
    onboarding_correct: "Corriger",
    onboarding_confirm: "C'est correct !",
    onboarding_day: "Jour",
    onboarding_month: "Mois",
    
    // Connexion
    login_title: "Connexion 🔐",
    login_subtitle: "Retrouve ton compte",
    login_pseudo_label: "Ton pseudo",
    login_pseudo_placeholder: "ton pseudo",
    login_pin_label: "Ta date d'anniversaire :",
    login_connect: "Me connecter",
    
    // Mon Jardin
    stats_title: "🐼 Mon jardin",
    stats_no_items: "Aucun item dans cette catégorie",
    garden_legend_learning: "En cours",
    garden_legend_practice: "À entretenir",
    garden_legend_mastered: "Maîtrisé",
    garden_level: "Niveau",
    garden_score: "Score actuel",
    
    // Insectes – messages jardin
insect_msg_01: "Chaque plante ici représente un caractère que tu as rencontré.",
insect_msg_02: "Un jardin pousse mieux quand on y revient souvent.",
insect_msg_03: "Tu n’as pas besoin d’aller vite. Les plantes aiment la patience.",
insect_msg_04: "Même une petite révision peut redonner de la force à une plante.",
insect_msg_05: "Observe ton jardin. Il raconte ton parcours.",

    
    // Placeholders
    pseudo_input_placeholder: "Ton pseudo...",
    
    // Erreurs
    error_pseudo_too_short: "Le pseudo doit contenir au moins 2 caractères",
    error_pseudo_too_long: "Le pseudo ne peut pas dépasser 20 caractères",
    error_pseudo_invalid_chars: "Le pseudo ne peut contenir que des lettres et des chiffres (pas d'espaces ni de caractères spéciaux)",
    error_select_date: "Veuillez sélectionner un jour et un mois",
    error_invalid_day: "Ce mois ne peut pas avoir",
    error_invalid_day_suffix: "jours",
    error_please_wait: "⏱️ Veuillez patienter encore",
    error_second: "seconde",
    error_seconds: "secondes",
    error_before_validate: "avant de valider...",
    error_suspicious_activity: "Activité suspecte détectée",
    error_connection: "Erreur de connexion",
    error_enter_pseudo: "Veuillez entrer votre pseudo",
    error_select_birthdate: "Veuillez sélectionner votre date de naissance",
    error_wrong_credentials: "Pseudo ou date de naissance incorrect",
    error_token_update: "Erreur lors de la mise à jour du token",
    
    // Loaders
    loader_meditation: "🧘 Méditation en cours...",
    loader_tea: "🍵 Préparation du thé matcha...",
    loader_cherry: "🌸 Plantation des cerisiers...",
    loader_garden: "🎋 Arrangement du jardin zen...",
    loader_ceremony: "🎌 Préparation de la cérémonie...",
    loader_preparing: "Préparation de ton jardin zen...",
    
    // Proverbes (utilisés dans showReturningUserWelcome)
    proverb_1: "Un voyage de mille lieues commence toujours par un premier pas 🌸",
    proverb_2: "La patience est la clé de la joie 🍃",
    proverb_3: "Chaque jour est une nouvelle chance d'apprendre 🎋",
    proverb_4: "Même un voyage de mille kilomètres commence par un pas 👣",
    proverb_5: "Le vent ne laisse pas de trace, mais il transforme le ciel 🌬️",
    proverb_6: "Le savoir est un trésor qui suit partout celui qui le possède 💎",
    proverb_7: "Un petit progrès chaque jour mène au succès 🌱",
    proverb_8: "La persévérance est la mère du succès 🏔️",
    proverb_9: "Qui grimpe lentement grimpe sûrement 🧗",
    proverb_10: "Le chemin est plus important que la destination 🛤️",
    proverb_11: "Mieux vaut tard que jamais ⏰",
    proverb_12: "Quand le vent cesse, les feuilles se reposent — ainsi va l'esprit apaisé 🍂",
    proverb_13: "Dans la goutte de rosée, tout l'univers se reflète 💧",
    proverb_14: "Le silence n'est pas vide — il est plein de réponses 🕊️",
    proverb_15: "Une pierre immobile dans le ruisseau apprend le passage du temps ⛰️",
    proverb_16: "Affûte ton esprit comme on polit un sabre — lentement, patiemment ⚔️",
    proverb_17: "Ce n'est pas la force, mais la constance, qui fend la pierre 💧",
    proverb_18: "Chaque jour, avance d'un pas invisible mais réel 👣",
    proverb_19: "La fleur n'ouvre pas ses pétales en un seul matin 🌸",
    proverb_20: "Chaque expert était autrefois un débutant 🌟",
    proverb_21: "L'échec est le fondement de la réussite 🌸",
    proverb_22: "Même l'ombre d'un arbre parle du soleil 🌳",
    proverb_23: "La brume cache la montagne, mais la montagne demeure ⛰️",
    proverb_24: "Le parfum du thé n'a pas besoin de paroles 🍵",
    proverb_25: "La discipline n'est pas une chaîne, mais une clé 🗝️",
    
    // Mois
    month_01: "janvier",
    month_02: "février",
    month_03: "mars",
    month_04: "avril",
    month_05: "mai",
    month_06: "juin",
    month_07: "juillet",
    month_08: "août",
    month_09: "septembre",
    month_10: "octobre",
    month_11: "novembre",
    month_12: "décembre",
    
    // Contact
    contact_title: "Contact",
    contact_send_message: "✉️",
    contact_message_subtitle: "Partage tes idées, suggestions ou questions",
    contact_category_label: "Catégorie :",
    contact_cat_suggestion: "💡 Suggestion",
    contact_cat_question: "❓ Question",
    contact_cat_feedback: "⭐ Retour d'expérience",
    contact_cat_other: "📝 Autre",
    contact_message_placeholder: "Ton message (max 500 caractères)...",
    contact_send: "✉️ Envoyer",
    contact_bug_subtitle: "Signaler un bug",
    contact_email_label: "Email :",
    contact_email_placeholder: "ton@email.com",
    contact_bug_description_label: "Description du bug :",
    contact_bug_description_placeholder: "Décris le problème en quelques lignes...",
    contact_bug_steps_label: "Étapes pour reproduire (optionnel) :",
    contact_bug_steps_placeholder: "1. Je clique sur...\n2. Ensuite...",
    contact_bug_screenshot_title: "📷 Screenshot nécessaire ?",
    contact_bug_screenshot_text: "Si nous avons besoin d'une capture d'écran, nous te contacterons par email.",
    contact_report_bug: "🐞",
    contact_my_messages: "📬",
    contact_inbox_title: "📬 Mes messages",
    contact_loading: "Chargement...",
    contact_inbox_empty: "📭 Aucun message pour le moment",
    contact_message_too_short: "Message trop court (min 10 caractères)",
    contact_invalid_email: "⚠️ Email invalide",
    contact_description_too_short: "⚠️ Description trop courte (min 20 caractères)",
    contact_success_message: "✅ Message envoyé ! Nous te répondrons bientôt 🌸",
    contact_success_bug: "✅ Bug reporté ! Merci pour ton aide",
    contact_error_short: "Message trop court (min 10 caractères)",
    contact_error_email: "⚠️ Email invalide",
    contact_error_bug_short: "⚠️ Description trop courte (min 20 caractères)",
    contact_error_bug_size: "⚠️ Screenshot trop lourd (max 5MB)",
    contact_error_network: "Erreur réseau. Vérifie ta connexion.",
    contact_response_header: "🌸 Réponse de l'équipe",
    contact_waiting_response: "En attente de réponse...",
    contact_limit_reached: 'Limite atteinte : 3 messages maximum par jour 🌸',
    contact_user_not_identified: 'Utilisateur non identifié. Connecte-toi d\'abord.',
    contact_error_occurred: 'Une erreur est survenue',
    contact_user_not_found: "Utilisateur non identifié. Connecte-toi d'abord.",
    contact_inbox_error: "❌ Erreur de chargement",
    
    sync_alert_title: "Perte de signal détectée",
    sync_alert_message: "Vous pouvez continuer à jouer, votre progression est mémorisée et sera synchronisée dès le retour de la connexion.",
    sync_alert_button: "J'ai compris",
    sync_success_title: "Synchronisation réussie !",
    sync_success_message: "Toutes vos données ont été sauvegardées avec succès.",
    sync_success_button: "OK",

 // Tutoriel Quiz - Titres
    tuto_step1_title: "Petite présentation",
    tuto_step2_title: "Barre de progression",
    tuto_step3_title: "Les cartes",
    tuto_step4_title: "La question",
    tuto_step5_title: "Les réponses",
    tuto_step6_title: "❌ Mauvaise réponse",
    tuto_step7_title: "✅ Bonne réponse",
    tuto_step8_title: "Le menu",
    tuto_step9_title: "C'est parti !",
    
    // Tutoriel Quiz - Textes
    tuto_step1_text: "Avant de commencer, faisons un rapide tour du jeu et de son fonctionnement.",
    tuto_step2_text: "Le panda avance au fil de ton apprentissage. Ton objectif : l'aider à rejoindre l'arbre.",
    tuto_step3_text: "Chaque carte représente un kana (puis des mots). Gagne jusqu'à 5 étoiles par carte. Quand toutes brillent, tu passes au niveau suivant.",
    tuto_step4_text: "Ici apparaissent les items que tu devras reconnaître : kana, romaji ou mot, selon le niveau.",
    tuto_step5_text: "Pour chaque question, choisis une réponse sur chaque ligne parmi les boutons proposés.",
    tuto_step6_text: "En cas d'erreur, le rouge montre ce qui ne va pas et le vert t'indique la bonne réponse. Se tromper fait partie de l'apprentissage.",
    tuto_step7_text: "Quand tout est correct, tu gagnes une étoile. Petit à petit, les bonnes réponses deviennent naturelles.",
    tuto_step8_text: "Le menu te permet de naviguer dans les différentes sections. Certaines seront débloquées au fil de ta progression. Une question ? Contacte-nous via le menu Options.",
    tuto_step9_text: "Apprendre devrait toujours être un jeu alors surtout amuse-toi et progresse zen ! 🌸",
    
    // Boutons tutoriel
    tuto_next: "Suivant →",
    tuto_start: "Commencer !",

    // Messages feedback tutoriel
    tuto_perfect: "Parfait !",

token_expired_title: "Session expirée",
token_expired_message: "Votre compte a été ouvert sur un autre appareil. Veuillez recharger la page pour continuer.",
token_expired_button: "Recharger la page",

 menu_quiz_flash: "Quiz Flash",
 quiz_flash_group_complete: "Groupe terminé !",

    // Déblocages
    unlock_revision_title: 'Mode Révisions',
    unlock_revision_message: 'Tu peux maintenant réviser tes kanas !',
    unlock_garden_title: 'Mon Jardin',
    unlock_garden_message: 'Ton jardin zen est maintenant accessible !',
    unlock_learning_title: 'Mode Apprendre Débloqué',
    unlock_learning_message: 'Tu peux à nouveau apprendre de nouveaux kanas !',

quiz_flash_choice_title: 'Quiz Flash',
quiz_flash_hiragana: '🌸 Hiragana',
quiz_flash_katakana: '⛩️ Katakana'

  },
  
  en: {
    // Menu
    menu_learn: "Learn",
    menu_revision: "Revision Mode",
    menu_options: "Options",
    menu_stats: "My Garden",
    
    // Welcome page
    welcome_title: "🎌🌸 Kanas-Zen-Garden 🌸🎌",
    welcome_subtitle: "Learn to read Japanese",
    welcome_loading: "Loading...",
    welcome_touch: "Touch the panda to enter!",
    welcome_loading_dots: "(Loading... )",
    welcome_user: "Welcome",
    welcome_back: "Welcome back",
    welcome_journey_starts: "Your journey begins now 🌸",
    
    // Quiz
    quiz_level: "Current level:",
    quiz_level_display: "Current level:",
    quiz_continue: "🌱 OK... got it 🌱",
    quiz_install: "Add to home screen",
    quiz_question_load: "load...",
    quiz_current_level: "Current level:",
    quiz_correct_answer: "👉 Correct answer:",
    
    // Options
    options_title: "Options",
    options_difficulty: "Difficulty",
    options_sound: "Sound",
    options_language: "Language",
    options_back: "← Back",
    sound_game_effects: "Game sounds",
    sound_voice_synthesis: "Voice synthesis",
    
    // Messages
    msg_perfect: "Perfect!",
    msg_validated: "Validated! 🎉",
    msg_correct: "👉 Correct answer:",
    msg_level_up: "LEVEL UP!!!",
    
    // Menu messages
    menu_msg_blocked: "Learn Mode blocked",
    menu_msg_unblocked: "Learn Mode unblocked!",
    menu_msg_still_blocked: "Learn Mode still blocked",
    menu_msg_revision_unlocked: "Revision mode unlocked",
    
    // Revision
    revision_available_level4: "Revision mode available from level 4",
    revision_no_items: "No items available for revision",
    revision_ok: "OK",
    revision_wrong: "Wrong",
    revision_correct_answer: "👉 Correct answer:",
    
    // My account
    account_title: "My Account",
    account_change_device: "Change account",
    account_pseudo_label: "Nickname:",
    account_level_label: "Level:",
    account_default_value: "-",
    account_level_in_progress: "(in progress)",
    
    // Onboarding
    onboarding_welcome: "Welcome! 🌸",
    onboarding_subtitle: "Let's begin your learning",
    onboarding_create: "Create an account",
    onboarding_login: "I already have an account",
    onboarding_pseudo_title: "Choose your nickname 🐼",
    onboarding_regenerate: "?",
    onboarding_next: "Okay",
    onboarding_back: "Back",
    onboarding_pin_title: "Secure your account 🔐",
    onboarding_pin_subtitle: "Enter your birth date",
    onboarding_confirm_title: "Confirmation",
    onboarding_confirm_question: "You were born on",
    onboarding_warning: "⚠️ This date will allow you to recover your account if needed",
    onboarding_correct: "Correct",
    onboarding_confirm: "That's correct",
    onboarding_day: "Day",
    onboarding_month: "Month",
    
    // Login
    login_title: "Login 🔐",
    login_subtitle: "Find your account",
    login_pseudo_label: "Your nickname",
    login_pseudo_placeholder: "your nickname",
    login_pin_label: "Your Birthdate :",
    login_connect: "🎋 Connect",
    
    // My Garden
    stats_title: "🐼 My Garden",
    stats_no_items: "No items in this category",
    garden_legend_learning: "Learning",
    garden_legend_practice: "Practice",
    garden_legend_mastered: "Mastered",
    garden_level: "Level",
    garden_score: "Current score",

    insect_msg_01: "Each plant here represents a character you have encountered.",
insect_msg_02: "A garden grows better when you come back to it often.",
insect_msg_03: "You don’t need to rush. Plants grow with patience.",
insect_msg_04: "Even a short review can bring strength back to a plant.",
insect_msg_05: "Look at your garden. It tells the story of your journey.",

    
    // Placeholders
    pseudo_input_placeholder: "Your nickname...",
    
    // Errors
    error_pseudo_too_short: "Nickname must contain at least 2 characters",
    error_pseudo_too_long: "Nickname cannot exceed 20 characters",
    error_pseudo_invalid_chars: "Nickname can only contain letters and numbers (no spaces or special characters)",
    error_select_date: "Please select a day and month",
    error_invalid_day: "This month cannot have",
    error_invalid_day_suffix: "days",
    error_please_wait: "⏱️ Please wait",
    error_second: "second",
    error_seconds: "seconds",
    error_before_validate: "before validating...",
    error_suspicious_activity: "Suspicious activity detected",
    error_connection: "Connection error",
    error_enter_pseudo: "Please enter your nickname",
    error_select_birthdate: "Please select your birth date",
    error_wrong_credentials: "Incorrect nickname or birth date",
    error_token_update: "Error updating token",
    
    // Loaders
    loader_meditation: "🧘 Meditating...",
    loader_tea: "🍵 Preparing matcha tea...",
    loader_cherry: "🌸 Planting cherry trees...",
    loader_garden: "🎋 Arranging zen garden...",
    loader_ceremony: "🎌 Preparing ceremony...",
    loader_preparing: "Preparing your zen garden...",
    
    // Proverbs
    proverb_1: "A journey of a thousand miles begins with a single step 🌸",
    proverb_2: "Patience is the key to joy 🍃",
    proverb_3: "Every day is a new chance to learn 🎋",
    proverb_4: "Even a journey of a thousand kilometers begins with one step 👣",
    proverb_5: "The wind leaves no trace, but it transforms the sky 🌬️",
    proverb_6: "Knowledge is a treasure that follows its owner everywhere 💎",
    proverb_7: "A little progress each day leads to success 🌱",
    proverb_8: "Perseverance is the mother of success 🏔️",
    proverb_9: "Who climbs slowly, climbs surely 🧗",
    proverb_10: "The path is more important than the destination 🛤️",
    proverb_11: "Better late than never ⏰",
    proverb_12: "When the wind stops, the leaves rest — so goes the peaceful mind 🍂",
    proverb_13: "In the dewdrop, the entire universe is reflected 💧",
    proverb_14: "Silence is not empty — it is full of answers 🕊️",
    proverb_15: "A still stone in the stream learns the passage of time ⛰️",
    proverb_16: "Sharpen your mind like polishing a sword — slowly, patiently ⚔️",
    proverb_17: "It is not strength, but consistency, that splits the stone 💧",
    proverb_18: "Each day, move forward with an invisible but real step 👣",
    proverb_19: "The flower doesn't open its petals in a single morning 🌸",
    proverb_20: "Every expert was once a beginner 🌟",
    proverb_21: "Failure is the foundation of success 🌸",
    proverb_22: "Even the shadow of a tree speaks of the sun 🌳",
    proverb_23: "The mist hides the mountain, but the mountain remains ⛰️",
    proverb_24: "The fragrance of tea needs no words 🍵",
    proverb_25: "Discipline is not a chain, but a key 🗝️",
    
    // Months
    month_01: "January",
    month_02: "February",
    month_03: "March",
    month_04: "April",
    month_05: "May",
    month_06: "June",
    month_07: "July",
    month_08: "August",
    month_09: "September",
    month_10: "October",
    month_11: "November",
    month_12: "December",
    
    // Contact
    contact_title: "Contact",
    contact_send_message: "✉️",
    contact_message_subtitle: "Share your ideas, suggestions, or questions",
    contact_category_label: "Category:",
    contact_cat_suggestion: "💡 Suggestion",
    contact_cat_question: "❓ Question",
    contact_cat_feedback: "⭐ Feedback",
    contact_cat_other: "📝 Other",
    contact_message_placeholder: "Your message (max 500 characters)...",
    contact_send: "✉️ Send",
    contact_bug_subtitle: "Report a bug",
    contact_email_label: "Email:",
    contact_email_placeholder: "your@email.com",
    contact_bug_description_label: "Bug description:",
    contact_bug_description_placeholder: "Describe the problem in a few lines...",
    contact_bug_steps_label: "Steps to reproduce (optional):",
    contact_bug_steps_placeholder: "1. I click on...\n2. Then...",
    contact_bug_screenshot_title: "📷 Screenshot required?",
    contact_bug_screenshot_text: "If we need a screenshot, we will contact you by email.",
    contact_report_bug: "🐞",
    contact_my_messages: "📬",
    contact_inbox_title: "📬 My messages",
    contact_loading: "Loading...",
    contact_inbox_empty: "📭 No messages yet",
    contact_message_too_short: "Message too short (min 10 characters)",
    contact_invalid_email: "⚠️ Invalid email",
    contact_description_too_short: "⚠️ Description too short (min 20 characters)",
    contact_success_message: "✅ Message sent! We'll reply soon 🌸",
    contact_success_bug: "✅ Bug reported! Thanks for your help",
    contact_error_short: "Message too short (min 10 characters)",
    contact_error_email: "⚠️ Invalid email",
    contact_error_bug_short: "⚠️ Description too short (min 20 characters)",
    contact_error_bug_size: "⚠️ Screenshot too large (max 5MB)",
    contact_error_network: "Network error. Check your connection.",
    contact_response_header: "🌸 Team response",
    contact_waiting_response: "Waiting for response...",
    contact_limit_reached: 'Limit reached: 3 messages maximum per day 🌸',
    contact_user_not_identified: 'User not identified. Please log in first.',
    contact_error_occurred: 'An error occurred',
    contact_user_not_found: "User not identified. Please log in first.",
    contact_inbox_error: "❌ Loading error",

    sync_alert_title: "Signal loss detected",
    sync_alert_message: "You can continue playing, your progress is saved and will be synchronized when the connection returns.",
    sync_alert_button: "Got it",
    sync_success_title: "Sync successful!",
    sync_success_message: "All your data has been saved successfully.",
    sync_success_button: "OK",

  // Tutorial Quiz - Titles
    tuto_step1_title: "Quick intro",
    tuto_step2_title: "Progress bar",
    tuto_step3_title: "The cards",
    tuto_step4_title: "The question",
    tuto_step5_title: "The answers",
    tuto_step6_title: "❌ Wrong answer",
    tuto_step7_title: "✅ Correct answer",
    tuto_step8_title: "The menu",
    tuto_step9_title: "Let's go!",
    
    // Tutorial Quiz - Texts
    tuto_step1_text: "Before we start, let's take a quick tour of the game and how it works.",
    tuto_step2_text: "The panda advances as you learn. Your goal: help it reach the tree.",
    tuto_step3_text: "Each card represents a kana (then words). Earn up to 5 stars per card. When they all shine, you move to the next level.",
    tuto_step4_text: "Here appear the items you'll need to recognize: kana, romaji, or words, depending on the level.",
    tuto_step5_text: "For each question, choose one answer on each row from the buttons provided.",
    tuto_step6_text: "If you make a mistake, red shows what's wrong and green shows the right answer. Making mistakes is part of learning.",
    tuto_step7_text: "When everything is correct, you earn a star. Little by little, the right answers become natural.",
    tuto_step8_text: "The menu lets you navigate between sections. Some will unlock as you progress. Got a question? Contact us via the Options menu.",
    tuto_step9_text: "Learning should always be fun, so enjoy yourself and progress zen! 🌸",
    
    // Tutorial buttons
    tuto_next: "Next →",
    tuto_start: "Start!",

    // Feedback messages tutorial
    tuto_perfect: "Perfect!",

token_expired_title: "Session Expired",
token_expired_message: "Your account was opened on another device. Please reload the page to continue.",
token_expired_button: "Reload Page",
 
menu_quiz_flash: "Flash Quiz",   
quiz_flash_group_complete: "Group completed!",

    // Unlocks
    unlock_revision_title: 'Review Mode',
    unlock_revision_message: 'You can now review your kanas!',
    unlock_garden_title: 'My Garden',
    unlock_garden_message: 'Your zen garden is now accessible!',
    unlock_learning_title: 'Learning Mode Unlocked',
    unlock_learning_message: 'You can learn new kanas again!',

quiz_flash_choice_title: 'Flash Quiz',
quiz_flash_hiragana: '🌸 Hiragana',
quiz_flash_katakana: '⛩️ Katakana'

  },
  
  es: {
    // Menu
    menu_learn: "Aprender",
    menu_revision: "Modo revisión",
    menu_options: "Opciones",
    menu_stats: "Mi Jardin",
    
    // Página de bienvenida
    welcome_title: "🎌🌸 Kanas-Zen-Garden 🌸🎌",
    welcome_subtitle: "Aprende a leer Japonés",
    welcome_loading: "Cargando...",
    welcome_touch: "¡Toca el panda para entrar!",
    welcome_loading_dots: "(Cargando... )",
    welcome_user: "Bienvenido",
    welcome_back: "Bienvenido de nuevo",
    welcome_journey_starts: "Tu viaje comienza ahora 🌸",
    
    // Quiz
    quiz_level: "Nivel actual:",
    quiz_level_display: "Nivel actual:",
    quiz_continue: "🌱 OK... lo entendí 🌱",
    quiz_install: "Añadir a pantalla de inicio",
    quiz_question_load: "load...",
    quiz_current_level: "Nivel actual:",
    quiz_correct_answer: "👉 Respuesta correcta:",
    
    // Opciones
    options_title: "Opciones",
    options_difficulty: "Dificultad",
    options_sound: "Sonido",
    options_language: "Idioma",
    options_back: "← Volver",
    sound_game_effects: "Sonidos del juego",
    sound_voice_synthesis: "Síntesis de voz",
    
    // Mensajes
    msg_perfect: "¡Perfecto!",
    msg_validated: "¡Validado! 🎉",
    msg_correct: "👉 Respuesta correcta:",
    msg_level_up: "¡SUBIDA DE NIVEL!",
    
    // Mensajes del menú
    menu_msg_blocked: "Modo Aprender bloqueado",
    menu_msg_unblocked: "¡Modo Aprender desbloqueado!",
    menu_msg_still_blocked: "Modo Aprender aún bloqueado",
    menu_msg_revision_unlocked: "🎮 Modo revisión desbloqueado 🎮",
    
    // Disponibilidad revisión
    revision_available_level4: "Modo revisión disponible desde el nivel 4",
    revision_no_items: "No hay elementos disponibles para revisión",
    revision_ok: "OK",
    revision_wrong: "Falso",
    revision_correct_answer: "👉 Respuesta correcta:",
    
    // Mi cuenta
    account_title: "Mi Cuenta",
    account_change_device: "Cambiar cuenta",
    account_pseudo_label: "Apodo:",
    account_level_label: "Nivel:",
    account_default_value: "-",
    account_level_in_progress: "(en progreso)",
    
    // Onboarding
    onboarding_welcome: "¡Bienvenido! 🌸",
    onboarding_subtitle: "Comencemos tu aprendizaje",
    onboarding_create: "Crear una cuenta",
    onboarding_login: "Ya tengo una cuenta",
    onboarding_pseudo_title: "Elige tu apodo 🐼",
    onboarding_regenerate: "?",
    onboarding_next: "Bueno",
    onboarding_back: "Volver",
    onboarding_pin_title: "Asegura tu cuenta 🔐",
    onboarding_pin_subtitle: "Ingresa tu fecha de nacimiento",
    onboarding_confirm_title: "Confirmación",
    onboarding_confirm_question: "Naciste el",
    onboarding_warning: "⚠️ Esta fecha le permitirá recuperar su cuenta si es necesario",
    onboarding_correct: "Corregir",
    onboarding_confirm: "Es correcto",
    onboarding_day: "Día",
    onboarding_month: "Mes",
    
    // Conexión
    login_title: "Conexión 🔐",
    login_subtitle: "Encuentra tu cuenta",
    login_pseudo_label: "Tu apodo",
    login_pseudo_placeholder: "tu apodo",
    login_pin_label: "Tu fecha de nacimiento :",
    login_connect: "🎋 Conectarme",
    
    // Mi Jardin
    stats_title: "🐼 Mi Jardin",
    stats_no_items: "No hay elementos en esta categoría",
    garden_legend_learning: "En curso",
    garden_legend_practice: "Repasar",
    garden_legend_mastered: "Dominado",
    garden_level: "Nivel",
    garden_score: "Puntuación actual",

    insect_msg_01: "Cada planta aquí representa un carácter que has encontrado.",
insect_msg_02: "Un jardín crece mejor cuando vuelves a visitarlo a menudo.",
insect_msg_03: "No hace falta ir rápido. Las plantas crecen con paciencia.",
insect_msg_04: "Incluso una pequeña revisión puede devolver fuerza a una planta.",
insect_msg_05: "Observa tu jardín. Cuenta la historia de tu recorrido.",

    // Placeholders
    pseudo_input_placeholder: "Tu apodo...",
    
    // Errores
    error_pseudo_too_short: "El apodo debe contener al menos 2 caracteres",
    error_pseudo_too_long: "El apodo no puede exceder 20 caracteres",
    error_pseudo_invalid_chars: "El apodo solo puede contener letras y números (sin espacios ni caracteres especiales)",
    error_select_date: "Por favor seleccione un día y mes",
    error_invalid_day: "Este mes no puede tener",
    error_invalid_day_suffix: "días",
    error_please_wait: "⏱️ Por favor espere",
    error_second: "segundo",
    error_seconds: "segundos",
    error_before_validate: "antes de validar...",
    error_suspicious_activity: "Actividad sospechosa detectada",
    error_connection: "Error de conexión",
    error_enter_pseudo: "Por favor ingrese su apodo",
    error_select_birthdate: "Por favor seleccione su fecha de nacimiento",
    error_wrong_credentials: "Apodo o fecha de nacimiento incorrecta",
    error_token_update: "Error al actualizar el token",
    
    // Cargadores
    loader_meditation: "🧘 Meditando...",
    loader_tea: "🍵 Preparando té matcha...",
    loader_cherry: "🌸 Plantando cerezos...",
    loader_garden: "🎋 Arreglando jardín zen...",
    loader_ceremony: "🎌 Preparando ceremonia...",
    loader_preparing: "Preparando tu jardín zen...",

    // Proverbios
proverb_1: "Un viaje de mil millas comienza con un solo paso 🌸",
proverb_2: "La paciencia es la clave de la alegría 🍃",
proverb_3: "Cada día es una nueva oportunidad para aprender 🎋",
proverb_4: "Incluso un viaje de mil kilómetros comienza con un paso 👣",
proverb_5: "El viento no deja huella, pero transforma el cielo 🌬️",
proverb_6: "El conocimiento es un tesoro que sigue a su dueño a todas partes 💎",
proverb_7: "Un pequeño progreso cada día conduce al éxito 🌱",
proverb_8: "La perseverancia es la madre del éxito 🏔️",
proverb_9: "Quien sube lentamente, sube con seguridad 🧗",
proverb_10: "El camino es más importante que el destino 🛤️",
proverb_11: "Más vale tarde que nunca ⏰",
proverb_12: "Cuando el viento se detiene, las hojas descansan — así va la mente en paz 🍂",
proverb_13: "En la gota de rocío, se refleja todo el universo 💧",
proverb_14: "El silencio no está vacío — está lleno de respuestas 🕊️",
proverb_15: "Una piedra inmóvil en el arroyo aprende el paso del tiempo ⛰️",
proverb_16: "Afila tu mente como se pule una espada — lentamente, pacientemente ⚔️",
proverb_17: "No es la fuerza, sino la constancia, la que parte la piedra 💧",
proverb_18: "Cada día, avanza con un paso invisible pero real 👣",
proverb_19: "La flor no abre sus pétalos en una sola mañana 🌸",
proverb_20: "Cada experto fue una vez un principiante 🌟",
proverb_21: "El fracaso es el fundamento del éxito 🌸",
proverb_22: "Incluso la sombra de un árbol habla del sol 🌳",
proverb_23: "La niebla oculta la montaña, pero la montaña permanece ⛰️",
proverb_24: "El aroma del té no necesita palabras 🍵",
proverb_25: "La disciplina no es una cadena, sino una llave 🗝️",

// Meses
month_01: "enero",
month_02: "febrero",
month_03: "marzo",
month_04: "abril",
month_05: "mayo",
month_06: "junio",
month_07: "julio",
month_08: "agosto",
month_09: "septiembre",
month_10: "octubre",
month_11: "noviembre",
month_12: "diciembre",

// Contacto
contact_title: "Contacto",
contact_send_message: "✉️",
contact_message_subtitle: "Comparte tus ideas, sugerencias o preguntas",
contact_category_label: "Categoría:",
contact_cat_suggestion: "💡 Sugerencia",
contact_cat_question: "❓ Pregunta",
contact_cat_feedback: "⭐ Comentario",
contact_cat_other: "📝 Otro",
contact_message_placeholder: "Tu mensaje (máx 500 caracteres)...",
contact_send: "✉️ Enviar",
contact_bug_subtitle: "Informar un error",
contact_email_label: "Correo:",
contact_email_placeholder: "tu@email.com",
contact_bug_description_label: "Descripción del error:",
contact_bug_description_placeholder: "Describe el problema en pocas líneas...",
contact_bug_steps_label: "Pasos para reproducir (opcional):",
contact_bug_steps_placeholder: "1. Hago clic en...\n2. Luego...",
contact_bug_screenshot_title: "📷 ¿Se necesita captura de pantalla?",
contact_bug_screenshot_text: "Si necesitamos una captura, nos pondremos en contacto contigo por correo.",
contact_report_bug: "🐞",
contact_my_messages: "📬",
contact_inbox_title: "📬 Mis mensajes",
contact_loading: "Cargando...",
contact_inbox_empty: "📭 No hay mensajes por ahora",
contact_message_too_short: "Mensaje demasiado corto (mín 10 caracteres)",
contact_invalid_email: "⚠️ Email inválido",
contact_description_too_short: "⚠️ Descripción demasiado corta (mín 20 caracteres)",
contact_success_message: "✅ ¡Mensaje enviado! Te responderemos pronto 🌸",
contact_success_bug: "✅ ¡Bug reportado! Gracias por tu ayuda",
contact_error_short: "Mensaje demasiado corto (mín 10 caracteres)",
contact_error_email: "⚠️ Email inválido",
contact_error_bug_short: "⚠️ Descripción demasiado corta (mín 20 caracteres)",
contact_error_bug_size: "⚠️ Captura demasiado pesada (máx 5MB)",
contact_error_network: "Error de red. Verifica tu conexión.",
contact_response_header: "🌸 Respuesta del equipo",
contact_waiting_response: "Esperando respuesta...",
contact_limit_reached: 'Límite alcanzado: 3 mensajes máximo por día 🌸',
contact_user_not_identified: 'Usuario no identificado. Inicia sesión primero.',
contact_error_occurred: 'Ocurrió un error',
contact_user_not_found: "Usuario no identificado. Conéctate primero.",
contact_inbox_error: "❌ Error de carga",

sync_alert_title: "Pérdida de señal detectada",
sync_alert_message: "Puedes seguir jugando, tu progreso está guardado y se sincronizará cuando vuelva la conexión.",
sync_alert_button: "Entendido",
sync_success_title: "¡Sincronización exitosa!",
sync_success_message: "Todos tus datos se han guardado correctamente.",
sync_success_button: "OK",


    // Tutorial Quiz - Títulos
    tuto_step1_title: "Pequeña presentación",
    tuto_step2_title: "Barra de progreso",
    tuto_step3_title: "Las tarjetas",
    tuto_step4_title: "La pregunta",
    tuto_step5_title: "Las respuestas",
    tuto_step6_title: "❌ Respuesta incorrecta",
    tuto_step7_title: "✅ Respuesta correcta",
    tuto_step8_title: "El menú",
    tuto_step9_title: "¡Vamos!",
    
    // Tutorial Quiz - Textos
    tuto_step1_text: "Antes de empezar, hagamos un rápido recorrido por el juego y su funcionamiento.",
    tuto_step2_text: "El panda avanza a medida que aprendes. Tu objetivo: ayudarlo a llegar al árbol.",
    tuto_step3_text: "Cada tarjeta representa un kana (luego palabras). Gana hasta 5 estrellas por tarjeta. Cuando todas brillen, pasas al siguiente nivel.",
    tuto_step4_text: "Aquí aparecen los elementos que deberás reconocer: kana, romaji o palabras, según el nivel.",
    tuto_step5_text: "Para cada pregunta, elige una respuesta en cada fila entre los botones propuestos.",
    tuto_step6_text: "En caso de error, el rojo muestra lo que está mal y el verde indica la respuesta correcta. Equivocarse es parte del aprendizaje.",
    tuto_step7_text: "Cuando todo es correcto, ganas una estrella. Poco a poco, las respuestas correctas se vuelven naturales.",
    tuto_step8_text: "El menú te permite navegar por las diferentes secciones. Algunas se desbloquearán a medida que progreses. ¿Alguna pregunta? Contáctanos a través del menú Opciones.",
    tuto_step9_text: "Aprender siempre debería ser un juego, ¡así que diviértete y progresa zen! 🌸",
    
    // Botones tutorial
    tuto_next: "Siguiente →",
    tuto_start: "¡Empezar!",

    // Mensajes feedback tutorial
    tuto_perfect: "¡Perfecto!",

token_expired_title: "Sesión expirada",
token_expired_message: "Tu cuenta fue abierta en otro dispositivo. Por favor, recarga la página para continuar.",
token_expired_button: "Recargar página",

// Desbloqueos
unlock_revision_title: 'Modo Revisión',
unlock_revision_message: '¡Ahora puedes revisar tus kanas!',
unlock_garden_title: 'Mi Jardín',
unlock_garden_message: '¡Tu jardín zen ya está accesible!',
unlock_learning_title: 'Modo Aprendizaje Desbloqueado',
unlock_learning_message: '¡Puedes aprender nuevos kanas de nuevo!',

quiz_flash_choice_title: 'Flash Quiz',
quiz_flash_hiragana: '🌸 Hiragana',
quiz_flash_katakana: '⛩️ Katakana'
}
};  

let currentLanguage = localStorage.getItem('appLanguage') || detectBrowserLanguage();

// --- Fonctions i18n ---
function detectBrowserLanguage() {
  // Récupérer la langue du navigateur
  const browserLang = navigator.language || navigator.userLanguage;
  
  console.log('🌍 Langue du navigateur détectée:', browserLang);
  
  // Extraire le code langue (ex: "fr-FR" → "fr", "es-ES" → "es")
  const langCode = browserLang.toLowerCase().split('-')[0];
  
  // Mapping vers les langues supportées
  if (langCode === 'fr') {
    console.log('✅ Français détecté');
    return 'fr';
  } else if (langCode === 'es') {
    console.log('✅ Espagnol détecté');
    return 'es';
  } else {
    console.log('✅ Langue par défaut: Anglais');
    return 'en';
  }
}
function t(key) {
  return translations[currentLanguage][key] || translations['fr'][key] || key;
}
function setLanguage(lang) {
  if (translations[lang]) {
    currentLanguage = lang;
    localStorage.setItem('appLanguage', lang);
    
    // ✅ NOUVEAU : Régénérer les tables Katakana avec la nouvelle langue
    if (HiraganaList.length > 0) {
      revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);
      console.log(`🔄 Table katakana régénérée pour langue ${lang}:`, Object.keys(revisionKatakanaTable).length, "entrées");
    }
    
    updateAllTexts();
    if (revisionMode.isActive) {
  startRevisionQuestion();
} else {
  nextQuestion();
}
  }
}
function updateAllTexts() {
  // Mettre à jour tous les éléments avec data-i18n
  document.querySelectorAll('[data-i18n]').forEach(element => {
    const key = element.getAttribute('data-i18n');
    element.textContent = t(key);
  });
  
  // ✅ AJOUTÉ : Mettre à jour les placeholders
  updatePlaceholders();
  
  // Mettre à jour le niveau actuel
  const levelDisplay = document.getElementById("levelDisplay");
  if (levelDisplay) {
    levelDisplay.innerText = `${t('quiz_level')} ${niveauActif}`;
  }
  
  // Mettre à jour les titres des sections
  updateSectionTitles();
  
  // Mettre à jour les messages du menu si visible
  updateMenuMessage();

updateAccountDisplay();
  
  // Mettre à jour le message de chargement si présent
  const loadingText = document.getElementById("loadingText");
  if (loadingText && (loadingText.textContent.includes("Chargement") || loadingText.textContent.includes("Loading") || loadingText.textContent.includes("Cargando"))) {
    if (gameDataLoaded) {
      loadingText.textContent = t('welcome_touch');
    } else {
      loadingText.textContent = `(${t('welcome_loading')})`;
    }
  }
    setTimeout(() => safeConvertEmojis(document.body), 50);
}
function updatePlaceholders() {
  // Mettre à jour les placeholders avec data-i18n-placeholder
  document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
    const key = element.getAttribute('data-i18n-placeholder');
    element.placeholder = t(key);
  });
}    

function updateSectionTitles() {
  // Titre page d'accueil
  const welcomeTitle = document.querySelector('.welcome-title');
  if (welcomeTitle) welcomeTitle.textContent = t('welcome_title');
  
  const welcomeSubtitle = document.querySelector('.welcome-subtitle');
  if (welcomeSubtitle) welcomeSubtitle.textContent = t('welcome_subtitle');
} 
function getLocalizedKatakana(item) {
  if (currentLanguage === 'en' && item.KatakanaEN) {
    return item.KatakanaEN;
  } else if (currentLanguage === 'es' && item.KatakanaES) {
    return item.KatakanaES;
  }
  return item.Katakana; // Fallback sur français
}
function formatDateForDisplay(day, month) {
  const monthsKeys = ['month_01', 'month_02', 'month_03', 'month_04', 'month_05', 'month_06',
                      'month_07', 'month_08', 'month_09', 'month_10', 'month_11', 'month_12'];
  const monthName = t(monthsKeys[parseInt(month) - 1]);
  const dayNum = parseInt(day);
  
  if (currentLanguage === 'en') {
    // Format anglais : "March 3rd"
    const suffix = getOrdinalSuffix(dayNum);
    return `${monthName} ${dayNum}${suffix}`;
  } else if (currentLanguage === 'es') {
    // Format espagnol : "3 de marzo"
    return `${dayNum} de ${monthName}`;
  } else {
    // Format français (par défaut) : "3 mars"
    return `${dayNum} ${monthName}`;
  }
}
function getOrdinalSuffix(day) {
  if (day >= 11 && day <= 13) {
    return 'th';
  }
  switch (day % 10) {
    case 1: return 'st';
    case 2: return 'nd';
    case 3: return 'rd';
    default: return 'th';
  }
}


// ============================================================================
// 👤 SECTION 2 : AUTHENTIFICATION & UTILISATEUR
// ============================================================================

// --- Variables globales utilisateur ---
let currentUser = null;
let currentPseudoProposal = null;
let userToken = null;

// --- Variables anti-bot ---
let stepTimestamps = {};
let sessionStartTime = null;
let userInteractions = {
  clicks: 0,
  keystrokes: 0,
  mouseMovements: 0
};

// --- Cache pseudos ---
let pseudoCache = [];
let currentPseudoIndex = 0;
// ✅ AJOUT : Constante des noms de mois (utilisée par les sélecteurs de date)
const MONTH_NAMES = {
  fr: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
  en: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  es: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
};
// --- Fonctions authentification ---
async function initUserSystem() {
  

  userToken = localStorage.getItem('userToken');
  
  if (userToken) {
    const result = await callAPI('getUserByToken', { token: userToken });
    
    if (result.success) {
      currentUser = result.user;
      
      // ✅ RÉINITIALISER LE CONTEXTE
      resetGameContext();
      
      await loadUserProgress();
      console.log('✅ Utilisateur connecté:', currentUser.pseudo);
      updateAccountDisplay();
    } else {
      console.warn('⚠️ Token invalide, création de compte nécessaire');
      localStorage.removeItem('userToken');
      userToken = null;
    }
  }
}
async function loginUser() {
  const pseudo = document.getElementById('login-pseudo').value.trim();
  const day = document.getElementById('login-birth-day').value;
  const month = document.getElementById('login-birth-month').value;
  const errorDiv = document.getElementById('login-error');
  const successDiv = document.getElementById('login-success');
  
  errorDiv.style.display = 'none';
  successDiv.style.display = 'none';
  
  // Validation
if (!pseudo) {
  errorDiv.textContent = t('error_enter_pseudo');
  errorDiv.style.display = 'block';
  return;
}

if (!day || !month) {
  errorDiv.textContent = t('error_select_birthdate');
  errorDiv.style.display = 'block';
  return;
}
  
  const pin = day + month;
  
  try {
    console.log('🔐 Tentative de connexion:', pseudo);
    
    // ✅ AJOUTÉ : Afficher le loader
    document.getElementById('login').classList.remove('active');
    document.getElementById('login-loader').style.display = 'flex';
    
    const authResult = await callAPI('authenticateUser', { pseudo, pin });
    
if (!authResult.success) {
  document.getElementById('login-loader').style.display = 'none';
  document.getElementById('login').classList.add('active');
  
  errorDiv.textContent = authResult.error || t('error_wrong_credentials');
  errorDiv.style.display = 'block';
  return;
}
    
    const newToken = crypto.randomUUID();
    
    const updateResult = await callAPI('updateUserToken', {
      pseudo,
      pin,
      newToken
    });
    
    if (updateResult.success) {
      // ✅ Sauvegarder le token
      userToken = newToken;
      localStorage.setItem('userToken', newToken);
      currentUser = authResult.user;
      
      console.log('✅ Token mis à jour, rechargement des données...');
      
      // ✅ Réinitialiser le contexte du jeu
      resetGameContext();
      // 🔍 DEBUG 1 - État de clientTruth avant loadUserProgress
console.log('🔍 DEBUG 1 - clientTruth avant loadUserProgress:', {
  itemCount: Object.keys(clientTruth.stats_json).length,
  niveau_atteint: clientTruth.niveau_atteint
});
      // ✅ Recharger les stats
      await loadUserProgress();
      // ✅ SOLUTION : Reconstruire clientTruth depuis HiraganaList
rebuildClientTruthFromHiraganaList();
console.log('🔧 clientTruth reconstruit:', {
  itemCount: Object.keys(clientTruth.stats_json).length,
  niveau_atteint: clientTruth.niveau_atteint
});
      currentUser.token = newToken;
      
      console.log('✅ Connexion réussie:', currentUser.pseudo);
      console.log(`📊 Niveau actif: ${niveauActif}, Niveau atteint: ${currentUser.niveau_atteint}`);
      
      // ✅ MODIFIÉ : Masquer le loader
      document.getElementById('login-loader').style.display = 'none';
      
      // ✅ AJOUTÉ : Afficher le message de bienvenue returning user
      showReturningUserWelcome(currentUser.pseudo);
      
} else {
  document.getElementById('login-loader').style.display = 'none';
  document.getElementById('login').classList.add('active');
  
  errorDiv.textContent = t('error_token_update');
  errorDiv.style.display = 'block';
}
    
} catch (error) {
  document.getElementById('login-loader').style.display = 'none';
  document.getElementById('login').classList.add('active');
  
  errorDiv.textContent = t('error_connection');
  errorDiv.style.display = 'block';
  console.error('❌ Erreur connexion:', error);
}
}
  
function showLoginFromOnboarding() {
  document.getElementById('create-account').classList.remove('active');
  document.getElementById('login').classList.add('active');
  
  document.getElementById('login-pseudo').value = '';
  
  document.getElementById('login-error').style.display = 'none';
  document.getElementById('login-success').style.display = 'none';
    // ✅ AJOUTÉ : Initialiser les sélecteurs de date
  setTimeout(() => {
    initLoginBirthdateSelectors();
  }, 100);
  console.log('🔄 Navigation vers connexion depuis onboarding');
}
function showChangeDevice() {
  showSection('login');
  
  // ✅ AJOUTÉ : Initialiser les sélecteurs de date
  setTimeout(() => {
    initLoginBirthdateSelectors();
  }, 100);
}
function updateAccountDisplay() {
  if (currentUser) {
    document.getElementById('account-pseudo').textContent = currentUser.pseudo;
    
    const niveauAffiche = currentUser.niveau_actif || niveauActif;
    document.getElementById('account-level').textContent = `${niveauAffiche} ${t('account_level_in_progress')}`;
    
    console.log(`👤 Affichage compte: pseudo=${currentUser.pseudo}, niveau=${niveauAffiche}`);
  }
}

// --- Fonctions onboarding ---
async function initPseudoCache() {
  // ✅ ATTENDRE que les WordLists soient chargées (max 5 secondes)
  let attempts = 0;
  while (!localStorage.getItem('wordLists') && attempts < 50) {
    console.log(`⏳ Attente des WordLists... (${attempts + 1}/50)`);
    await new Promise(resolve => setTimeout(resolve, 100));
    attempts++;
  }
  
  // Si échec après 5 secondes, utiliser le fallback
  if (!localStorage.getItem('wordLists')) {
    console.error('❌ WordLists non disponibles après 5 secondes - Utilisation du fallback');
    pseudoCache = generateFallbackPseudos();
    currentPseudoIndex = 0;
  } else {
    // WordLists disponibles, génération normale
    if (pseudoCache.length === 0) {
      pseudoCache = generatePseudoBatch();
      currentPseudoIndex = 0;
    }
  }
  
  // Initialiser avec le premier pseudo
  const pseudoInput = document.getElementById('pseudo-input');
  if (pseudoInput && pseudoCache.length > 0) {
    pseudoInput.value = pseudoCache[0].pseudo;
    currentPseudoProposal = pseudoCache[0];
    currentPseudoIndex = 1;
  }
  
  // S'assurer que l'étape 1 est active
  document.querySelectorAll('.onboarding-step').forEach(step => {
    step.classList.remove('active');
  });
  document.getElementById('onboarding-step-1').classList.add('active');
  
  // Initialiser protection anti-bot
  sessionStartTime = Date.now();
  stepTimestamps = { 1: Date.now() };
  userInteractions = { clicks: 0, keystrokes: 0, mouseMovements: 0 };
  
  console.log('🛡️ Session anti-bot initialisée');
}
// ✅ NOUVELLE FONCTION : Génération de pseudos de secours
function generateFallbackPseudos() {
  console.log('⚠️ Génération de pseudos de fallback (WordLists non disponibles)');
  
  const fallbackJpn = [
    'Sakura', 'Hana', 'Yuki', 'Sora', 'Kaze', 
    'Umi', 'Hoshi', 'Tsuki', 'Hi', 'Mizu',
    'Kiri', 'Nami', 'Ame', 'Kumo', 'Yama'
  ];
  
  const fallbackEng = [
    'Zen', 'Spirit', 'Dream', 'Cloud', 'Star', 
    'Moon', 'Fire', 'Water', 'Wind', 'Sky',
    'Mist', 'Wave', 'Rain', 'Mountain', 'Light'
  ];
  
  const batch = [];
  for (let i = 0; i < 10; i++) {
    const randomJpn = fallbackJpn[Math.floor(Math.random() * fallbackJpn.length)];
    const randomEng = fallbackEng[Math.floor(Math.random() * fallbackEng.length)];
    
    batch.push({
      pseudo: randomJpn + randomEng,
      jpnWord: randomJpn,
      engWord: randomEng
    });
  }
  
  console.log('✅ 10 pseudos de fallback générés:', batch.slice(0, 3).map(p => p.pseudo));
  return batch;
}
function generatePseudoBatch() {
  const wordListsStr = localStorage.getItem('wordLists');
  if (!wordListsStr) {
    console.error('❌ WordLists non disponibles dans localStorage');
    return [];
  }
  
  let wordLists;
  try {
    wordLists = JSON.parse(wordListsStr);
  } catch (e) {
    console.error('❌ Erreur parsing wordLists:', e);
    return [];
  }
  
  console.log('📦 Structure wordLists:', Object.keys(wordLists));
  
  // ✅ NOUVEAU : Extraire les listes jpn et eng
  let jpnWords, engWords;
  
  if (Array.isArray(wordLists)) {
    // Structure: [{jpn: "...", eng: "..."}, ...]
    jpnWords = wordLists.map(item => item.jpn);
    engWords = wordLists.map(item => item.eng);
  } else if (wordLists.jpn && wordLists.eng) {
    // Structure: {jpn: [...], eng: [...]}
    jpnWords = wordLists.jpn;
    engWords = wordLists.eng;
  } else {
    console.error('❌ Structure wordLists non reconnue:', wordLists);
    return [];
  }
  
  // ✅ GÉNÉRATION avec tirage aléatoire INDÉPENDANT
  const batch = [];
  for (let i = 0; i < 10; i++) {
    const randomJpn = jpnWords[Math.floor(Math.random() * jpnWords.length)];
    const randomEng = engWords[Math.floor(Math.random() * engWords.length)];
    
    batch.push({
      pseudo: randomJpn + randomEng,
      jpnWord: randomJpn,
      engWord: randomEng
    });
  }
  
  console.log(`✅ Batch de ${batch.length} pseudos générés avec combinaisons aléatoires`);
  console.log('🎲 Exemples:', batch.slice(0, 3).map(p => p.pseudo));
  
  return batch;
}
async function generateNewPseudo() {
  const pseudoInput = document.getElementById('pseudo-input');
  const errorDiv = document.getElementById('create-error');
  
  // Vérifier que les éléments existent (protection)
  if (!pseudoInput) {
    console.warn('⚠️ Champ pseudo non trouvé');
    return;
  }
  
  if (errorDiv) {
    errorDiv.style.display = 'none';
  }
  
// Si cache vide ou épuisé, régénérer un batch
  if (currentPseudoIndex >= pseudoCache.length) {
    // ✅ Tenter génération normale, fallback si échec
    if (localStorage.getItem('wordLists')) {
      pseudoCache = generatePseudoBatch();
    } else {
      console.warn('⚠️ WordLists toujours indisponibles, utilisation du fallback');
      pseudoCache = generateFallbackPseudos();
    }
    currentPseudoIndex = 0;
    
    if (pseudoCache.length === 0) {
      if (errorDiv) {
        errorDiv.textContent = 'Erreur : listes de mots non chargées';
        errorDiv.style.display = 'block';
      }
      pseudoInput.value = '';
      return;
    }
  }
  
  // Proposer le prochain pseudo du cache
  currentPseudoProposal = pseudoCache[currentPseudoIndex];
  currentPseudoIndex++;
  
  pseudoInput.value = currentPseudoProposal.pseudo;
  
  console.log(`🎯 Pseudo proposé: ${currentPseudoProposal.pseudo} (${currentPseudoIndex}/${pseudoCache.length} du cache)`);
}


function goToStep(stepNumber) {
  const currentStep = document.querySelector('.onboarding-step.active');
  const nextStep = document.getElementById(`onboarding-step-${stepNumber}`);
  
  if (!currentStep || !nextStep) return;
  
  // Enregistrer timestamp de l'étape
  stepTimestamps[stepNumber] = Date.now();
  
  // Masquer tous les messages d'erreur
  document.getElementById('create-error')?.style.setProperty('display', 'none');
  document.getElementById('pin-error')?.style.setProperty('display', 'none');
  
  // Animation de sortie
  currentStep.classList.add('slide-out-left');
  
  setTimeout(() => {
    currentStep.classList.remove('active', 'slide-out-left');
    nextStep.classList.add('active', 'slide-in-right');
    
    // Focus sur le champ approprié
    if (stepNumber === 2) {
      document.getElementById('pseudo-input')?.focus();
    } else if (stepNumber === 3) {
      // ✅ AJOUTÉ : Initialiser les sélecteurs de date
      initBirthdateSelectors();
      document.getElementById('birth-day')?.focus();
    }
    
    setTimeout(() => {
      nextStep.classList.remove('slide-in-right');
    }, 400);
  }, 400);
  
  console.log(`🎋 Navigation vers étape ${stepNumber}`);
}
function validatePseudoAndContinue() {
  const pseudoInput = document.getElementById('pseudo-input');
  const pseudo = pseudoInput.value.trim();
  const errorDiv = document.getElementById('create-error');
  
  // Vérification délai minimum
  const timeOnStep = Date.now() - (stepTimestamps[2] || Date.now());
  const requiredTime = 3000;
  
if (timeOnStep < requiredTime) {
  const remainingTime = Math.ceil((requiredTime - timeOnStep) / 1000);
  console.warn('🤖 Navigation trop rapide - bot suspecté');
  if (errorDiv) {
    const secondText = remainingTime > 1 ? t('error_seconds') : t('error_second');
    errorDiv.textContent = `${t('error_please_wait')} ${remainingTime} ${secondText}...`;
    errorDiv.style.display = 'block';
    errorDiv.style.color = '#f39c12';
  }
  
  setTimeout(() => {
    if (errorDiv) {
      errorDiv.style.display = 'none';
      errorDiv.style.color = '#dc3545';
    }
  }, remainingTime * 1000);
  
  return;
}
  
  // Validation du pseudo
if (!pseudo || pseudo.length < 2) {
  errorDiv.textContent = t('error_pseudo_too_short');
  errorDiv.style.display = 'block';
  errorDiv.style.color = '#dc3545';
  pseudoInput.focus();
  return;
}

if (pseudo.length > 20) {
  errorDiv.textContent = t('error_pseudo_too_long');
  errorDiv.style.display = 'block';
  errorDiv.style.color = '#dc3545';
  pseudoInput.focus();
  return;
}

const validPattern = /^[a-zA-Z0-9àâäéèêëïîôùûüÿçñÀÂÄÉÈÊËÏÎÔÙÛÜŸÇÑ]+$/;
if (!validPattern.test(pseudo)) {
  errorDiv.textContent = t('error_pseudo_invalid_chars');
  errorDiv.style.display = 'block';
  errorDiv.style.color = '#dc3545';
  pseudoInput.focus();
  return;
}
  
  // Mettre à jour currentPseudoProposal
  currentPseudoProposal = {
    pseudo: pseudo,
    jpnWord: currentPseudoProposal?.jpnWord || '',
    engWord: currentPseudoProposal?.engWord || ''
  };
  
  errorDiv.style.display = 'none';
  
  console.log(`✅ Pseudo validé: ${pseudo}`);
  goToStep(3);
}
// ✅ NOUVELLE FONCTION : Générique pour remplir les sélecteurs de date
function populateBirthdateSelectors(dayId, monthId) {
  const daySelect = document.getElementById(dayId);
  const monthSelect = document.getElementById(monthId);
  
  if (!daySelect || !monthSelect) return;
  
  // Générer les jours (01-31)
  daySelect.innerHTML = '<option value="">--</option>';
  for (let i = 1; i <= 31; i++) {
    const day = String(i).padStart(2, '0');
    daySelect.innerHTML += `<option value="${day}">${day}</option>`;
  }
  
  // Générer les mois avec la langue actuelle
  const monthNames = MONTH_NAMES[currentLanguage] || MONTH_NAMES.en;
  monthSelect.innerHTML = '<option value="">--</option>';
  
  for (let i = 1; i <= 12; i++) {
    const month = String(i).padStart(2, '0');
    monthSelect.innerHTML += `<option value="${month}">${monthNames[i-1]}</option>`;
  }
  
  console.log(`📅 Sélecteurs ${dayId}/${monthId} initialisés en ${currentLanguage}`);
}  
function initBirthdateSelectors() {
  populateBirthdateSelectors('birth-day', 'birth-month');
}
function initLoginBirthdateSelectors() {
  populateBirthdateSelectors('login-birth-day', 'login-birth-month');
}
function validateBirthdateAndContinue() {
  const daySelect = document.getElementById('birth-day');
  const monthSelect = document.getElementById('birth-month');
  const errorDiv = document.getElementById('pin-error');
  
  const day = daySelect.value;
  const month = monthSelect.value;
  
  // Vérification délai minimum
  const timeOnStep = Date.now() - (stepTimestamps[3] || Date.now());
  const requiredTime = 2000;
  
  if (timeOnStep < requiredTime) {
    const remainingTime = Math.ceil((requiredTime - timeOnStep) / 1000);
    console.warn('🤖 Navigation trop rapide - bot suspecté');
    if (errorDiv) {
      const secondText = remainingTime > 1 ? t('error_seconds') : t('error_second');
      errorDiv.textContent = `${t('error_please_wait')} ${remainingTime} ${secondText}...`;
      errorDiv.style.display = 'block';
      errorDiv.style.color = '#f39c12';
    }
    
    setTimeout(() => {
      if (errorDiv) {
        errorDiv.style.display = 'none';
        errorDiv.style.color = '#dc3545';
      }
    }, remainingTime * 1000);
    
    return;
  }
  
  // Validation de la sélection
  if (!day || !month) {
    if (errorDiv) {
      errorDiv.textContent = t('error_select_date');
      errorDiv.style.display = 'block';
      errorDiv.style.color = '#dc3545';
    }
    return;
  }
  
  // ✅ AJOUTÉ : Définition de daysInMonth
  const daysInMonth = {
    '01': 31, '02': 29, '03': 31, '04': 30, '05': 31, '06': 30,
    '07': 31, '08': 31, '09': 30, '10': 31, '11': 30, '12': 31
  };
  
  const maxDay = daysInMonth[month];
  if (parseInt(day) > maxDay) {
    if (errorDiv) {
      errorDiv.textContent = `${t('error_invalid_day')} ${day} ${t('error_invalid_day_suffix')}`;
      errorDiv.style.display = 'block';
      errorDiv.style.color = '#dc3545';
    }
    return;
  }
  
  if (errorDiv) {
    errorDiv.style.display = 'none';
  }
  
 // Créer le PIN au format JJMM
const pin = day + month;
window.tempPin = pin;

// ✅ Afficher la date formatée selon la langue
const formattedDate = formatDateForDisplay(day, month);
document.getElementById('confirm-date-display').textContent = formattedDate;

console.log(`✅ Date validée: ${pin}`);
goToStep(4);
}

async function finalizeAccount() {
  const pin = window.tempPin;
  
  if (!pin || !currentPseudoProposal) {
    console.error('❌ Données manquantes pour finaliser le compte');
    return;
  }
  
  // ✅ AJOUTÉ : VÉRIFICATIONS ANTI-BOT
  
  // 1. Vérifier honeypot
  const honeypot = document.getElementById('website');
  if (honeypot && honeypot.value !== '') {
    console.warn('🤖 Bot détecté via honeypot');
    showAccountCreationLoader();
    setTimeout(() => {
      hideAccountCreationLoader();
      goToStep(1);
    }, 2000);
    return;
  }
  
// 2. Vérifier temps total minimum (15 secondes)
const totalTime = Date.now() - (sessionStartTime || Date.now());
const requiredTotalTime = 5000; // 15 secondes

if (totalTime < requiredTotalTime) {
  const remainingTime = Math.ceil((requiredTotalTime - totalTime) / 1000);
  console.warn('🤖 Création trop rapide:', totalTime, 'ms');
  
  goToStep(4);
  
  const errorDiv = document.getElementById('create-error');
  if (errorDiv) {
    const secondText = remainingTime > 1 ? t('error_seconds') : t('error_second');
    errorDiv.textContent = `${t('error_please_wait')} ${remainingTime} ${secondText} ${t('error_before_validate')}`;
    errorDiv.style.display = 'block';
    errorDiv.style.color = '#f39c12';
  }
  
  setTimeout(() => {
    if (errorDiv) {
      errorDiv.style.display = 'none';
      errorDiv.style.color = '#dc3545';
    }
  }, remainingTime * 1000);
  
  return;
}

//if (userInteractions.clicks < 3 || userInteractions.keystrokes < 0) {
//  console.warn('🤖 Interactions insuffisantes:', userInteractions);
//  const errorDiv = document.getElementById('create-error');
//  if (errorDiv) {
//    errorDiv.textContent = t('error_suspicious_activity');
//    errorDiv.style.display = 'block';
//  }
//  return;
// }
  
// 4. Vérifier que le pseudo a des mots source (protection supplémentaire)
//  if (!currentPseudoProposal.jpnWord && !currentPseudoProposal.engWord) {
//    console.warn('🤖 Pseudo sans origine - suspecté');
//    return;
//  }
  
  console.log('✅ Vérifications anti-bot passées:', {
    totalTime: totalTime + 'ms',
    clicks: userInteractions.clicks,
    keystrokes: userInteractions.keystrokes,
    mouseMovements: userInteractions.mouseMovements
  });
  
  // Masquer l'étape 4 et afficher loader
  document.getElementById('onboarding-step-4').classList.remove('active');
  showAccountCreationLoader();
  
  userToken = crypto.randomUUID();
  
  try {
    const result = await callAPI('assignPseudo', {
      token: userToken,
      pseudo: currentPseudoProposal.pseudo,
      jpnWord: currentPseudoProposal.jpnWord,
      engWord: currentPseudoProposal.engWord,
      pin: pin
    });
    
    if (result.success) {
      localStorage.setItem('userToken', userToken);
      currentUser = result.user;
      await loadUserProgress();
      
      console.log('✅ Compte créé avec succès:', currentUser.pseudo);
      localStorage.removeItem('quizTutorialSeen');
      showWelcomeAnimation(currentUser.pseudo);
      
      setTimeout(() => {
        document.getElementById('welcome-screen').style.display = 'none';
        
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        document.getElementById('welcome').classList.add('active');
        
        document.querySelector('.panda-logo').style.display = 'none';
        document.getElementById('loadingText').style.display = 'none';
        
        document.querySelector('.hamburger').classList.remove('hidden');
        
        if (isApprentissageBloque()) {
          console.log('🚫 Mode Apprendre bloqué → Redirection vers Mode Révision');
          forceRevisionMode();
        } else {
          console.log('✅ Mode Apprendre débloqué → Redirection vers Mode Apprendre');
          showSection('quiz');
        }
        
        updateAccountDisplay();
      }, 3500);
      
    } else {
  hideAccountCreationLoader();
  goToStep(4);
  const errorDiv = document.getElementById('create-error');
  
 
}
} catch (error) {
  hideAccountCreationLoader();
  goToStep(4);
  const errorDiv = document.getElementById('create-error');
  errorDiv.textContent = t('error_connection');
  errorDiv.style.display = 'block';
  console.error('❌ Erreur:', error);
}
  
  delete window.tempPin;
}




// --- Loaders & animations d'accueil ---
function showAccountCreationLoader() {
  const messages = [
    t('loader_meditation'),
    t('loader_tea'),
    t('loader_cherry'),
    t('loader_garden'),
    t('loader_ceremony')
  ];
  
  const loaderScreen = document.getElementById('account-creation-loader');
  const textElement = loaderScreen.querySelector('.zen-loader-text');
  
  textElement.textContent = messages[Math.floor(Math.random() * messages.length)];
  
  loaderScreen.style.display = 'flex';
}
function hideAccountCreationLoader() {
  document.getElementById('account-creation-loader').style.display = 'none';
}

function showWelcomeAnimation(pseudo) {
  hideAccountCreationLoader();
  
  const welcomeScreen = document.getElementById('welcome-screen');
  const titleElement = document.querySelector('.welcome-user-title');
  
  titleElement.textContent = `${t('welcome_user')} ${pseudo} 🎌`;
  welcomeScreen.style.display = 'flex';
  
  triggerSakuraFall(welcomeScreen);
  
  playLevelUp();
}
function showReturningUserWelcome(pseudo) {
  const messages = [
    t('proverb_1'),
    t('proverb_2'),
    t('proverb_3'),
    t('proverb_4'),
    t('proverb_5'),
    t('proverb_6'),
    t('proverb_7'),
    t('proverb_8'),
    t('proverb_9'),
    t('proverb_10'),
    t('proverb_11'),
    t('proverb_12'),
    t('proverb_13'),
    t('proverb_14'),
    t('proverb_15'),
    t('proverb_16'),
    t('proverb_17'),
    t('proverb_18'),
    t('proverb_19'),
    t('proverb_20'),
    t('proverb_21'),
    t('proverb_22'),
    t('proverb_23'),
    t('proverb_24'),
    t('proverb_25')
  ];
  
  // ✅ CRÉER UN OVERLAY TEMPORAIRE au lieu d'utiliser #welcome-screen
  const overlay = document.createElement('div');
  overlay.id = 'returning-user-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #F8F1E9;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 99999;
    overflow: hidden;
  `;
  
  const randomMessage = messages[Math.floor(Math.random() * messages.length)];
  
  // Créer le titre
  const title = document.createElement('h1');
  title.style.cssText = `
   
    color: #8B6F47;
    text-shadow: 0 0 20px rgba(253, 193, 197, 0.5);
    animation: welcome-fade-in 1s ease-out;
    text-align: center;
    padding: 0 20px;
    margin: 0 0 20px 0;
  `;
  title.textContent = `${t('welcome_back')} ${pseudo} ! 🎌`;
  
  // Créer le sous-titre
  const subtitle = document.createElement('p');
  subtitle.style.cssText = `
  
    color: #8B6F47;
    opacity: 0.8;
    animation: welcome-fade-in 1s ease-out 0.5s both;
    text-align: center;
    padding: 0 20px;
    margin: 0;
  `;
  subtitle.textContent = randomMessage;
  
  overlay.appendChild(title);
  overlay.appendChild(subtitle);
  
  // Ajouter au body
  document.body.appendChild(overlay);
  
  console.log('✅ Overlay créé et ajouté au DOM');
  
  // Petite chute de sakura
  for (let i = 0; i < 15; i++) {
    const sakura = document.createElement("div");
    sakura.className = "sakura";
    sakura.style.cssText = `
      position: absolute;
      width: 12px;
      height: 12px;
      background: #FDC1C5;
      border-radius: 50%;
      pointer-events: none;
      animation: sakuraFall ${2.5 + Math.random() * 1.5}s linear forwards;
      animation-delay: ${Math.random() * 1.5}s;
      left: ${Math.random() * 100}vw;
      top: -10px;
      z-index: 10;
    `;
    overlay.appendChild(sakura);
    setTimeout(() => sakura.remove(), 6000);
  }
  
  playEnterSound();
  
setTimeout(() => {
  console.log('⏰ Timeout atteint, fermeture overlay');
  
  // Supprimer l'overlay
  overlay.remove();
  
  // Retourner à la section welcome (fond zen)
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  const welcomeSection = document.getElementById('welcome');
  welcomeSection.classList.add('active');
  
  // Masquer le panda et le texte de chargement
  const panda = document.querySelector('.panda-logo');
  const loadingText = document.getElementById('loadingText');
  if (panda) panda.style.display = 'none';
  if (loadingText) loadingText.style.display = 'none';
  
  // ✅ NOUVEAU : Redirection intelligente
  if (isApprentissageBloque()) {
    console.log('🚫 Mode Apprendre bloqué → Redirection vers Mode Révision');
    forceRevisionMode();
  } else {
    console.log('✅ Mode Apprendre débloqué → Redirection vers Mode Apprendre');
    showSection('quiz');
  }
  
  // Afficher le hamburger
  const hamburger = document.querySelector('.hamburger');
  if (hamburger) hamburger.classList.remove('hidden');
  
  updateAccountDisplay();
}, 2500);
}


// ============================================================================
// 📊 SECTION 3 : DONNÉES & GESTION DE CACHE
// ============================================================================

// --- Données principales ---
let HiraganaList = [];
let gameDataLoaded = false;
let backgroundLoadingInProgress = false;

// --- Cache de validation & stats ---
let validationCache = {}; // { [id]: validationNumber }
let statsCache = {
  items: {}, // { [id]: { tentatives, reussites, pourcentage } }
  globalPourcentage: 0
};

// --- Tables de révision ---
let revisionRomajiTable = {};
let revisionKatakanaTable = {};

// --- Variables de progression ---
let niveauActif = 1;
let seuilValidation = parseInt(localStorage.getItem('difficulty')) || 6;
let previousValidationStates = new Map();

// --- Groupes de niveaux ---
const GROUPES = {
  1: { niveaux: [1, 2, 3], nom: "Groupe 1" },
  2: { niveaux: [4, 5], nom: "Groupe 2" },
  3: { niveaux: [6, 7, 8], nom: "Groupe 3" },
  4: { niveaux: [9, 10, 11, 12], nom: "Groupe 4" },
  5: { niveaux: [13, 14, 15, 16, 17], nom: "Groupe 5" },
  6: { niveaux: [18, 19, 20, 21, 22], nom: "Groupe 6" },
  7: { niveaux: [23, 24, 25, 26, 27], nom: "Groupe 7" },
  8: { niveaux: [28, 29, 30, 31, 32, 33], nom: "Groupe 8" },
  9: { niveaux: [34, 35, 36, 37, 38, 39], nom: "Groupe 9" },
  10: { niveaux: [40, 41, 42, 43, 44, 45, 46], nom: "Groupe 10" }
};

// --- Fonctions de gestion des données ---
async function loadUserProgress() {
  if (!userToken) {
    console.warn('⚠️ Pas de token - Stats non chargées');
    return;
  }
  
  const userStats = await callAPI('getUserStats', { token: userToken });
  if (userStats.success) {
    const stats = userStats.stats || {};
    let mergedCount = 0;
    
    // ✅ Merger les stats dans HiraganaList
    HiraganaList.forEach(item => {
      const itemId = item.ID.toString();
      const itemStats = stats[itemId] || { validation: 0, tentatives: 0, reussites: 0 };
      
      item.Validation = itemStats.validation;
      item.Tentatives = itemStats.tentatives;
      item['Réussites'] = itemStats.reussites;
      mergedCount++;
      
      const id = parseInt(item.ID);
      validationCache[id] = parseInt(itemStats.validation);
      
      const tentatives = parseInt(itemStats.tentatives || 0);
      const reussites = parseFloat(itemStats.reussites || 0);
      const pourcentage = tentatives > 0 ? (reussites / tentatives * 100) : 0;
      
      statsCache.items[id] = {
        tentatives: tentatives,
        reussites: reussites,
        pourcentage: pourcentage
      };
    });

    const totalTentatives = Object.values(statsCache.items).reduce((sum, item) => sum + item.tentatives, 0);
    const totalReussites = Object.values(statsCache.items).reduce((sum, item) => sum + item.reussites, 0);
    statsCache.globalPourcentage = totalTentatives > 0 ? (totalReussites / totalTentatives * 100) : 0;

    console.log(`📊 Progrès user chargé: ${mergedCount} items mergés`);
    console.log('🔍 DEBUG 2 - État après merge dans HiraganaList:', {
  hiraganaListCount: HiraganaList.length,
  clientTruthCount: Object.keys(clientTruth.stats_json).length,
  premierItem: HiraganaList[0]
});
    // ✅ Calculer le niveau MAX ATTEINT (niveaux 100% complétés)
    let niveauMaxAtteint = 0;
    const maxLevel = getMaxLevel(HiraganaList);
    
    for (let n = 1; n <= maxLevel; n++) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === n);
      const itemsValides = itemsNiveau.filter(h => parseInt(h.Validation || 0) >= 5);
      
      if (itemsValides.length === itemsNiveau.length && itemsNiveau.length > 0) {
        niveauMaxAtteint = n;
      } else {
        break;
      }
    }
    
    // ✅ Calculer le niveau ACTIF (utilise la fonction corrigée)
    niveauActif = determineNiveauActif(HiraganaList);
    
    console.log(`🏆 Niveau MAX ATTEINT: ${niveauMaxAtteint} (tous les items à >=5)`);
    console.log(`🎮 Niveau ACTIF: ${niveauActif} (premier niveau incomplet)`);
    console.log(`🚫 Mode apprentissage bloqué: ${isApprentissageBloque()}`);
    
    // ✅ Mettre à jour currentUser
    if (currentUser) {
      currentUser.niveau_atteint = niveauMaxAtteint;
      currentUser.niveau_actif = niveauActif;
    }
    
    // ✅ Régénérer les tables
    revisionRomajiTable = generateRevisionRomajiTable(HiraganaList);
    revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);
    
    // ✅ Rafraîchir l'UI
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
    updateLevelProgress(HiraganaList, niveauActif);
    renderProgressBar(niveauActif, maxLevel);
    renderHiraganaCards(HiraganaList, niveauActif);
    updateMenuButtonStates();
    updateAccountDisplay();
    
    console.log('✅ loadUserProgress terminé');
 //   initClientTruth(userStats.stats, niveauMaxAtteint);

  } else {
    console.error('⚠️ Erreur chargement stats user:', userStats.error);
    niveauActif = 1;
    if (currentUser) {
      currentUser.niveau_atteint = 0;
      currentUser.niveau_actif = 1;
    }
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} 1`;
    updateAccountDisplay();
  }
  updateSyncIndicator();
}
async function applyUserProgress() {
  if (!userToken) {
    console.warn('⚠️ Pas de token - Stats non chargées');
    return;
  }

  const userStats = await callAPI('getUserStats', { token: userToken });
  if (userStats.success) {
    const stats = userStats.stats || {};
    let mergedCount = 0;

    // ✅ Merger les stats dans HiraganaList
    HiraganaList.forEach(item => {
      const itemId = item.ID.toString();
      const itemStats = stats[itemId] || { validation: 0, tentatives: 0, reussites: 0 };

      item.Validation = itemStats.validation;
      item.Tentatives = itemStats.tentatives;
      item['Réussites'] = itemStats.reussites;
      mergedCount++;

      const id = parseInt(item.ID);
      validationCache[id] = parseInt(itemStats.validation);

      const tentatives = parseInt(itemStats.tentatives || 0);
      const reussites = parseFloat(itemStats.reussites || 0);
      const pourcentage = tentatives > 0 ? (reussites / tentatives * 100) : 0;

      statsCache.items[id] = {
        tentatives: tentatives,
        reussites: reussites,
        pourcentage: pourcentage
      };
    });

    const totalTentatives = Object.values(statsCache.items).reduce((sum, item) => sum + item.tentatives, 0);
    const totalReussites = Object.values(statsCache.items).reduce((sum, item) => sum + item.reussites, 0);
    statsCache.globalPourcentage = totalTentatives > 0 ? (totalReussites / totalTentatives * 100) : 0;
    console.log(`📊 Progrès user chargé: ${mergedCount} items mergés`);

    // ✅ Calculer le niveau MAX ATTEINT
    let niveauMaxAtteint = 0;
    const maxLevel = getMaxLevel(HiraganaList);

    for (let n = 1; n <= maxLevel; n++) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === n);
      const itemsValides = itemsNiveau.filter(h => parseInt(h.Validation || 0) >= 5);

      if (itemsValides.length === itemsNiveau.length && itemsNiveau.length > 0) {
        niveauMaxAtteint = n;
      } else {
        break;
      }
    }

    // ✅ Calculer le niveau ACTIF
    niveauActif = determineNiveauActif(HiraganaList);

    console.log(`🏆 Niveau MAX ATTEINT: ${niveauMaxAtteint} (tous les items à >=5)`);
    console.log(`🎮 Niveau ACTIF: ${niveauActif} (premier niveau incomplet)`);
    console.log(`🚫 Mode apprentissage bloqué: ${isApprentissageBloque()}`);

    // ✅ Mettre à jour currentUser
    if (currentUser) {
      currentUser.niveau_atteint = niveauMaxAtteint;
      currentUser.niveau_actif = niveauActif;
    }

    // ✅ Régénérer les tables
    revisionRomajiTable = generateRevisionRomajiTable(HiraganaList);
    revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);

    // ✅ Rafraîchir l'UI (seulement si on est déjà dans le jeu)
    if (gameDataLoaded || document.getElementById("levelDisplay")) {
      document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
      updateLevelProgress(HiraganaList, niveauActif);
      renderProgressBar(niveauActif, maxLevel);
      renderHiraganaCards(HiraganaList, niveauActif);
      updateMenuButtonStates();
      updateAccountDisplay();
    }

    console.log('✅ applyUserProgress terminé');
  } else {
    console.error('⚠️ Erreur chargement stats user:', userStats.error);
    niveauActif = 1;
    if (currentUser) {
      currentUser.niveau_atteint = 0;
      currentUser.niveau_actif = 1;
    }
    if (document.getElementById("levelDisplay")) {
      document.getElementById("levelDisplay").innerText = `${t('quiz_level')} 1`;
      updateAccountDisplay();
    }
  }
  updateSyncIndicator();
}
function generateRevisionRomajiTable(hiraganaList) {
  const table = {};
  let validItems = 0;
  let invalidItems = 0;
  
  hiraganaList.forEach((item, index) => {
    const hiragana = item.Hiragana;
    const romaji = item.Romaji;
    
    if (!hiragana || !romaji) {
      console.warn(`⚠️ Item ${index} ignoré - données manquantes:`, {hiragana, romaji});
      invalidItems++;
      return;
    }
    
    const hiraganaStr = String(hiragana).trim();
    const romajiStr = String(romaji).trim();
    
    if (hiraganaStr === '' || romajiStr === '' || romajiStr === 'undefined' || romajiStr === 'null') {
      console.warn(`⚠️ Item ${index} ignoré - données vides:`, {hiragana: hiraganaStr, romaji: romajiStr});
      invalidItems++;
      return;
    }
    
    try {
      // ✅ PASSER LE KANA EN PARAMÈTRE
      const segments = analyzeRomajiSegments(romajiStr, hiraganaStr);
      table[hiraganaStr] = {
        romaji: segments.segments,
        charCounts: segments.charCounts,
        originalRomaji: romajiStr,
        niveau: item.Niveau,
        validation: item.Validation
      };
      validItems++;
      
      // Log seulement pour les cas multi-caractères
      if (hiraganaStr.length > 1) {
        console.log(`📝 ${hiraganaStr} (${romajiStr}) → ${JSON.stringify(segments.segments)} chars: ${JSON.stringify(segments.charCounts)}`);
      }
    } catch (error) {
      console.error(`❌ Erreur lors de l'analyse de l'item ${index}:`, {hiragana: hiraganaStr, romaji: romajiStr}, error);
      invalidItems++;
    }
  });
  
  console.log(`📊 Génération table romaji: ${validItems} items valides, ${invalidItems} items ignorés`);
  return table;
}

function generateRevisionKatakanaTable(hiraganaList) {
  const table = {};
  let validItems = 0;
  let invalidItems = 0;
  
  hiraganaList.forEach((item, index) => {
    const katakana = getLocalizedKatakana(item);
    const romaji = item.Romaji;
    
    if (!katakana || !romaji) {
      console.warn(`⚠️ Item ${index} ignoré pour Katakana - données manquantes:`, {katakana, romaji});
      invalidItems++;
      return;
    }
    
    const katakanaStr = String(katakana).trim();
    const romajiStr = String(romaji).trim();
    
    if (katakanaStr === '' || romajiStr === '' || romajiStr === 'undefined' || romajiStr === 'null') {
      invalidItems++;
      return;
    }
    
    try {
      // ✅ PASSER LE KANA EN PARAMÈTRE
      const segments = analyzeRomajiSegments(romajiStr, katakanaStr);
      table[katakanaStr] = {
        romaji: segments.segments,
        charCounts: segments.charCounts,
        originalRomaji: romajiStr,
        niveau: item.Niveau,
        validation: item.Validation
      };
      validItems++;
      
      if (katakanaStr.length > 1) {
        console.log(`📝 ${katakanaStr} (${romajiStr}) → ${JSON.stringify(segments.segments)} chars: ${JSON.stringify(segments.charCounts)}`);
      }
    } catch (error) {
      invalidItems++;
    }
  });
  
  console.log(`📊 Génération table katakana: ${validItems} items valides, ${invalidItems} items ignorés`);
  return table;
}

function analyzeRomajiSegments(romajiInput, kanaText = null) {
  if (!romajiInput) {
    throw new Error("Romaji vide ou null");
  }
  
  let romajiString = String(romajiInput).toLowerCase().trim();
  romajiString = romajiString.replace(/[^a-z]/g, '');
  if (romajiString === '') {
    throw new Error("Romaji vide après nettoyage des caractères spéciaux");
  }
  
  // Segmenter intelligemment le romaji
  const segments = smartSegmentRomaji(romajiString);
  
  // Si pas de kana fourni, utiliser l'ancienne logique (1 segment = 1 char)
  if (!kanaText) {
    return {
      segments: segments,
      charCounts: segments.map(() => 1)
    };
  }
  
  // ✅ NOUVEAU : Calculer les charCounts en fonction du texte kana
  const charCounts = calculateCharCounts(segments, kanaText);
  
  return {
    segments: segments,
    charCounts: charCounts
  };
}

/**
 * Calcule le nombre de caractères kana pour chaque segment romaji
 */
function calculateCharCounts(romajiSegments, kanaText) {
  const smallKana = ['ゃ', 'ゅ', 'ょ', 'ャ', 'ュ', 'ョ', 'ぁ', 'ぃ', 'ぅ', 'ぇ', 'ぉ', 'ァ', 'ィ', 'ゥ', 'ェ', 'ォ', 'ゎ', 'ヮ'];
  const smallTsu = ['っ', 'ッ'];
  
  const charCounts = [];
  let kanaPos = 0;
  
  for (let segIndex = 0; segIndex < romajiSegments.length; segIndex++) {
    const segment = romajiSegments[segIndex];
    let charCount = 1; // Par défaut : 1 segment romaji = 1 char kana
    
    if (kanaPos >= kanaText.length) {
      charCounts.push(1);
      continue;
    }
    
    const currentKana = kanaText[kanaPos];
    const nextKana = kanaPos + 1 < kanaText.length ? kanaText[kanaPos + 1] : null;
    
    // CAS 1 : Petit tsu suivi d'un caractère (っぷ = "ppu" par exemple)
    if (smallTsu.includes(currentKana) && nextKana) {
      // Le っ + caractère suivant = 1 segment romaji avec double consonne
      charCount = 2;
      kanaPos += 2;
    }
    
    // CAS 2 : Caractère + petit kana (き + ゅ = "kyu")
    else if (nextKana && smallKana.includes(nextKana)) {
      charCount = 2;
      kanaPos += 2;
    }
    
    // CAS 3 : Voyelle longue spéciale (お + よ = "oyo")
    else if ('おオ'.includes(currentKana) && nextKana && 'よョ'.includes(nextKana)) {
      charCount = 2;
      kanaPos += 2;
    }
    
    // CAS 4 : Caractère simple
    else {
      charCount = 1;
      kanaPos += 1;
    }
    
    charCounts.push(charCount);
  }
  
  // Vérification de sécurité : si les comptes ne correspondent pas, fallback
  const totalChars = charCounts.reduce((a, b) => a + b, 0);
  if (totalChars !== kanaText.length) {
    console.warn(`⚠️ Désynchronisation détectée pour "${kanaText}": ${totalChars} chars calculés vs ${kanaText.length} attendus`);
    // Fallback : tous à 1
    return romajiSegments.map(() => 1);
  }
  
  return charCounts;
}
// ✅ AJOUT : Constantes pour la segmentation romaji (utilisées par smartSegmentRomaji)
const ROMAJI_SPECIAL_SYLLABLES = [
  'tsu', 'shi', 'chi', 'sha', 'sho', 'shu', 'cha', 'cho', 'chu',
  'nya', 'nyo', 'nyu', 'hya', 'hyo', 'hyu', 'mya', 'myo', 'myu',
  'rya', 'ryo', 'ryu', 'gya', 'gyo', 'gyu', 'bya', 'byo', 'byu',
  'pya', 'pyo', 'pyu', 'kya', 'kyo', 'kyu', 'ja', 'ji', 'ju', 'jo'
];

const ROMAJI_BASIC_SYLLABLES = [
  'ka', 'ki', 'ku', 'ke', 'ko', 'ga', 'gi', 'gu', 'ge', 'go',
  'sa', 'shi', 'su', 'se', 'so', 'za', 'ji', 'zu', 'ze', 'zo',
  'ta', 'chi', 'tsu', 'te', 'to', 'da', 'ji', 'zu', 'de', 'do',
  'na', 'ni', 'nu', 'ne', 'no',
  'ha', 'hi', 'fu', 'he', 'ho', 'ba', 'bi', 'bu', 'be', 'bo', 'pa', 'pi', 'pu', 'pe', 'po',
  'ma', 'mi', 'mu', 'me', 'mo',
  'ya', 'yu', 'yo',
  'ra', 'ri', 'ru', 're', 'ro',
  'wa', 'wi', 'we', 'wo', 'n'
];

const ROMAJI_VOWELS = ['a', 'i', 'u', 'e', 'o'];

// ✅ Pré-calculer et trier une seule fois
const ROMAJI_ALL_SYLLABLES = [
  ...ROMAJI_SPECIAL_SYLLABLES, 
  ...ROMAJI_BASIC_SYLLABLES, 
  ...ROMAJI_VOWELS
].sort((a, b) => b.length - a.length);  // Tri par longueur décroissante

function smartSegmentRomaji(romaji) {
  if (!romaji || typeof romaji !== 'string') {
    console.warn("smartSegmentRomaji: romaji invalide", romaji);
    return [romaji || ''];
  }
  
  const segments = [];
  let remaining = romaji.toLowerCase();
  
  while (remaining.length > 0) {
    let found = false;
    
    // ✅ Utiliser la liste pré-triée
    for (const syllable of ROMAJI_ALL_SYLLABLES) {
      if (remaining.startsWith(syllable)) {
        segments.push(syllable);
        remaining = remaining.slice(syllable.length);
        found = true;
        break;
      }
    }
    
    // Fallback : prendre 2 caractères si possible (consonne + voyelle), sinon 1
    if (!found) {
      if (remaining.length >= 2 && !ROMAJI_VOWELS.includes(remaining[0])) {
        segments.push(remaining.slice(0, 2));
        remaining = remaining.slice(2);
      } else {
        segments.push(remaining[0]);
        remaining = remaining.slice(1);
      }
    }
  }
  
  return segments.length > 0 ? segments : [romaji];
}


// ============================================================================
// 🌐 SECTION 4 : API & COMMUNICATION SERVEUR
// ============================================================================

const WEB_APP_URL = 'https://kanaszengarden.emmanuel-pierre.workers.dev/api';
let pendingUpdates = [];
let isProcessing = false;
async function ensureLatestProgress() {
  if (!userToken || !currentUser) {
    console.warn('⚠️ Pas de token ou currentUser → skip ensureLatestProgress');
    return;
  }

  console.log('🔍 Vérification des progrès : comparaison local vs serveur...');

  // Récupérer les stats serveur (sans les merger encore)
  const userStatsResult = await callAPI('getUserStats', { token: userToken });

  if (!userStatsResult.success) {
    console.warn('⚠️ Impossible de récupérer les stats serveur → on garde le local tel quel');
    return;
  }

  const serverStats = userStatsResult.stats || {};
  const serverNiveauAtteint = userStatsResult.niveau_atteint || 0;

  // On appelle initClientTruth qui va :
  // - comparer
  // - lancer une sync si local plus avancé
  // - et on l'attend grâce au fait qu'on va le rendre awaitable (voir point 2)
  await initClientTruth(serverStats, serverNiveauAtteint);

  console.log('✅ Progression synchronisée : les stats serveur sont maintenant à jour');
}
  
  
 //===============================================
// SYNC CHECK TRIGGER - basé sur la descente du compteur
// ===============================================
const SyncCheckTrigger = {
  armed: false,
  threshold: 5,
  lastPendingCount: 0,
  
  evaluate() {
    const current = pendingUpdates.length;
    
    // 🎯 ARMEMENT : on dépasse le seuil
    if (!this.armed && current >= this.threshold) {
      this.armed = true;
      console.log(
        `%c[SYNC TRIGGER] ⚡ ARMÉ (${current} updates en attente)`,
        'color:#f80;font-weight:bold'
      );
    }
    
    // 🔥 DÉCLENCHEMENT : armé + compteur qui descend
    if (this.armed && current < this.lastPendingCount && navigator.onLine) {
      console.log(
        `%c[SYNC TRIGGER] 🚀 DÉCLENCHÉ (${this.lastPendingCount} → ${current})`,
        'color:#0c0;font-weight:bold'
      );
      
      this.armed = false; // Désarmer
      
      // ✅ STOPPER la queue immédiatement
      isProcessing = false;
      
      // ✅ Lancer le sync check
      setTimeout(() => {
        performSyncCheck('auto-trigger-on-descent');
      }, 100); // Petit délai pour que isProcessing = false soit bien pris en compte
    }
    
    this.lastPendingCount = current;
  }
};
  
// ===============================================
// POLLING DE SYNCHRONISATION (robuste même en mode avion)
// ===============================================
let syncPollingInterval = null;




function startSyncPolling() {
  if (syncPollingInterval) return; // déjà actif

  console.log('🔄 Démarrage du polling de synchronisation (toutes les 8s)');

  syncPollingInterval = setInterval(() => {
    // Conditions pour lancer le traitement
    if (
      navigator.onLine &&                     // on a une connexion
      pendingUpdates.length > 0 &&            // il y a des updates en attente
      !isProcessing &&                        // la queue n'est pas déjà en train de tourner
      !SyncMonitor.syncCheckInProgress         // pas en plein sync check
    ) {
      console.log(`🌐 Connexion détectée + ${pendingUpdates.length} updates en attente → lancement sync`);
      processUpdates();
    }

    // Optionnel : même si pas d'updates pending, on peut forcer un sync check périodique
    // si on veut être ultra-parano (toutes les 2-3 minutes par exemple)
    // Mais pas nécessaire si tu fais déjà des checks après level-up
  }, 80000); // toutes les 80 secondes → très léger, pas de batterie drain
}

function stopSyncPolling() {
  if (syncPollingInterval) {
    clearInterval(syncPollingInterval);
    syncPollingInterval = null;
    console.log('⏹️ Arrêt du polling de synchronisation');
  }
}

// Démarrer le polling dès que l'app est chargée
startSyncPolling();

// Optionnel : arrêter quand l'utilisateur se déconnecte volontairement ou ferme (mais pas critique)
// window.addEventListener('beforeunload', stopSyncPolling);




// Appeler cette fonction à la fin de processUpdates(), et dans SyncMonitor.evaluate()

// ===============================================
// SYSTÈME DE SYNC INDICATOR AMÉLIORÉ
// ===============================================

// ✅ AJOUTER cette variable globale en haut avec syncAlertShown
let wasDesynchronized = false; // Nouvelle variable pour mémoriser l'état de désync
let syncAlertShown = false;

let tokenExpiredAlertShown = false; // ✅ Uniquement en mémoire = reset à chaque rechargement

function hasSeenSyncAlerts() {
  if (!currentUser || !currentUser.pseudo) {
    return localStorage.getItem('sync_alerts_seen') === 'true';
  }
  return localStorage.getItem(`sync_alerts_seen_${currentUser.pseudo}`) === 'true';
}

function markSyncAlertsAsSeen() {
  if (!currentUser || !currentUser.pseudo) {
    localStorage.setItem('sync_alerts_seen', 'true');
  } else {
    localStorage.setItem(`sync_alerts_seen_${currentUser.pseudo}`, 'true');
  }
}

function showSyncAlert(type = 'warning') {
  if (hasSeenSyncAlerts()) {
    console.log('🔕 Alertes sync désactivées (utilisateur déjà informé)');
    return;
  }

  if (type === 'warning' && syncAlertShown) return;
  
  let existingCard = document.getElementById('syncAlertCard');
  if (existingCard) {
    existingCard.remove();
  }

  const card = document.createElement('div');
  card.id = 'syncAlertCard';
  card.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 24px;
    padding: 35px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 1000000;
    max-width: 260px;
    width: 90%;
    text-align: center;
    animation: slideIn 0.3s ease-out;
  `;

  const overlay = document.createElement('div');
  overlay.id = 'syncAlertOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999999;
    animation: fadeIn 0.3s ease-out;
  `;

  if (type === 'warning') {
    card.innerHTML = `
      <div style="font-size: 100px; margin-bottom: 20px;">⌔</div>
      <h2 style="color: #333; margin: 0 0 15px 0; font-size: 22px; font-weight: 600;" data-i18n="sync_alert_title">Perte de signal détectée</h2>
      <p style="color: #666; margin: 0 0 25px 0; line-height: 1.6; font-size: 15px;" data-i18n="sync_alert_message">
        Vous pouvez continuer à jouer, votre progression est mémorisée et sera synchronisée dès le retour de la connexion.
      </p>
      <button id="closeSyncAlert" style="
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        border: none;
        padding: 14px 32px;
        border-radius: 30px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(76, 175, 80, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(76, 175, 80, 0.3)'" data-i18n="sync_alert_button">
        J'ai compris
      </button>
    `;
    syncAlertShown = true;
  } else if (type === 'success') {
    card.innerHTML = `
      <h2 style="color: #4CAF50; margin: 0 0 15px 0; font-size: 22px; font-weight: 600;" data-i18n="sync_success_title">Synchronisation réussie !</h2>
      <p style="color: #666; margin: 0 0 25px 0; line-height: 1.6; font-size: 15px;" data-i18n="sync_success_message">
        Toutes vos données ont été sauvegardées avec succès.
      </p>
      <button id="closeSyncAlert" style="
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        border: none;
        padding: 14px 32px;
        border-radius: 30px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(76, 175, 80, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(76, 175, 80, 0.3)'" data-i18n="sync_success_button">
        OK
      </button>
    `;
  }

  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideIn {
      from { opacity: 0; transform: translate(-50%, -60%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
  `;
  document.head.appendChild(style);

  // ✅ D'ABORD ajouter au DOM
  document.body.appendChild(overlay);
  document.body.appendChild(card);

  // ✅ PUIS appliquer les traductions (après que les éléments soient dans le DOM)
  setTimeout(() => {
    console.log('🌍 Application des traductions sync alert...');
    
    // Traduire manuellement les éléments de la carte
    card.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      const translation = t(key);
      console.log(`📝 Traduction ${key} →`, translation);
      element.textContent = translation;
    });
    
    console.log('✅ Traductions appliquées');
  }, 10);

  // ✅ Ajouter l'événement après tout
  document.getElementById('closeSyncAlert').addEventListener('click', closeSyncAlert);
}

function showTokenExpiredFlashcard() {
  // Éviter les alertes multiples
  if (tokenExpiredAlertShown) return;
  tokenExpiredAlertShown = true;
  
  // Supprimer toute alerte existante
  const existingCard = document.getElementById('tokenExpiredCard');
  const existingOverlay = document.getElementById('tokenExpiredOverlay');
  if (existingCard) existingCard.remove();
  if (existingOverlay) existingOverlay.remove();
  
  const overlay = document.createElement('div');
  overlay.id = 'tokenExpiredOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 9999999;
    backdrop-filter: blur(5px);
    animation: fadeIn 0.3s ease-out;
  `;
  
  const card = document.createElement('div');
  card.id = 'tokenExpiredCard';
  card.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 24px;
    padding: 35px;
    box-shadow: 0 15px 50px rgba(0,0,0,0.4);
    z-index: 10000000;
    max-width: 300px;
    width: 80%;
    text-align: center;
    animation: slideIn 0.3s ease-out;

@keyframes shake {
  0%, 100% { transform: translate(-50%, -50%); }
  10%, 30%, 50%, 70%, 90% { transform: translate(-52%, -50%); }
  20%, 40%, 60%, 80% { transform: translate(-48%, -50%); }
}
  `;
  
  card.innerHTML = `
    <div style="font-size: 80px; margin-bottom: 20px;">⚠️</div>
    <h2 style="color: #d32f2f; margin: 0 0 15px 0; font-size: 22px; font-weight: 600;" data-i18n="token_expired_title">
      Session expirée
    </h2>
    <p style="color: #666; margin: 0 0 25px 0; line-height: 1.6; font-size: 15px;" data-i18n="token_expired_message">
      Votre compte a été ouvert sur un autre appareil. Veuillez recharger la page pour continuer.
    </p>
    <button id="reloadPageBtn" style="
      background: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: 30px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 12px rgba(211, 47, 47, 0.3);
      width: 100%;
    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(211, 47, 47, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(211, 47, 47, 0.3)'" data-i18n="token_expired_button">
      Recharger la page
    </button>
  `;
  
  document.body.appendChild(overlay);
  document.body.appendChild(card);
  
  // Appliquer les traductions
  setTimeout(() => {
    card.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      element.textContent = t(key);
    });
  }, 10);
  
  // Action du bouton
  document.getElementById('reloadPageBtn').addEventListener('click', () => {
    window.location.reload();
  });
  
  // Empêcher la fermeture en cliquant sur l'overlay
  overlay.addEventListener('click', (e) => {
    e.stopPropagation();
    // Optionnel : faire vibrer la carte pour montrer qu'on doit cliquer sur le bouton
    card.style.animation = 'shake 0.5s';
    setTimeout(() => {
      card.style.animation = 'slideIn 0.3s ease-out';
    }, 500);
  });
}

function closeSyncAlert() {
  const card = document.getElementById('syncAlertCard');
  const overlay = document.getElementById('syncAlertOverlay');
  
  if (card) {
    const isSuccessAlert = card.querySelector('[data-i18n="sync_success_title"]');
    
    card.style.animation = 'fadeOut 0.3s ease-out';
    
    // ✅ CORRECTION : Vérifier que overlay existe avant de l'animer
    if (overlay) {
      overlay.style.animation = 'fadeOut 0.3s ease-out';
    }
    
    setTimeout(() => {
      card.remove();
      // ✅ CORRECTION : Vérifier avant de supprimer
      if (overlay) {
        overlay.remove();
      }
      
      if (isSuccessAlert) {
        markSyncAlertsAsSeen();
        console.log('✅ Alertes sync marquées comme vues pour cet utilisateur');
      }
    }, 300);
  }
}


function updateSyncIndicator() {
  let indicator = document.getElementById('syncIndicator');

  // ✅ NOUVELLE LOGIQUE : Détecter la vraie désynchronisation
  const isReallyDesync = pendingUpdates.length > 2;
  
  // Si on dépasse le seuil, on mémorise qu'on était désynchronisé
  if (isReallyDesync) {
    wasDesynchronized = true;
  }
  
  // Si on revient à 0, on réinitialise
  if (pendingUpdates.length === 0) {
    wasDesynchronized = false;
  }

  // Si plus de 2 updates et alerte pas encore montrée ET utilisateur n'a pas déjà vu
  if (isReallyDesync && !syncAlertShown && !hasSeenSyncAlerts()) {
    showSyncAlert('warning');
  }

  // Création de l'indicateur s'il n'existe pas
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'syncIndicator';
    indicator.style.cssText = `
      position: fixed;
      bottom: 35px;
      right: 20px;
      background: rgba(255, 152, 0, 0.95);
      color: white;
      padding-right:5px;
      padding-left:5px;
      border-radius: 25px;
      font-size: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 999998;
      transition: all 0.3s ease;
      pointer-events: none;
      display: none;
      opacity: 0;
    `;
    document.body.appendChild(indicator);
  }

  // ✅ Afficher UNIQUEMENT si on est/était vraiment désynchronisé
  // ET qu'il reste encore des updates à traiter
  const shouldShowIndicator = wasDesynchronized && pendingUpdates.length > 0;
  
  if (shouldShowIndicator) {
    if (hasSeenSyncAlerts() || syncAlertShown) {
      indicator.innerHTML = ` ⌔ `;
      indicator.style.display = 'block';
      indicator.style.opacity = '1';
    }
  } else {
    // Masquer l'indicateur
    indicator.style.opacity = '0';
    setTimeout(() => {
      if (indicator.style.opacity === '0') {
        indicator.style.display = 'none';
      }
    }, 300);
  }
}


function showSyncSuccessAlert() {
  if (syncAlertShown && !hasSeenSyncAlerts()) {
    console.log('🎉 Affichage alerte de succès');
    setTimeout(() => {
      showSyncAlert('success');
      syncAlertShown = false;
    }, 300);
  } else {
    console.log('⚠️ Pas d\'alerte de succès (déjà vue ou warning non affiché)');
    syncAlertShown = false;
  }
}
  
// ===============================
// CLIENT TRUTH (source client)
// ===============================
function getClientTruthStorageKey() {
  if (currentUser && currentUser.pseudo) {
    return `client_truth_user_${currentUser.pseudo}`;
  }
  return 'client_truth_unknown';
}

let clientTruth = {
  stats_json: {},
  niveau_atteint: 1
};
const SyncMonitor = {
  syncCheckRequested: false,
  syncCheckInProgress: false, // ✅ NOUVEAU
  state: 'SYNCED',
  pendingUpdates: 0,
  failedUpdates: 0,
  lastClientSnapshotHash: null,
  lastServerSnapshotHash: null,
  serverReachable: true,

  log(reason) {
    console.log(
      `%c[SYNC MONITOR] ${this.state}`,
      'color:#0aa;font-weight:bold',
      reason || ''
    );
  },

  evaluate() {
  let newState = 'SYNCED';

  if (this.pendingUpdates > 0 || this.failedUpdates > 0) {
    newState = 'DESYNC_PENDING';
  }

  if (newState !== this.state) {
    this.state = newState;
    this.log('state transition');
  }
  updateSyncIndicator();  // ← déjà présent, juste s'assurer qu'il est là
}
};

async function initClientTruth(serverStatsJson, serverNiveauAtteint) {
  console.log('[INIT CLIENT TRUTH] start');
  const storageKey = getClientTruthStorageKey();

  let localTruth = null;
  const serverTruth = {
    stats_json: serverStatsJson || {},
    niveau_atteint: serverNiveauAtteint || 1
  };

  // 🔍 Essayer de récupérer la vérité locale
  try {
    const saved = localStorage.getItem(storageKey);
    if (saved) {
      localTruth = JSON.parse(saved);
      console.log('[INIT CLIENT TRUTH] localStorage trouvé', localTruth);
    }
  } catch (e) {
    console.warn('[INIT CLIENT TRUTH] localStorage restore failed', e);
  }

  // ✅ Variables pour le log final
  let chosenSource = 'SERVER';

  // 🎯 DÉCISION : Quelle vérité est la plus avancée ?
  if (!localTruth) {
    // Pas de données locales → utiliser serveur
    console.log('[INIT CLIENT TRUTH] ✅ Utilisation SERVEUR (pas de local)');
    clientTruth = serverTruth;
   
  } else {
    // Comparer par nombre total de tentatives
    const localTotal = Object.values(localTruth.stats_json || {})
      .reduce((sum, item) => sum + (Number(item.tentatives) || 0), 0);
     
    const serverTotal = Object.values(serverTruth.stats_json || {})
      .reduce((sum, item) => sum + (Number(item.tentatives) || 0), 0);
   
    console.log('[INIT CLIENT TRUTH] Comparaison tentatives:', {
      local: localTotal,
      server: serverTotal,
      diff: localTotal - serverTotal,
      winner: localTotal > serverTotal ? '🏆 LOCAL' : localTotal < serverTotal ? '🏆 SERVER' : '⚖️ ÉGALITÉ'
    });
   
    if (localTotal > serverTotal) {
      console.log('[INIT CLIENT TRUTH] ✅ LOCAL plus avancé → SYNC CLIENT→SERVEUR (immédiate)');
      clientTruth = localTruth;
      chosenSource = 'LOCAL';
     
      // 🔄 SYNC IMMÉDIATE ET ATTENDUE (plus de setTimeout !)
      try {
        console.log('[INIT] Sync immédiate client→serveur en cours...');
        await forceSyncClientToServer();  // ← on await ici !
        console.log('[SYNC MONITOR] SYNCED force sync completed');
      } catch (error) {
        console.error('[INIT CLIENT TRUTH] ❌ Échec de la sync forcée', error);
        // Option : tu peux choisir de fallback sur serveur ou garder local
        // Pour l'instant on garde local quand même
      }
     
    } else if (serverTotal > localTotal) {
      console.log('[INIT CLIENT TRUTH] ✅ SERVEUR plus avancé → Utilisation serveur');
      clientTruth = serverTruth;
     
    } else {
      // Égalité parfaite
      console.log('[INIT CLIENT TRUTH] ⚖️ Égalité parfaite → Utilisation serveur par défaut');
      clientTruth = serverTruth;
    }
  }

  // 💾 Sauvegarder la vérité choisie en localStorage
  try {
    localStorage.setItem(storageKey, JSON.stringify(clientTruth));
  } catch (e) {
    console.warn('[INIT CLIENT TRUTH] localStorage save failed', e);
  }
// Juste avant le dernier console.log '[INIT CLIENT TRUTH] initialized'

console.log('🔍 DEBUG 3 - clientTruth après initClientTruth:', {
  itemCount: Object.keys(clientTruth.stats_json).length,
  niveau_atteint: clientTruth.niveau_atteint,
  preview: Object.keys(clientTruth.stats_json).slice(0, 5)
});
  console.log('[INIT CLIENT TRUTH] initialized', {
    source: chosenSource,
    items: Object.keys(clientTruth.stats_json).length,
    niveau_atteint: clientTruth.niveau_atteint
  });

  // La fonction se termine → await initClientTruth() se résout ici
}
 function updateClientTruthOnAnswer(params) {
  console.log('[CLIENT TRUTH INPUT]', params);
// Au tout début de la fonction, après la ligne console.log('[CLIENT TRUTH INPUT]', params);

console.log('🔍 DEBUG 4 - clientTruth AVANT update:', {
  itemCount: Object.keys(clientTruth.stats_json).length,
  niveau_atteint: clientTruth.niveau_atteint
});
  if (!params || params.id == null) {
    console.warn('[CLIENT TRUTH] invalid params', params);
    return;
  }

  const id = params.id.toString();
  const scorePoints = parseFloat(params.scorePoints || 0);
  const isRevisionMode = params.isRevisionMode === true;

  // Initialiser l’item si nécessaire
  if (!clientTruth.stats_json[id]) {
    clientTruth.stats_json[id] = {
      tentatives: 0,
      reussites: 0,
      validation: 0
    };
  }

  const item = clientTruth.stats_json[id];

  // Mise à jour stats de base
  item.tentatives += 1;
  item.reussites += scorePoints;

  // Calcul validation (copie STRICTE de la logique serveur)
  let newValidation;

  if (isRevisionMode) {
    if (scorePoints === 1) {
      newValidation = item.validation + 1;
    } else {
      newValidation = Math.max(5, item.validation - 2);
    }
  } else {
    let validationChange =
      scorePoints === 1 ? 1 :
      scorePoints === 0.5 ? -1 : -2;

    newValidation = Math.max(0, item.validation + validationChange);
  }

  item.validation = newValidation;

  // 🔁 Recalcul du niveau atteint (copie logique serveur)
  clientTruth.niveau_atteint = calculateClientNiveauAtteint(clientTruth.stats_json);

  // Sauvegarde persistante
  try {
    localStorage.setItem(getClientTruthStorageKey(), JSON.stringify(clientTruth));
  } catch (e) {}

  console.log('[CLIENT TRUTH UPDATED]', {
    id,
    item,
    niveau_atteint: clientTruth.niveau_atteint
  });
  console.log(
  '[CLIENT TRUTH FULL SNAPSHOT]',
  Object.keys(clientTruth.stats_json).length,
  clientTruth.stats_json
);

}

  
function calculateClientNiveauAtteint(statsJson) {
  const maxLevel = getMaxLevel(HiraganaList);

  for (let niveau = 1; niveau <= maxLevel; niveau++) {
    const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === niveau);
    let itemsValides = 0;

    itemsNiveau.forEach(item => {
      const stats = statsJson[item.ID.toString()] || { validation: 0 };
      if (stats.validation >= 5) itemsValides++;
    });

    if (itemsValides < itemsNiveau.length) {
      return niveau - 1;
    }
  }

  return maxLevel;
}
function rebuildClientTruthFromHiraganaList() {
  if (!Array.isArray(HiraganaList) || HiraganaList.length === 0) {
    console.warn('[CLIENT TRUTH REBUILD] HiraganaList invalide');
    return;
  }

  const rebuiltStats = {};

  HiraganaList.forEach(item => {
    const id = item.ID.toString();

    rebuiltStats[id] = {
      tentatives: parseInt(item.Tentatives || 0),
      reussites: parseFloat(item['Réussites'] || 0),
      validation: parseInt(item.Validation || 0)
    };
  });

  clientTruth.stats_json = rebuiltStats;
  clientTruth.niveau_atteint = calculateClientNiveauAtteint(rebuiltStats);

  try {
    localStorage.setItem(
      getClientTruthStorageKey(),
      JSON.stringify(clientTruth)
    );
  } catch (e) {
    console.warn('[CLIENT TRUTH REBUILD] localStorage failed', e);
  }

  console.log(
    '[CLIENT TRUTH REBUILT]',
    Object.keys(clientTruth.stats_json).length,
    'items',
    'niveau_atteint:',
    clientTruth.niveau_atteint
  );
  SyncMonitor.lastClientSnapshotHash =
  JSON.stringify(clientTruth.stats_json).length;

SyncMonitor.log('client snapshot updated');
SyncMonitor.evaluate();

}
function rebuildHiraganaListFromClientTruth() {
  // Au tout début de la fonction

console.log('🔍 DEBUG 5 - REBUILD appelé:', {
  clientTruthCount: Object.keys(clientTruth.stats_json || {}).length,
  hiraganaListCountAvant: HiraganaList.length,
  niveau_atteint: clientTruth.niveau_atteint
});
  if (!clientTruth || !clientTruth.stats_json || !Array.isArray(HiraganaList)) {
    console.warn('[REBUILD] clientTruth ou HiraganaList invalide');
    return;
  }

  HiraganaList.forEach(item => {
    const id = item.ID.toString();
    const stats = clientTruth.stats_json[id] || {
      validation: 0,
      tentatives: 0,
      reussites: 0
    };

    item.Validation = stats.validation;
    item.Tentatives = stats.tentatives;
    item['Réussites'] = stats.reussites;

    // Mise à jour du cache de validation
    validationCache[parseInt(id)] = stats.validation;

    // Mise à jour statsCache (pourcentage par item)
    const tentatives = stats.tentatives;
    const reussites = stats.reussites;
    const pourcentage = tentatives > 0 ? Math.round((reussites / tentatives) * 100) : 0;

    statsCache.items[parseInt(id)] = {
      tentatives,
      reussites,
      pourcentage
    };
  });

  // Recalcul du pourcentage global
  const totalTentatives = Object.values(statsCache.items).reduce((sum, i) => sum + i.tentatives, 0);
  const totalReussites = Object.values(statsCache.items).reduce((sum, i) => sum + i.reussites, 0);
  statsCache.globalPourcentage = totalTentatives > 0 ? Math.round((totalReussites / totalTentatives) * 100) : 0;

  console.log('[REBUILD] HiraganaList et caches mis à jour depuis clientTruth');
}  
function normalizeStats(stats) {
  const normalized = {};

  for (const [id, item] of Object.entries(stats || {})) {
    const tentatives = Number(item.tentatives || 0);
    const reussites = Number(item.reussites || 0);
    const validation = Number(item.validation || 0);

    // ❌ on ignore les items jamais joués
    if (tentatives === 0 && reussites === 0 && validation === 0) {
      continue;
    }

    normalized[id] = {
      tentatives,
      reussites,
      validation
    };
  }

  return normalized;
}
async function hashJSON(obj) {
  const str = JSON.stringify(obj);
  const buffer = new TextEncoder().encode(str);
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}  
async function performSyncCheck(trigger = 'level-up') {
  console.log(
    `%c[SYNC CHECK] triggered (${trigger})`,
    'color:#09c;font-weight:bold'
  );

  if (!navigator.onLine) {
    console.log('[SYNC CHECK] aborted: offline');
    return;
  }

  // ✅ BYPASS : Si déclenchement auto, on ignore pendingUpdates
  const isBypassTrigger = trigger === 'auto-trigger-on-descent';
  
  if (!isBypassTrigger && SyncMonitor.pendingUpdates > 0) {
    console.log('[SYNC CHECK] aborted: pendingUpdates > 0');
    return;
  }

  if (SyncMonitor.syncCheckInProgress) {
    console.log('[SYNC CHECK] aborted: already in progress');
    return;
  }

  SyncMonitor.syncCheckInProgress = true;
  console.log('[SYNC CHECK] LOCK activé');

  try {
    const clientSnapshot = normalizeStats(clientTruth.stats_json || {});
    const clientHash = await hashJSON(clientSnapshot);

    console.log('[SYNC CHECK] Client snapshot capturé:', clientSnapshot);

    const serverStats = await callAPI('getUserStats', {
      token: userToken
    });

    if (!serverStats.success) {
      console.log('[SYNC CHECK] aborted: server error');
      return;
    }

    const serverJson = normalizeStats(serverStats.stats || {});
    const serverHash = await hashJSON(serverJson);

    SyncMonitor.lastServerSnapshotHash = serverHash;

    console.group('[SYNC CHECK] NORMALIZED INPUTS');
    console.log('CLIENT (snapshot):', clientSnapshot);
    console.log('SERVER (normalized):', serverJson);
    console.groupEnd();

    console.log(
      `[SYNC CHECK] hashes → client=${clientHash} / server=${serverHash}`
    );

    if (clientHash !== serverHash) {
      SyncMonitor.state = 'DESYNC_CONFIRMED';
      console.warn(
        '%c[SYNC CHECK] DESYNC_CONFIRMED',
        'color:#c00;font-weight:bold'
      );
      
      console.log('[SYNC CHECK] Déclenchement auto-resync...');
      
      const resyncResult = await forceSyncClientToServer();
      
      if (resyncResult.success) {
        console.log(
          '%c[SYNC CHECK] Resync automatique réussie - VIDAGE DE LA QUEUE',
          'color:#0a0;font-weight:bold'
        );
        
        // ✅ VIDER complètement la queue
        pendingUpdates = [];
        SyncMonitor.pendingUpdates = 0;
        SyncMonitor.failedUpdates = 0;
        isProcessing = false;
        
        try {
          localStorage.setItem('pending_updates', '[]');
        } catch(e) {}
        
        // ✅ Rebuild UI
        rebuildHiraganaListFromClientTruth();
        niveauActif = determineNiveauActif(HiraganaList);
        document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
        updateLevelProgress(HiraganaList, niveauActif);
        renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
        renderHiraganaCards(HiraganaList, niveauActif);
        updateMenuButtonStates();
        updateAccountDisplay();
        updateSyncIndicator();
        
      } else {
        console.error('[SYNC CHECK] Resync automatique échouée:', resyncResult.error);
        // ⚠️ En cas d'échec, on laisse la queue se vider normalement
      }
      
    } else {
      console.log('[SYNC CHECK] client/server in sync');
    }

  } catch (err) {
    console.log('[SYNC CHECK] aborted: exception', err);
  } finally {
    SyncMonitor.syncCheckInProgress = false;
    console.log('[SYNC CHECK] LOCK libéré');
  }
}
// Fonction de resynchronisation forcée
async function forceSyncClientToServer() {
  console.log(
    '%c[FORCE SYNC] Début écrasement serveur par client',
    'color:#f80;font-weight:bold'
  );

  if (!userToken) {
    console.error('[FORCE SYNC] Pas de token utilisateur');
    return { success: false, error: 'No user token' };
  }

  if (!SyncMonitor.syncCheckInProgress) {
    SyncMonitor.syncCheckInProgress = true;
    console.log('[FORCE SYNC] LOCK activé');
  }

  try {
    const cleanedStats = normalizeStats(clientTruth.stats_json);
    
    console.log('[FORCE SYNC] Envoi au serveur:', {
      itemsCount: Object.keys(cleanedStats).length,
      niveau_atteint: clientTruth.niveau_atteint,
      preview: cleanedStats
    });

    // ✅ Appel API pour écraser les stats
    const result = await callAPI('overwriteUserStats', {
      token: userToken,
      stats_json: JSON.stringify(cleanedStats)
    });

    if (result.success) {
      console.log(
        '%c[FORCE SYNC] ✅ Succès stats',
        'color:#0a0;font-weight:bold',
        result
      );

      // ✅ NOUVEAU : Synchroniser aussi le niveau
      const levelResult = await callAPI('updateUserLevel', {
        token: userToken,
        niveau_atteint: clientTruth.niveau_atteint
      });
      
      if (levelResult.success) {
        console.log(
          '%c[FORCE SYNC] ✅ Niveau synchronisé',
          'color:#0a0;font-weight:bold'
        );
      }

      const newHash = await hashJSON(cleanedStats);
      SyncMonitor.lastClientSnapshotHash = newHash;
      SyncMonitor.lastServerSnapshotHash = newHash;
      
      SyncMonitor.state = 'SYNCED';
      SyncMonitor.log('force sync completed');
      
      return { success: true, result };
      
    } else {
      console.error('[FORCE SYNC] Échec:', result.error);
      return { success: false, error: result.error };
    }

  } catch (error) {
    console.error('[FORCE SYNC] Exception:', error);
    return { success: false, error: error.message };
    
  } finally {
    SyncMonitor.syncCheckInProgress = false;
    console.log('[FORCE SYNC] LOCK libéré');
  }
}

// Fonction helper pour recharger les données depuis le serveur
async function refreshUserData() {
  try {
    console.log('[REFRESH] Rechargement données serveur...');
    
    const serverStats = await callAPI('getUserStats', { token: userToken });
    
    if (serverStats.success) {
      // Reconstruire HiraganaList avec les nouvelles stats
      rebuildClientTruthFromHiraganaList();
      
      console.log('[REFRESH] Données rechargées');
      return true;
    }
    
    return false;
    
  } catch (error) {
    console.error('[REFRESH] Erreur:', error);
    return false;
  }
}
  
//-------------------------------------------------------------------------------------------------------
// --- Fonctions API ---
async function callAPI(action, data = null) {
  try {
    const baseUrl = WEB_APP_URL;
    let url = baseUrl;
    let options = {
      method: 'GET',
      redirect: 'follow'
    };

    const params = new URLSearchParams({ action });
    if (data) {
      Object.entries(data).forEach(([key, value]) => {
        params.append(key, value);
      });
    }

    if (data && (action === 'overwriteUserStats' || action === 'updateStats' || params.toString().length > 1500)) {
      options.method = 'POST';
      options.body = params;
      options.headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
    } else {
      url += `?${params.toString()}`;
    }

    console.log(`🔍 Appel API (${options.method}): ${action}`);
    const response = await fetch(url, options);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const result = await response.json();
    
    // ✅ NOUVEAU : Détection token invalide
    if (result.error && (
      result.error.toLowerCase().includes('token non trouvé') || 
      result.error.toLowerCase().includes('token invalide') ||
      result.error.toLowerCase().includes('session expirée') ||
      result.error.toLowerCase().includes('token not found') ||
      result.error.toLowerCase().includes('invalid token')
    )) {
      console.error('🚨 [TOKEN INVALIDE] Session expirée ou ouverte ailleurs');
      showTokenExpiredFlashcard();
    }
    
    return result;

  } catch (error) {
    logError(`Erreur API (${action}): ${error.message}`);
    console.error(`⚠️ Détails erreur:`, error);
    return { error: error.message };
  }
}


async function queueUpdateStats(params) {
  
  // ✅ BLOQUER les mises à jour pendant un sync check
  if (SyncMonitor.syncCheckInProgress) {
    console.log('[QUEUE UPDATE] sync check en cours, mise en attente');
    // Attendre que le sync check soit terminé
    await new Promise(resolve => {
      const checkInterval = setInterval(() => {
        if (!SyncMonitor.syncCheckInProgress) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 50);
    });
  }
  
  SyncMonitor.pendingUpdates++;
  SyncMonitor.log('pendingUpdates++');
  SyncMonitor.evaluate();
  
  updateClientTruthOnAnswer(params);

  pendingUpdates.push(params);
  
  try {
    localStorage.setItem('pending_updates', JSON.stringify(pendingUpdates));
  } catch(e) {}
// ✅ NOUVEAU : Vérifier si on doit montrer l'alerte
  updateSyncIndicator();
  if (!isProcessing) {
    processUpdates();
  }
}


async function processUpdates() {
  if (isProcessing || pendingUpdates.length === 0) return;
  
  isProcessing = true;
  
  while (pendingUpdates.length > 0) {
    const update = pendingUpdates[0];
    
    try {
      const apiParams = {
        token: update.token,
        id: update.id,
        scorePoints: update.scorePoints,
        isRevisionMode: update.isRevisionMode
      };

      const result = await callAPI('updateStats', apiParams);

      if (result.success) {
        SyncMonitor.pendingUpdates = Math.max(0, SyncMonitor.pendingUpdates - 1);
        SyncMonitor.failedUpdates = 0;
        SyncMonitor.log('server update success');
        SyncMonitor.evaluate();

        pendingUpdates.shift();
        try {
          localStorage.setItem('pending_updates', JSON.stringify(pendingUpdates));
        } catch (e) {}

        SyncCheckTrigger.evaluate();

        SyncMonitor.lastClientSnapshotHash = await hashJSON(
          normalizeStats(clientTruth.stats_json)
        );

        // ✅ MODIFIER ICI : Gérer les animations sans dépendre de newLevel du serveur
        if (update.hasLeveledUp && update.targetLevel > update.previousLevel) {
          if (update.targetLevel > niveauActif) {
            triggerLevelUpAnimation(document.body);
          }
          if (update.targetLevel === 4 && !hasShownLevel4Menu) {
            hasShownLevel4Menu = true;
            setTimeout(() => showUnlockFlashcard(t('unlock_revision_title'), '🔓', t('unlock_revision_message')), 1);
          }
          if (update.targetLevel === 5 && !hasShownLevel5Garden) {
            hasShownLevel5Garden = true;
            setTimeout(() => showUnlockFlashcard(t('unlock_garden_title'), '🎁', t('unlock_garden_message')), 1);
          }
        }
        
      } else {
        SyncMonitor.failedUpdates++;
        SyncMonitor.log('server update failed');
        SyncMonitor.evaluate();
        console.error(`Erreur API updateStats: ${result.error}`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
    } catch (error) {
      console.error(`Erreur réseau lors de l'update: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  
  isProcessing = false;

  // ✅ AJOUTER ICI : Synchroniser le niveau avec le serveur après avoir vidé la queue
  if (userToken && clientTruth.niveau_atteint) {
    try {
      await callAPI('updateUserLevel', {
        token: userToken,
        niveau_atteint: clientTruth.niveau_atteint
      });
      console.log(`✅ Niveau synchronisé avec serveur: ${clientTruth.niveau_atteint}`);
    } catch (error) {
      console.warn('⚠️ Échec sync niveau (sera réessayé):', error);
    }
  }

  // Rebuild complet depuis clientTruth
  rebuildHiraganaListFromClientTruth();
  niveauActif = determineNiveauActif(HiraganaList);
  document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
  updateLevelProgress(HiraganaList, niveauActif);
  renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
  renderHiraganaCards(HiraganaList, niveauActif);
  updateMenuButtonStates();
  updateAccountDisplay();
  updateSyncIndicator();
  
  if (pendingUpdates.length === 0) {
    showSyncSuccessAlert();
  }
}
// ✅ NOUVELLE FONCTION : Synchroniser périodiquement le niveau avec le serveur
async function syncNiveauAtteint() {
  if (!userToken || !clientTruth || !clientTruth.niveau_atteint) {
    console.log('⏭️ Skip sync niveau (pas de token ou niveau)');
    return;
  }
  
  try {
    const result = await callAPI('updateUserLevel', {
      token: userToken,
      niveau_atteint: clientTruth.niveau_atteint
    });
    
    if (result.success) {
      console.log(`✅ Niveau synchronisé: ${clientTruth.niveau_atteint}`);
    } else {
      console.warn('⚠️ Échec sync niveau:', result.error);
    }
  } catch (error) {
    console.error('❌ Erreur sync niveau:', error);
  }
}

// ✅ Appeler la sync niveau toutes les 5 minutes
setInterval(() => {
  if (navigator.onLine) {
    syncNiveauAtteint();
  }
}, 300000); // 5 minutes

// ✅ Sync avant de quitter la page
window.addEventListener('beforeunload', () => {
  if (navigator.onLine && pendingUpdates.length === 0) {
    // Sync synchrone pour beforeunload (non bloquante)
    navigator.sendBeacon(
      WEB_APP_URL,
      new URLSearchParams({
        action: 'updateUserLevel',
        token: userToken,
        niveau_atteint: clientTruth.niveau_atteint
      })
    );
  }
});

// ============================================================================
// 🎵 SECTION 5 : SYSTÈME AUDIO
// ============================================================================
// =============================================================================
// AUDIO MANAGER OPTIMISÉ
// =============================================================================

// --- Configuration globale ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let soundEnabled = true;
let voiceEnabled = true;

// --- Initialisation ---
function initAudio() {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(err => console.error('Audio resume failed:', err));
  }
}

function loadSoundSettings() {
  const savedSound = localStorage.getItem('soundEnabled');
  const savedVoice = localStorage.getItem('voiceEnabled');
  soundEnabled = savedSound !== null ? savedSound === 'true' : true;
  voiceEnabled = savedVoice !== null ? savedVoice === 'true' : true;
}

function toggleSound(enabled) {
  soundEnabled = enabled;
  localStorage.setItem('soundEnabled', enabled);
  updateSoundUI();
}

function toggleVoice(enabled) {
  voiceEnabled = enabled;
  localStorage.setItem('voiceEnabled', enabled);
  updateSoundUI();
}

function updateSoundUI() {
  const soundSlider = document.getElementById('sound-slider');
  const voiceSlider = document.getElementById('voice-slider');
  const soundStatus = document.getElementById('sound-status');
  const voiceStatus = document.getElementById('voice-status');
  
  if (soundSlider) soundSlider.checked = soundEnabled;
  if (voiceSlider) voiceSlider.checked = voiceEnabled;
  if (soundStatus) soundStatus.textContent = soundEnabled ? '🔊' : '🔇';
  if (voiceStatus) voiceStatus.textContent = voiceEnabled ? '🔊' : '🔇';
}

// --- Fonctions utilitaires centralisées ---
function playSound(callback) {
  if (!soundEnabled) return;
  initAudio();
  try {
    callback();
  } catch (error) {
    console.error('Audio error:', error.message);
  }
}

function createOsc(type, freq, duration, gainValue = 0.05) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(gainValue, audioCtx.currentTime + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
  
  return { osc, gain };
}

function playSequence(frequencies, duration = 0.2, gainValue = 0.035, delay = 100) {
  frequencies.forEach((freq, i) => {
    setTimeout(() => createOsc('sine', freq, duration, gainValue), i * delay);
  });
}

function playNotes(notes, delays, type = 'sine', gainValue = 0.05) {
  notes.forEach((freq, i) => {
    setTimeout(() => createOsc(type, freq, delays[i] || 0.2, gainValue), i * 100);
  });
}

// --- Effets sonores simples ---
function playPopSound() {
  playSound(() => createOsc('triangle', 420, 0.15, 0.15));
 
}

function playTwinkle() {
  playSound(() => playSequence([1046.50, 1318.51, 1567.98], 0.15, 0.02, 60));
}

function playJapaneseChime() {
  playSound(() => playSequence([293.66, 329.63, 392.00, 440.00, 523.25], 0.8, 0.02, 120));
}

function playZenBell() {
  playSound(() => {
    createOsc('sine', 1240, 0.2, 0.6);
  });
}

function playSoftError() {
  playSound(() => createOsc('triangle', 220, 0.4, 0.4));
}

// --- Effets sonores complexes ---
function bambooHit() {
  playSound(() => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    osc.type = "triangle";
    osc.frequency.value = 220;
    filter.type = "bandpass";
    filter.frequency.value = 500;
    filter.Q.value = 6;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);

    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);

    osc.start();
    osc.stop(audioCtx.currentTime + 0.25);
  });
}

function bambooDrop() {
  playSound(() => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    osc.type = "sine";
    osc.frequency.value = 180;
    filter.type = "lowpass";
    filter.frequency.value = 600;
    filter.Q.value = 8;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);

    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0.06, audioCtx.currentTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);

    osc.start();
    osc.stop(audioCtx.currentTime + 0.6);
  });
}

function deepWoodHit() {
  playSound(() => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = "sine";
    osc.frequency.setValueAtTime(90, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
  });
}

// --- Sons de jeu ---

function playQuestionSound() {
  if (!soundEnabled) return;
  
  const audio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/pop.mp3');
  audio.volume = 0.5; // Ajustez le volume si besoin
  audio.play().catch(err => console.log('Erreur son:', err));
}

function playValidationSound() {
  if (!soundEnabled) return;
  
  const audio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/validation.mp3');
  audio.volume = 0.1; // Ajustez le volume si besoin
  audio.play().catch(err => console.log('Erreur son:', err));
}

function playEnterSound() {
  if (!soundEnabled) return;
  
  const audio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/enter.mp3');
  audio.volume = 0.4; // Ajustez le volume si besoin
  audio.play().catch(err => console.log('Erreur son:', err));
}

function playOkSound() {
  if (!soundEnabled) return;
  
  const audio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/ok.mp3');
  audio.volume = 1; // Ajustez le volume si besoin
  audio.play().catch(err => console.log('Erreur son:', err));
}

// Créer l'instance une seule fois au chargement
const clicAudio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/clic.mp3');
clicAudio.volume = 1;

function playClicSound() {
  if (!soundEnabled) return;
  
  // Rembobiner le son au début avant de le jouer
  clicAudio.currentTime = 0;
  clicAudio.play().catch(err => console.log('Erreur son:', err));
}
function playMenuClicSound() {
  if (!soundEnabled) return;
  
  const audio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/menuclic.mp3');
  audio.volume = 1; // Ajustez le volume si besoin
  audio.play().catch(err => console.log('Erreur son:', err));
}
  
function playMarioCoin() {
  playSound(() => playNotes([659.25, 1046.50], [0.1, 0.2]));
}

function playSuccess90s() {
  playSound(() => {
    const baseFreq = 587.33;
    const osc1 = audioCtx.createOscillator();
    const gain1 = audioCtx.createGain();
    const osc2 = audioCtx.createOscillator();
    const gain2 = audioCtx.createGain();

    osc1.connect(gain1);
    osc2.connect(gain2);
    gain1.connect(audioCtx.destination);
    gain2.connect(audioCtx.destination);

    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.frequency.value = baseFreq;
    osc2.frequency.setValueAtTime(baseFreq * 1.5, audioCtx.currentTime);
    osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3, audioCtx.currentTime + 0.3);

    gain1.gain.setValueAtTime(0.03, audioCtx.currentTime);
    gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
    gain2.gain.setValueAtTime(0.01, audioCtx.currentTime);
    gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

    osc1.start();
    osc2.start();
    osc1.stop(audioCtx.currentTime + 0.4);
    osc2.stop(audioCtx.currentTime + 0.3);
  });
}

function playFail() {
  playSound(() => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'sine';
    
    gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
    osc.frequency.setValueAtTime(220, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.4);
    
    osc.start();
    osc.stop(audioCtx.currentTime + 0.4);
  });
}

// --- Sons de feux d'artifice (refactorisés) ---
function playFireworkSound() {
  playSound(() => {
    const frequencies = [329.63, 415.30, 523.25, 659.25];
    frequencies.forEach((freq, i) => {
      setTimeout(() => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc.type = 'triangle';
        osc.frequency.value = freq;
        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;

        gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);

        osc.start();
        osc.stop(audioCtx.currentTime + 0.4);
      }, i * 150);
    });
  });
}

function playfireworksound2() {
  playSound(() => playSequence([554.37, 659.25, 830.61, 987.77], 0.2, 0.035, 100));
}

function playfireworksound3() {
  playSound(() => playSequence([659.25, 783.99, 987.77, 1174.66], 0.2, 0.035, 100));
}

function playfireworksound4() {
  playSound(() => playSequence([783.99, 987.77, 1174.66, 1396.91], 0.2, 0.035, 100));
}

function playLevelUp() {
  playSound(() => {
    const sequence = [523.25, 659.25, 783.99, 1046.50];
    const flourish = [783.99, 1046.50, 1318.51];

    sequence.forEach((freq, i) => {
      setTimeout(() => createOsc('sine', freq, 0.12, 0.04), i * 120);
    });

    flourish.forEach((freq, i) => {
      setTimeout(() => createOsc('sine', freq, 0.1, 0.04), 480 + i * 100);
    });

    setTimeout(() => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const mod = audioCtx.createOscillator();
      const modGain = audioCtx.createGain();

      mod.connect(modGain);
      modGain.connect(osc.frequency);
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'sine';
      mod.type = 'sine';
      osc.frequency.value = 1318.51;
      mod.frequency.value = 5;
      modGain.gain.value = 10;

      gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.0);

      osc.start();
      mod.start();
      osc.stop(audioCtx.currentTime + 2.0);
      mod.stop(audioCtx.currentTime + 2.0);
    }, 780);
  });
}

// --- Sons flashcard (refactorisés avec vérifications) ---
function happySoundFlashcard() {
  playSound(() => {
    function pluck(freq, duration = 0.15, gainValue = 0.15) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(gainValue, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function noisePop() {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      }
      const src = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      gain.gain.value = 0.18;
      src.buffer = buffer;
      src.connect(gain).connect(audioCtx.destination);
      src.start();
    }

    noisePop();
    [880, 1175, 1568].forEach((f, i) =>
      setTimeout(() => pluck(f, 0.16, 0.18), i * 90)
    );
  });
}

function sadSoundFlashcard() {
  playSound(() => {
    function pluck(freq, duration = 0.28, gainValue = 0.12) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(gainValue, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function noisePop() {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      }
      const src = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      gain.gain.value = 0.18;
      src.buffer = buffer;
      src.connect(gain).connect(audioCtx.destination);
      src.start();
    }

    noisePop();
    [740, 587, 440].forEach((f, i) =>
      setTimeout(() => pluck(f, 0.28, 0.12), i * 120)
    );
  });
}

// === SONS DE BOUTONS ===
// Son général pour les boutons de menu
const buttonClickAudio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/menuclic.mp3');
buttonClickAudio.volume = 0.7;

// Son spécifique pour les boutons de réponse du quiz
const quizAnswerAudio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/learnclic.mp3');
quizAnswerAudio.volume = 0.4; // Ajuste selon tes préférences

// Fonction pour jouer le son général
function playButtonClick() {
  if (!soundEnabled) return;
  buttonClickAudio.currentTime = 0;
  buttonClickAudio.play().catch(err => console.log('Erreur son bouton:', err));
}

// Fonction pour jouer le son de réponse quiz
function playQuizAnswerClick() {
  if (!soundEnabled) return;
  quizAnswerAudio.currentTime = 0;
  quizAnswerAudio.play().catch(err => console.log('Erreur son réponse:', err));
}

// --- Initialisation au chargement ---
loadSoundSettings();
updateSoundUI();


// ============================================================================
// 📈 SECTION 6 : PROGRESSION & NIVEAUX
// ============================================================================

// --- Constantes ---
const SEUIL_VALIDATION = 5;  // Seuil fixe pour validation complète (étoiles pleines, feu d'artifice, etc.)

// --- Variables progression ---
let hasShownBlockedMenu = false;
let hasShownUnblockedMenu = false;
let hasShownLevel4Menu = false;
let hasShownLevel5Garden = false;

// --- Helpers communs ---
const getItemsByLevel = (list, level) => 
  (list || []).filter(h => parseInt(h.Niveau, 10) === level);

const getValidatedCount = (items) => 
  items.filter(h => parseInt(h.Validation || 0, 10) >= SEUIL_VALIDATION).length;

// --- Fonctions progression ---
function determineNiveauActif(list) {
  if (!list?.length) return 1;
  
  const maxNiveau = Math.max(...list.map(k => parseInt(k.Niveau, 10) || 1));
  
  for (let n = 1; n <= maxNiveau; n++) {
    const items = getItemsByLevel(list, n);
    if (getValidatedCount(items) < items.length) {
      return n;
    }
  }
  return maxNiveau;
}

function getNiveauGroupe(niveau) {
  for (const [groupeId, groupe] of Object.entries(GROUPES)) {
    if (groupe.niveaux.includes(niveau)) {
      return parseInt(groupeId, 10);
    }
  }
  return 1;
}

function isGroupeDebloque(groupeId) {
  if (groupeId <= 2) return true;
  
  for (let g = 1; g < groupeId; g++) {
    const niveaux = GROUPES[g]?.niveaux || [];
    for (const niveau of niveaux) {
      const items = getItemsByLevel(HiraganaList, niveau);
      if (getValidatedCount(items) < items.length) {
        return false;
      }
    }
  }
  return true;
}

function isApprentissageBloque() {
  const groupeActuel = getNiveauGroupe(niveauActif);
  
  if (niveauActif <= 5) {
    return groupeActuel >= 3 && !isGroupeDebloque(groupeActuel);
  }
  
  // Niveaux > 5 : blocage basé sur déficit
  const deficit = calculerDeficitValidation();
  const wasBlocked = localStorage.getItem('apprentissageBloque') === 'true';
  
  if (wasBlocked) {
    const shouldUnblock = deficit === 0;
    if (shouldUnblock) localStorage.setItem('apprentissageBloque', 'false');
    return !shouldUnblock;
  } else {
    const shouldBlock = deficit > 2;
    if (shouldBlock) localStorage.setItem('apprentissageBloque', 'true');
    return shouldBlock;
  }
}


function calculerDeficitValidation() {
  const groupeActuel = getNiveauGroupe(niveauActif);
  if (groupeActuel < 3) return 0; // Pas de blocage avant le groupe 3
  
  let deficitTotal = 0;
  
  // Parcourir TOUS les groupes précédents (1 à groupeActuel-1)
  for (let g = 1; g < groupeActuel; g++) {
    const niveauxGroupe = GROUPES[g].niveaux;
    
    for (const niveau of niveauxGroupe) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === niveau);
      for (const item of itemsNiveau) {
        const validation = parseInt(item.Validation || 0);
        if (validation < seuilValidation) {
  deficitTotal += (seuilValidation - validation);
        }
      }
    }
  }
  
  return deficitTotal;
}
function calculerDeficitMaximum() {
  const groupeActuel = getNiveauGroupe(niveauActif);
  if (groupeActuel < 3) return 0;
  
  let totalItems = 0;
  
  // Parcourir TOUS les groupes précédents (1 à groupeActuel-1)
  for (let g = 1; g < groupeActuel; g++) {
    const niveauxGroupe = GROUPES[g].niveaux;
    
    for (const niveau of niveauxGroupe) {
      const itemsNiveau = HiraganaList.filter(h => parseInt(h.Niveau) === niveau);
      totalItems += itemsNiveau.length;
    }
  }
  
  return totalItems * (seuilValidation - 5); // Déficit max = passage de 5 au seuil
}


function getMaxLevel(list) {
  if (!list?.length) return 1;
  return Math.max(...list.map(k => parseInt(k.Niveau, 10) || 1));
}

function getItemCountForLevel(level) {
  return getItemsByLevel(HiraganaList, level).length;
}

function getValidatedCountForLevel(level) {
  return getValidatedCount(getItemsByLevel(HiraganaList, level));
}

// --- Fonctions UI progression ---
function updateLevelProgress(list, niveau) {
  renderHiraganaCards(list, niveau);
}

function renderProgressBar(currentLevel, maxLevel) {
  const container = document.getElementById("progressBarContainer");
  if (!container) return;

  container.innerHTML = `
    <span class="side-emoji">🌱</span>
    <div class="progress-bar-track">
      <div class="progress-marker">🐼</div>
    </div>
    <span class="side-emoji">🌳</span>
  `;

  const marker = container.querySelector(".progress-marker");
  const pct = maxLevel > 1 ? ((currentLevel - 1) / (maxLevel - 1)) * 100 : 0;
  marker.style.left = `${Math.min(100, Math.max(0, pct))}%`;

  safeConvertEmojis(container);
}

function renderHiraganaCards(list, niveau) {
  const container = document.getElementById("hiraganaCards");
  if (!container) return;

  const items = getItemsByLevel(list, niveau);
  container.innerHTML = "";

  items.forEach(item => {
    const validation = parseInt(item.Validation || 0, 10);
    const card = document.createElement("div");
    card.className = `hiragana-card ${validation >= SEUIL_VALIDATION ? 'completed' : ''}`;
    card.innerHTML = `
      <div class="hiragana-char">${item.Hiragana}</div>
      <div class="stars-container">
        ${Array.from({length: 5}, (_, i) => 
          `<div class="star ${i < validation ? 'filled' : ''}"></div>`
        ).join('')}
      </div>
    `;
    container.appendChild(card);
    previousValidationStates.set(parseInt(item.ID, 10), validation);
  });
}

function updateStarsForHiragana(hiraganaId, newValidation) {
  const cards = document.querySelectorAll('.hiragana-card');
  const previousValidation = previousValidationStates.get(hiraganaId) || 0;

  cards.forEach(card => {
    const char = card.querySelector('.hiragana-char')?.textContent;
    const item = HiraganaList.find(h => h.Hiragana === char && parseInt(h.ID, 10) === hiraganaId);
    if (!item) return;

    const stars = card.querySelectorAll('.star');
    stars.forEach((star, i) => {
      if (i < newValidation) {
        star.classList.add('filled');
        if (i >= previousValidation) star.classList.add('new-star');
        setTimeout(() => star.classList.remove('new-star'), 500);
      } else {
        star.classList.remove('filled', 'new-star');
      }
    });

    card.classList.toggle('completed', newValidation >= SEUIL_VALIDATION);

    if (newValidation >= SEUIL_VALIDATION && previousValidation < SEUIL_VALIDATION) {
      if (isMobile) triggerLightFirework(card);
      else triggerAdvancedFirework(card);
    }
  });

  previousValidationStates.set(hiraganaId, newValidation);
}

// ============================================================================
// 🎮 SECTION 7 : MODE QUIZ (APPRENTISSAGE)
// ============================================================================

// --- Variables quiz ---
let current = {};
let selections = { first: null, second: null };
let targetFields = [];
let isAnswered = false;
let previousCharacter = null;
let wasApprentissageBloque = false;

// --- Fonctions quiz ---
function nextQuestion() {
  document.getElementById("result").innerText = "";
  document.getElementById("continueBtn").style.visibility = "hidden";
  selections = { first: null, second: null };
  isAnswered = false;

  // Items non maîtrisés du niveau actif
  let kanas = HiraganaList.filter(k => 
    parseInt(k.Niveau, 10) === niveauActif && 
    parseInt(k.Validation || 0, 10) < SEUIL_VALIDATION
  );

  // Si tout est maîtrisé → passage éventuel au niveau suivant
  if (kanas.length === 0) {
    const nouveauNiveau = determineNiveauActif(HiraganaList);
    if (nouveauNiveau !== niveauActif) {
      niveauActif = nouveauNiveau;
      localStorage.setItem('unlockedLevel', niveauActif);
      document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
      renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
      updateLevelProgress(HiraganaList, niveauActif);
      updateRevisionButtonState();
      updateApprendreButtonState();
      triggerLevelUpAnimation(document.body); // Level up détecté
    }
    // On retombe sur les items du niveau (même s’ils sont maîtrisés) pour ne pas bloquer
    kanas = HiraganaList.filter(k => parseInt(k.Niveau, 10) === niveauActif);
  }

  // Pondération : plus la validation est basse, plus l'item a de chances d'être tiré
  const weights = kanas.map(k => Math.max(0.1, 5 - parseInt(k.Validation || 0, 10) + 0.5));
  const sum = weights.reduce((a, b) => a + b, 0);
  
  let selected;
  do {
    let rand = Math.random() * sum;
    let acc = 0;
    for (let i = 0; i < kanas.length; i++) {
      acc += weights[i];
      if (rand < acc) {
        selected = kanas[i];
        break;
      }
    }
  } while (selected === previousCharacter && kanas.length > 1);

  current = selected;
  previousCharacter = current;

  // Choix aléatoire du mode de question
  const modes = [
    { question: "Hiragana", options1: "Katakana", options2: "Romaji" },
    { question: "Katakana", options1: "Hiragana", options2: "Romaji" },
    { question: "Romaji",   options1: "Hiragana", options2: "Katakana" }
  ];
  const mode = modes[Math.floor(Math.random() * modes.length)];
  targetFields = [mode.options1, mode.options2];

  document.getElementById("question").innerText = 
    mode.question === 'Katakana' ? getLocalizedKatakana(current) : current[mode.question];

  renderChoices("choices1", generateChoices(mode.options1), "first");
  renderChoices("choices2", generateChoices(mode.options2), "second");
}

function generateChoices(field) {
  const getValue = (item) => field === 'Katakana' ? getLocalizedKatakana(item) : item[field];
  
  const others = HiraganaList.filter(k => k !== current && parseInt(k.Niveau, 10) === niveauActif);
  const values = [
    getValue(current),
    ...others.sort(() => 0.5 - Math.random()).slice(0, 3).map(getValue)
  ];
  return values.sort(() => 0.5 - Math.random());
}

function renderChoices(id, options, slot) {
  const container = document.getElementById(id);
  if (!container) return;
  
  container.innerHTML = "";
  options.forEach(text => {
    const btn = document.createElement("button");
    btn.innerText = text;
    btn.className = "arcade-button";
    btn.onclick = () => {
      if (selections[slot] || isAnswered) return;
      
      selections[slot] = text;
      btn.classList.add("clicked-glow", "clicked");
      container.querySelectorAll("button").forEach(b => b.disabled = true);
      checkAnswer();
    };
    container.appendChild(btn);
  });
}

async function checkAnswer() {
  if (!selections.first || !selections.second || isAnswered) return;
  isAnswered = true;

  const getValue = (field) => field === 'Katakana' ? getLocalizedKatakana(current) : current[field];
  const correct = [getValue(targetFields[0]), getValue(targetFields[1])];
  const user = [selections.first, selections.second];

  let score = 0;
  ["choices1", "choices2"].forEach((id, idx) => {
    const container = document.getElementById(id);
    if (!container) return;
    
    container.querySelectorAll("button").forEach(btn => {
      btn.classList.remove("clicked-glow", "correct", "incorrect");
      const text = btn.innerText;
      
      if (text === correct[idx]) {
        btn.classList.add("correct");
        if (text === user[idx]) score += 0.5;
      } else if (text === user[idx]) {
        btn.classList.add("incorrect");
      }
      btn.disabled = true;
    });
  });

  // Calcul nouvelle validation
  const oldValidation = parseInt(current.Validation || 0, 10);
  let newValidation = oldValidation;
  if (score === 1) newValidation = Math.min(SEUIL_VALIDATION, oldValidation + 1);
  else if (score === 0.5) newValidation = Math.max(0, oldValidation - 1);
  else newValidation = Math.max(0, oldValidation - 2);

  const itemId = parseInt(current.ID, 10);
  const isFinalValidation = score === 1 && oldValidation < SEUIL_VALIDATION && newValidation >= SEUIL_VALIDATION;

  // Mise à jour locale
  updateStarsForHiragana(itemId, newValidation);
  const index = HiraganaList.findIndex(h => parseInt(h.ID, 10) === itemId);
  if (index !== -1) {
    HiraganaList[index].Validation = newValidation.toString();
    HiraganaList[index].Tentatives = (parseInt(HiraganaList[index].Tentatives || 0, 10) + 1);
    HiraganaList[index].Réussites = (parseInt(HiraganaList[index].Réussites || 0, 10) + score);
    validationCache[itemId] = newValidation;
  }

  // Feedback succès / échec
  if (score === 1) {
    const emojisOK = ["🦋","🐸","🌵","🌴","🍏","🍀","🌳","🌱","👻","😸","😽","🌈","🐻","🐌","🌞","✅","🧠","🐶","🐵"];
    const emoji = emojisOK[Math.floor(Math.random() * emojisOK.length)];
    const text = isFinalValidation ? t('msg_validated') : t('msg_perfect');
    
    if (!isFinalValidation) playTwinkle();
    
    const questionDiv = document.getElementById("question");
    const resultDiv = document.getElementById("result");
    const container = document.querySelector('.quiz-container');
    
    const questionRect = questionDiv.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    resultDiv.style.position = "absolute";
    resultDiv.style.top = (questionRect.top - containerRect.top) + "px";
    resultDiv.style.left = "0"; resultDiv.style.right = "0";
    resultDiv.style.height = questionRect.height + "px";
    resultDiv.style.zIndex = "10";
    questionDiv.style.visibility = "hidden";

    setTimeout(() => {
      resultDiv.className = 'anim-combo';
      resultDiv.innerHTML = `<div class="result-line">
        <div class="result-text">${text}</div>
        <div class="result-emoji">${emoji}</div>
      </div>`;
      safeConvertEmojis(resultDiv);
      setTimeout(createSparkles, 100);
    }, 10);

    setTimeout(() => {
      questionDiv.style.visibility = "visible";
      resultDiv.style.opacity = "0";
      setTimeout(() => { resultDiv.innerHTML = ""; resultDiv.style = ""; }, 500);
    }, 1800);
  } else {
    playSoftError();
  }

  // Son hiragana
  if (current.Hiragana && voiceEnabled) {
    const audio = new Audio(`https://emmanuel971-source.github.io/hirakataquizz/${encodeURIComponent(current.Hiragana)}.mp3`);
    audio.play().catch(() => {});
  }

  // Mise à jour niveau et UI
  const previousNiveau = niveauActif;
  niveauActif = determineNiveauActif(HiraganaList);
  document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
  updateLevelProgress(HiraganaList, niveauActif);
  renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
  renderHiraganaCards(HiraganaList, niveauActif);
  updateMenuButtonStates();

  if (niveauActif > previousNiveau) {
    SyncMonitor.syncCheckRequested = true;
    console.log('[SYNC CHECK] requested (level-up)');
    triggerLevelUpAnimation(document.body);
    syncNiveauAtteint(); 
  }

  // Envoi stats
  queueUpdateStats({
    token: userToken,
    id: itemId,
    scorePoints: score,
    isRevisionMode: revisionMode.isActive,
    previousLevel: previousNiveau,
    hasLeveledUp: niveauActif > previousNiveau,
    targetLevel: niveauActif
  });

  // Rafraîchissement stats page si ouverte
  if (document.getElementById('stats')?.classList.contains('active')) {
    setTimeout(generateStatsPage, 100);
  }

  // Suite
  if (!revisionMode.isActive) {
    if (score === 1) {
      setTimeout(nextQuestion, niveauActif > previousNiveau ? 4000 : 1500);
    } else {
      document.getElementById("continueBtn").style.visibility = "visible";
    }
  } else {
    document.getElementById("continueBtn").style.visibility = "visible";
  }
}

function resetGameContext() {
  current = {};
  selections = { first: null, second: null };
  isAnswered = false;
  previousCharacter = null;

  ["choices1", "choices2"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = "";
  });

  const result = document.getElementById("result");
  if (result) result.innerText = "";

  const continueBtn = document.getElementById("continueBtn");
  if (continueBtn) continueBtn.style.visibility = "hidden";
}
// ============================================================================
// 🔄 SECTION 8 : MODE RÉVISION
// ============================================================================

// --- Variables révision ---
let revisionMode = {
  currentQuestion: "",
  input: "",
  romajiSegments: [],
  charCounts: [],
  fullCorrect: "",
  cumulativeRomaji: [],
  cumulativeChars: [],
  isActive: false,
  currentItem: null
};

let wasBlockedWhenEnteringRevision = false;
let deficitInitialRevision = 0;
let pointsGagnesEnRevision = 0;
let hasUnlockedInRevision = false;

// --- Fonctions révision ---
function startRevisionQuestion() {


  const niveauActif = determineNiveauActif(HiraganaList);
  const excludedKatakanaLevels = [3, 5, 7, 10, 11, 12, 14, 16, 17, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39];
  const hiraganaItems = HiraganaList.filter(h => 
    parseInt(h.Niveau || 1) < niveauActif && 
    revisionRomajiTable[h.Hiragana] &&
    h.Hiragana && h.Romaji
  );
  const katakanaItems = HiraganaList.filter(h => 
    parseInt(h.Niveau || 1) < niveauActif && 
    !excludedKatakanaLevels.includes(parseInt(h.Niveau || 1)) && 
    revisionKatakanaTable[h.Katakana] &&
    h.Katakana && h.Romaji
  );
  const availableItems = [
    ...hiraganaItems.map(item => ({ ...item, type: 'hiragana', key: item.Hiragana })), 
    ...katakanaItems.map(item => ({ ...item, type: 'katakana', key: getLocalizedKatakana(item) }))
  ];

  console.log(`🎯 Items disponibles pour révision: Hiragana=${hiraganaItems.length}, Katakana=${katakanaItems.length}`);



  // Tampon des 3 derniers tirages - convertir en numbers
  const recentItems = JSON.parse(localStorage.getItem('recentRevisionItems') || '[]').map(id => parseInt(id));

  let selectedItem;
  const apprendreBloque = isApprentissageBloque();
  if (!apprendreBloque) {
    // 🎲 TIRAGE ALÉATOIRE PUR (20%) - Filtré seulement par le tampon
    const randomItems = availableItems.filter(item => !recentItems.includes(parseInt(item.ID)));
    const finalRandomItems = randomItems.length >= 4 ? randomItems : availableItems;
    
    selectedItem = finalRandomItems[Math.floor(Math.random() * finalRandomItems.length)];
    
    console.log(`🎲 TIRAGE ALÉATOIRE (20%)`);
    console.log(`📋 Items disponibles pour tirage aléatoire: ${finalRandomItems.length}/${availableItems.length}`);
    console.log(`🔍 Items filtrés par tampon:`, finalRandomItems.map(item => `${item.key}(ID:${item.ID})`).join(', '));
    
  } else {
    // ⚖️ TIRAGE PONDÉRÉ (80%) - Filtré par Validation ≤ 10 + tampon
    const validationFilteredItems = availableItems.filter(item => (validationCache[parseInt(item.ID)] || 0) < seuilValidation);
    const weightedItems = validationFilteredItems.filter(item => !recentItems.includes(parseInt(item.ID)));
    
    let finalWeightedItems;
    
    if (weightedItems.length >= 4) {
      // Cas idéal : assez d'items respectant validation ≤ 10 ET hors tampon
      finalWeightedItems = weightedItems;
    } else if (weightedItems.length > 0) {
      // Peu d'items mais au moins quelques-uns : on les garde
      finalWeightedItems = weightedItems;
    } else {
      // Aucun item respectant les deux contraintes
      // PRIORITÉ : éviter le tampon (libérer contrainte validation ≤ 10)
      const itemsHorsTampon = availableItems.filter(item => !recentItems.includes(parseInt(item.ID)));
      if (itemsHorsTampon.length > 0) {
        finalWeightedItems = itemsHorsTampon;
        console.log(`⚠️ FALLBACK 1 - Libération contrainte Validation ≤ 10 pour éviter tampon`);
      } else {
        // Dernier recours : prendre tous les items (même dans le tampon)
        finalWeightedItems = availableItems;
        console.log(`⚠️ FALLBACK 2 - Tous les items utilisés (tampon ignoré)`);
      }
    }

    // Tirage pondéré sur les items finaux
    const weights = finalWeightedItems.map(item => {
      const stats = statsCache.items[parseInt(item.ID)] || { pourcentage: 0 };
      const pourcentage = stats.pourcentage;
      return pourcentage === 0 ? 50 : Math.min(50, Math.pow(100 / (pourcentage + 10), 2));
    });
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;
    for (let i = 0; i < finalWeightedItems.length; i++) {
      random -= weights[i];
      if (random <= 0) {
        selectedItem = finalWeightedItems[i];
        break;
      }
    }
    
    console.log(`⚖️ TIRAGE PONDÉRÉ (80%)`);
    console.log(`📋 Items disponibles (Validation ≤ 10 + tampon): ${finalWeightedItems.length}/${availableItems.length}`);
    console.log(`🔍 Items respectant Validation ≤ 10:`, 
      validationFilteredItems.map(item => `${item.key}(ID:${item.ID},Val:${validationCache[parseInt(item.ID)] || 0})`)
        .join(', '));
    console.log(`🚫 Items exclus par tampon:`, recentItems.join(', '));
    console.log(`✅ Items finaux pour pondération:`, 
      finalWeightedItems.map(item => `${item.key}(ID:${item.ID},Val:${validationCache[parseInt(item.ID)] || 0},${(statsCache.items[parseInt(item.ID)]?.pourcentage || 0).toFixed(1)}%)`)
        .join(', '));
  }

  // Mettre à jour le tampon - s'assurer que c'est un number
  recentItems.push(parseInt(selectedItem.ID));
  if (recentItems.length > 3) recentItems.shift(); // Garder seulement les 3 derniers
  localStorage.setItem('recentRevisionItems', JSON.stringify(recentItems));

  // Log pour vérification
  console.log(`🎯 Question sélectionnée: "${selectedItem.key}" (ID: ${selectedItem.ID}, Type: ${selectedItem.type})`);
  console.log(`🔍 Tampon récent:`, recentItems);

  // Configurer la question
  revisionMode.currentQuestion = selectedItem.key;
  const table = selectedItem.type === 'hiragana' ? revisionRomajiTable : revisionKatakanaTable;
  const tableEntry = table[selectedItem.key];
  revisionMode.romajiSegments = tableEntry.romaji;
  revisionMode.charCounts = tableEntry.charCounts;
  revisionMode.fullCorrect = revisionMode.romajiSegments.join("");
  revisionMode.currentItem = selectedItem;

  let cumRom = 0;
  revisionMode.cumulativeRomaji = revisionMode.romajiSegments.map(segment => {
    cumRom += segment.length;
    return cumRom;
  });
  let cumChar = 0;
  revisionMode.cumulativeChars = revisionMode.charCounts.map(count => {
    cumChar += count;
    return cumChar;
  });

  revisionMode.input = "";
  document.getElementById("revision-question").innerHTML = 
    revisionMode.currentQuestion.split("").map((char, index) => 
      `<div class="char-card" id="revision-card-${index}">
        <span id="revision-char-${index}">${char}</span>
      </div>`
    ).join("");
  document.getElementById("revision-input-display").textContent = "";
 

  // 💬 Affiche l’infobulle du déficit/avance de Validation sur la première carte
const firstCard = document.getElementById(`revision-card-0`);
if (firstCard && revisionMode.currentItem) {
  const currentValidation = parseInt(revisionMode.currentItem.Validation || validationCache[revisionMode.currentItem.ID] || 0);
  showValidationBubble(firstCard, currentValidation, seuilValidation);
}


  

  if (firstCard) firstCard.classList.add("pulsing");

  console.log(`📝 Question: "${revisionMode.currentQuestion}" (${selectedItem.Romaji}) -> Attendu: "${revisionMode.fullCorrect}"`);
  console.log(`📊 Pourcentage item (ID ${selectedItem.ID}): ${(statsCache.items[parseInt(selectedItem.ID)]?.pourcentage || 0).toFixed(2)}% | Pourcentage global: ${statsCache.globalPourcentage.toFixed(2)}%`);
// ✅ FORCER l'affichage de la barre à chaque nouvelle question
setTimeout(() => {
  updateUnlockProgress();
}, 200);
} 
function updateRevisionFeedback() {
  // Reset toutes les classes
  for (let i = 0; i < revisionMode.currentQuestion.length; i++) {
    const cardElement = document.getElementById(`revision-card-${i}`);
    const charElement = document.getElementById(`revision-char-${i}`);
    if (cardElement) {
      cardElement.classList.remove(
        "char-correct-1", "char-correct-2", "char-correct-3", "char-correct-4",
        "char-incorrect-1", "char-incorrect-2", "char-incorrect-3", "char-incorrect-4",
        "pulsing", "pop-animation"
      );
    }
    if (charElement) {
      charElement.classList.remove("pulsing");
    }
  }

  let currentSegment = -1;
  const inputLength = revisionMode.input.length;

  // Parcourir chaque segment
  for (let seg = 0; seg < revisionMode.romajiSegments.length; seg++) {
    const romStart = seg > 0 ? revisionMode.cumulativeRomaji[seg - 1] : 0;
    const romEnd = revisionMode.cumulativeRomaji[seg];
    const charStart = seg > 0 ? revisionMode.cumulativeChars[seg - 1] : 0;
    const charEnd = revisionMode.cumulativeChars[seg];
    const segmentLength = romEnd - romStart;
    const typedLen = Math.max(0, Math.min(inputLength - romStart, segmentLength));
    const typedSegment = revisionMode.input.substring(romStart, romStart + typedLen);
    const expected = revisionMode.romajiSegments[seg];
    let className = "";

    console.log(`Segment ${seg}: romStart=${romStart}, romEnd=${romEnd}, typedLen=${typedLen}, typedSegment="${typedSegment}", expected="${expected}"`);

    // Gradation basée sur la progression dans le segment
    if (typedLen > 0) {
      if (expected.startsWith(typedSegment)) {
        const level = Math.min(4, typedLen);
        className = `char-correct-${level}`;
      } else {
        const level = Math.min(4, typedLen);
        className = `char-incorrect-${level}`;
      }
    }

    // Appliquer la gradation aux cartes du segment
    for (let c = charStart; c < charEnd; c++) {
      const card = document.getElementById(`revision-card-${c}`);
      const span = document.getElementById(`revision-char-${c}`);
      if (card) {
        card.className = `char-card ${className || ""}`; // Appliquer la gradation
        // Ajouter animation "pop" et son si on valide un nouveau caractère
        if (inputLength > romStart && c === charStart && !card.classList.contains("pop-animation")) {
          card.classList.add("pop-animation");
          playClicSound();
          setTimeout(() => card.classList.remove("pop-animation"), 300);
        }
      }
    }

    // Validation finale uniquement pour le segment courant si entièrement saisi
    if (inputLength >= romEnd) {
      const fullSegment = revisionMode.input.substring(romStart, romEnd);
      if (fullSegment === expected) {
        for (let c = charStart; c < charEnd; c++) {
          const card = document.getElementById(`revision-card-${c}`);
          if (card) {
            card.classList.remove("pulsing");
            card.className = `char-card char-correct-4`;
          }
        }
      } else if (romStart < inputLength) { // Saisie incorrecte partielle
        for (let c = charStart; c < charEnd; c++) {
          const card = document.getElementById(`revision-card-${c}`);
          if (card) {
            card.classList.remove("pulsing");
            card.className = `char-card char-incorrect-4`;
          }
        }
      }
    }

    // Déterminer le segment en cours pour la pulsation
    if (romStart <= inputLength && inputLength < romEnd) {
      currentSegment = seg;
    }
  }

  // Ajouter la pulsation à la carte en cours
  if (currentSegment >= 0) {
    const charStart = currentSegment > 0 ? revisionMode.cumulativeChars[currentSegment - 1] : 0;
    const charEnd = revisionMode.cumulativeChars[currentSegment];
    for (let c = charStart; c < charEnd; c++) {
      const cardElement = document.getElementById(`revision-card-${c}`);
      if (cardElement) {
        cardElement.classList.add("pulsing");
      }
    }
  }

}
  
function initRevisionKeyboard() {
  const revisionKeys = document.querySelectorAll('.revision-key');
  revisionKeys.forEach(key => key.replaceWith(key.cloneNode(true)));
  const newRevisionKeys = document.querySelectorAll('.revision-key');

  newRevisionKeys.forEach(key => {
    key.addEventListener("click", async () => {
      if (!revisionMode.isActive) return;

      // Saisie ou effacement
      if (key.id === "revision-back") {
        revisionMode.input = revisionMode.input.slice(0, -1);
      } else {
        revisionMode.input += key.textContent;
      }

      document.getElementById("revision-input-display").textContent = revisionMode.input;
      updateRevisionFeedback();

      const totalLength = revisionMode.cumulativeRomaji[revisionMode.cumulativeRomaji.length - 1] || 1;

      // Réponse complète → on valide
      if (revisionMode.input.length >= totalLength) {
        const isCorrect = revisionMode.input === revisionMode.fullCorrect;
        const itemId = parseInt(revisionMode.currentItem.ID);

        // === Stats (inchangé) ===
        statsCache.items[itemId] = statsCache.items[itemId] || { tentatives: 0, reussites: 0, pourcentage: 0 };
        statsCache.items[itemId].tentatives += 1;
        statsCache.items[itemId].reussites += isCorrect ? 1 : 0;
        statsCache.items[itemId].pourcentage = statsCache.items[itemId].tentatives > 0
          ? (statsCache.items[itemId].reussites / statsCache.items[itemId].tentatives * 100)
          : 0;

        const totalTentatives = Object.values(statsCache.items).reduce((s, i) => s + i.tentatives, 0);
        const totalReussites = Object.values(statsCache.items).reduce((s, i) => s + i.reussites, 0);
        statsCache.globalPourcentage = totalTentatives > 0 ? (totalReussites / totalTentatives * 100) : 0;

        // === Validation + points (inchangé) ===
        const hiraganaIndex = HiraganaList.findIndex(h => h.ID == itemId);
        const currentValidation = parseInt(HiraganaList[hiraganaIndex].Validation || 0);
        let newValidation;
        let pointsGagnes = 0;

        if (isCorrect) {
          newValidation = currentValidation + 1;
          if (currentValidation < seuilValidation) pointsGagnes = 1;
        } else {
          newValidation = Math.max(5, currentValidation - 2);
          const oldDeficit = Math.max(0, seuilValidation - currentValidation);
          const newDeficit = Math.max(0, seuilValidation - newValidation);
          pointsGagnes = oldDeficit - newDeficit;
        }

        HiraganaList[hiraganaIndex].Validation = newValidation.toString();
        validationCache[itemId] = newValidation;

        if (wasBlockedWhenEnteringRevision) {
          pointsGagnesEnRevision += pointsGagnes;
          updateUnlockProgress();
        }

        // === Calcul pour les animations ===
        const oldEmoji = getPlantEmoji(currentValidation);
        const newEmoji = getPlantEmoji(newValidation);
        const statusChanged = oldEmoji !== newEmoji; // surtout vrai lors du passage 🌿 ↔ 🌸

        // === AFFICHAGE DE LA FLASHCARD   ===
 // === AFFICHAGE DE LA FLASHCARD PENDANT 3 SECONDES ===
openRevisionFlashcard(
  revisionMode.currentItem,   // l'item
  newEmoji,                   // emoji à jour
  isCorrect,                  // ✅ bonne ou mauvaise réponse
  currentValidation,          // ✅ ancien score (AVANT la validation)
  newValidation,              // ✅ nouveau score (APRÈS la validation)
  statusChanged,              // animation plante si changement de statut
  true                        // toujours scintillement du score
);


        // === Feedback texte + couleur ===
        const niveau = parseInt(revisionMode.currentItem.Niveau || 1);
        const isHighLevel = niveau > 38;
        const isMultiChar = revisionMode.romajiSegments.length >= 2;
        const katakanaDisplay = (!isHighLevel && isMultiChar) ? ` (${getLocalizedKatakana(revisionMode.currentItem)})` : '';

        if (isCorrect) {
         
          playValidationSound();
        } else {
        
          playSoftError();
        }

        // === Mise à jour bulle de validation sur la carte (optionnel mais joli) ===
        const currentCard = document.querySelector('.char-card.pulsing') || document.getElementById('revision-card-0');
        if (currentCard) {
          showValidationBubble(currentCard, newValidation, seuilValidation);
        }

        // === Envoi stats en arrière-plan ===
        queueUpdateStats({ token: userToken, id: itemId, scorePoints: isCorrect ? 1 : 0, isRevisionMode: true });

        // === Rafraîchissement stats si page ouverte ===
        if (document.getElementById('stats').classList.contains('active')) {
          setTimeout(generateGarden, 100);
        }

       
      }
    });
  });
}

function isRevisionModeAvailable() {
  return niveauActif >= 4;
}  
function updateUnlockProgress() {
  const container = document.getElementById('unlock-progress-container');
  const fill = document.getElementById('unlock-progress-fill');

  if (!container || !fill) return;

  const isBlockedNow = isApprentissageBloque();

  // Détecter la transition bloqué → débloqué
  if (wasApprentissageBloque && !isBlockedNow) {
    container.style.display = 'none';
    updateApprendreButtonState();

    setTimeout(() => {
      showUnlockFlashcard(
        t('unlock_learning_title'),
        '🌱',
        t('unlock_learning_message')
      );
    }, 500);
  }

  wasApprentissageBloque = isBlockedNow;

  // Affichage de la barre uniquement si bloqué ET en révision
  if (!revisionMode.isActive || !isBlockedNow) {
    container.style.display = 'none';
    return;
  }

  const deficitActuel = calculerDeficitValidation();
  const deficitMaximum = calculerDeficitMaximum();

  if (deficitMaximum <= 0) {
    container.style.display = 'none';
    return;
  }

  container.style.display = 'block';

  const pourcentage = Math.min(
    100,
    Math.max(0, (deficitActuel / deficitMaximum) * 100)
  );

  fill.style.width = `${pourcentage}%`;

  if (pourcentage < 10 && pourcentage > 0) {
    fill.classList.add('proche-deblocage');
  } else {
    fill.classList.remove('proche-deblocage');
  }
}

// ============================================================================
// 🌸 SECTION 9 : MON JARDIN (STATISTIQUES) - VERSION OPTIMISÉE
// ============================================================================

// --- Variables garden ---
let currentStatsData = [];

// --- Configuration ---
const GARDEN_CONFIG = {
  itemsPerRow: 5,
  bugs: ['🐛', '🦋', '🐝', '🐞', '🐜'],
  plants: {
    beginner: ['🌱', '🌱'],
    intermediate: ['🌿', '🌿', '🌿', '🌿'],
    master: ['🌸', '🌸', '🌸', '🌸']
  },
  modalAutoCloseDelay: 2200,
  validationThresholds: {
    intermediate: 5,
    master: 10 // Utilisera seuilValidation si défini
  }
};

// ============================================================================
// GÉNÉRATION DU JARDIN
// ============================================================================

/**
 * Génère et affiche le jardin visuel avec les caractères sous forme de plantes
 */
function generateGarden() {
  const ground = document.getElementById('garden-ground');
  if (!ground) {
    console.error('❌ Élément #garden-ground introuvable');
    return;
  }
  
  ground.innerHTML = '';
  
  const currentLevel = niveauActif;
  const visibleItems = HiraganaList.filter(item => parseInt(item.Niveau) <= currentLevel);
  
  // Regrouper par niveau
  const levels = groupByLevel(visibleItems);
  
  // Générer les lignes du jardin
  const rows = generateGardenRows(levels, currentLevel);
  rows.forEach(row => ground.appendChild(row));
  
  // Conversion des emojis en Fluent 3D
  convertGardenEmojis(ground);
  
  // Initialiser la légende avec scroll
  initializeGardenLegend();
  
  console.log(`🌸 Jardin généré: ${visibleItems.length} caractères, niveau ${currentLevel}`);
}

/**
 * Regroupe les items par niveau
 */
function groupByLevel(items) {
  const levels = {};
  items.forEach(item => {
    const lvl = parseInt(item.Niveau);
    if (!levels[lvl]) levels[lvl] = [];
    levels[lvl].push(item);
  });
  return levels;
}

/**
 * Génère toutes les lignes du jardin
 */
function generateGardenRows(levels, maxLevel) {
  const rows = [];
  let currentRow = null;
  let itemsInRow = 0;
  
  for (let lvl = 1; lvl <= maxLevel; lvl++) {
    // Ajouter un insecte séparateur entre les niveaux (sauf au début)
    if (lvl > 1) {
      if (!currentRow || itemsInRow === GARDEN_CONFIG.itemsPerRow) {
        currentRow = createNewRow();
        rows.push(currentRow);
        itemsInRow = 0;
      }
      addBugToRow(currentRow);
      itemsInRow++;
    }
    
    // Ajouter tous les items de ce niveau
    if (levels[lvl]) {
      levels[lvl].forEach(item => {
        if (!currentRow || itemsInRow === GARDEN_CONFIG.itemsPerRow) {
          currentRow = createNewRow();
          rows.push(currentRow);
          itemsInRow = 0;
        }
        
        const itemDiv = createPlantItem(item);
        currentRow.appendChild(itemDiv);
        itemsInRow++;
      });
    }
  }
  
  // Compléter la dernière ligne avec des slots invisibles
  if (currentRow && itemsInRow < GARDEN_CONFIG.itemsPerRow) {
    addEmptySlots(currentRow, GARDEN_CONFIG.itemsPerRow - itemsInRow);
  }
  
  return rows;
}

/**
 * Crée un élément plante pour un caractère
 */
function createPlantItem(item) {
  const validation = validationCache[parseInt(item.ID)] || 0;
  const plant = getPlantEmoji(validation);
  
  const itemDiv = document.createElement('div');
  itemDiv.className = 'garden-item';
  itemDiv.onclick = () => openGardenModal(item, plant);
  itemDiv.innerHTML = `
    <div class="garden-plant">${plant}</div>
    <div class="garden-hiragana">${item.Hiragana}</div>
  `;
  
  return itemDiv;
}

/**
 * Crée une nouvelle ligne de jardin
 */
function createNewRow() {
  const row = document.createElement('div');
  row.className = 'garden-level';
  return row;
}

/**
 * Ajoute un insecte aléatoire à une ligne
 */
function addBugToRow(row) {
  const emoji = GARDEN_CONFIG.bugs[Math.floor(Math.random() * GARDEN_CONFIG.bugs.length)];
  const bugDiv = document.createElement('div');
  bugDiv.className = 'garden-item garden-bug';
  bugDiv.innerHTML = `<div style="font-size:2.8em;">${emoji}</div>`;
  bugDiv.onclick = () => openInsectFlashcard(emoji);
  row.appendChild(bugDiv);
}

/**
 * Ajoute des slots vides invisibles pour compléter une ligne
 */
function addEmptySlots(row, count) {
  for (let i = 0; i < count; i++) {
    const empty = document.createElement('div');
    empty.className = 'garden-item';
    empty.style.visibility = 'hidden';
    row.appendChild(empty);
  }
}

/**
 * Convertit les emojis du jardin en Fluent 3D
 */
function convertGardenEmojis(ground) {
  requestAnimationFrame(() => {
    if (typeof safeConvertEmojis === 'function') {
      safeConvertEmojis(ground);
      console.log('✅ Emojis du jardin convertis en Fluent 3D');
    } else {
      console.warn('⚠️ safeConvertEmojis non disponible');
    }
  });
}

/**
 * Initialise la légende flottante avec gestion du scroll
 */
function initializeGardenLegend() {
  const container = document.querySelector('.garden-container');
  const legend = document.getElementById('garden-legend');
  
  if (!legend || !container) return;
  
  legend.style.display = 'flex';
  legend.classList.add('visible');
  
  container.addEventListener('scroll', () => {
    legend.classList.toggle('visible', container.scrollTop > 80);
  });
}

// ============================================================================
// MODAL DE DÉTAILS
// ============================================================================

let modalCloseTimeout = null;

/**
 * Ouvre la modal avec les détails d'un caractère
 */
function openGardenModal(item, emoji) {
  const modal = document.getElementById('garden-modal');
  if (!modal) {
    console.error('❌ Modal #garden-modal introuvable');
    return;
  }

  // Annuler le précédent timeout si existant
  if (modalCloseTimeout) {
    clearTimeout(modalCloseTimeout);
  }

  // Remplir les données
  safeSetContent('modal-plant', emoji);
  safeSetContent('modal-hiragana', item.Hiragana);
  safeSetContent('modal-katakana', getLocalizedKatakana(item) || '-');
  safeSetContent('modal-romaji', item.Romaji);
  safeSetContent('modal-level', item.Niveau);
  safeSetContent('modal-validation', validationCache[parseInt(item.ID)] || 0);

  // Convertir les emojis de la modal
  requestAnimationFrame(() => {
    const card = modal.querySelector('.garden-card');
    if (card && typeof safeConvertEmojis === 'function') {
      safeConvertEmojis(card);
    }
  });
  
  // Afficher la modal
  modal.classList.add('visible');
  
  // Fermeture automatique
  modalCloseTimeout = setTimeout(closeGardenModal, GARDEN_CONFIG.modalAutoCloseDelay);
  
  // Jouer le son si activé
  playCharacterSound(item);
}

/**
 * Ferme la modal de jardin
 */
function closeGardenModal() {
  const modal = document.getElementById('garden-modal');
  if (modal) {
    modal.classList.remove('visible');
  }
  if (modalCloseTimeout) {
    clearTimeout(modalCloseTimeout);
    modalCloseTimeout = null;
  }
}

/**
 * Joue le son d'un caractère si la voix est activée
 */
function playCharacterSound(item) {
  if (typeof voiceEnabled !== 'undefined' && voiceEnabled) {
    const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${encodeURIComponent(item.Hiragana)}.mp3`;
    const audio = new Audio(audioUrl);
    audio.play().catch(err => {
      console.warn('⚠️ Erreur lecture audio:', err.message);
    });
  }
}

/**
 * Ouvre une flashcard pour un insecte (fonction de fallback)
 */
function openInsectFlashcard(emoji) {
  if (typeof window.openInsectFlashcard === 'function') {
    window.openInsectFlashcard(emoji);
  } else {
    console.log(`🐛 Insecte cliqué: ${emoji}`);
    // Fallback : afficher une alerte simple
    alert(`${emoji} Insecte du niveau !`);
  }
}

// ============================================================================
// SYSTÈME DE PLANTES
// ============================================================================

/**
 * Retourne l'emoji de plante selon le nombre de validations
 */
function getPlantEmoji(validation) {
  const masterThreshold = typeof seuilValidation !== 'undefined' 
    ? seuilValidation 
    : GARDEN_CONFIG.validationThresholds.master;
  
  const intermediateThreshold = GARDEN_CONFIG.validationThresholds.intermediate;
  
  let plantArray;
  if (validation >= masterThreshold) {
    plantArray = GARDEN_CONFIG.plants.master;
  } else if (validation >= intermediateThreshold) {
    plantArray = GARDEN_CONFIG.plants.intermediate;
  } else {
    plantArray = GARDEN_CONFIG.plants.beginner;
  }
  
  return plantArray[Math.floor(Math.random() * plantArray.length)];
}

// ============================================================================
// STATISTIQUES ET FILTRES
// ============================================================================

/**
 * Filtre les statistiques selon le critère sélectionné
 */
function filterStats(filter) {
  console.log('🔍 Filtrage:', filter);
  
  // Mettre à jour les boutons actifs
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  
  const activeBtn = document.querySelector(`[data-filter="${filter}"]`);
  if (activeBtn) {
    activeBtn.classList.add('active');
  }
  
  // Afficher le tableau filtré
  renderStatsTable(currentStatsData, filter);
}

/**
 * Affiche le tableau de statistiques filtré
 */
function renderStatsTable(data, filter = 'all') {
  const tbody = document.getElementById('stats-table-body');
  if (!tbody) {
    console.error('❌ Élément #stats-table-body introuvable');
    return;
  }
  
  // Filtrer les données
  let filtered = filterDataByStatus(data, filter);
  
  // Trier par niveau décroissant puis par ID décroissant
  filtered.sort((a, b) => {
    const nivA = parseInt(a.niveau);
    const nivB = parseInt(b.niveau);
    if (nivA !== nivB) return nivB - nivA;
    return b.id - a.id;
  });
  
  // Générer le HTML
  if (filtered.length === 0) {
    tbody.innerHTML = `
      <tr>
        <td colspan="4" style="text-align: center; opacity: 0.5; padding: 2em;">
          🌸 ${getTranslation('stats_no_items', 'Aucun élément à afficher')}
        </td>
      </tr>
    `;
    return;
  }
  
  tbody.innerHTML = filtered.map(item => `
    <tr class="${item.statutClass}">
      <td><strong>${item.hiragana}</strong></td>
      <td>${item.katakana}</td>
      <td><em>${item.romaji}</em></td>
      <td><span class="status-emoji">${item.statutEmoji}</span></td>
    </tr>
  `).join('');
  
  console.log(`📋 Tableau affiché: ${filtered.length} items (filtre: ${filter})`);
}

/**
 * Filtre les données selon le statut
 */
function filterDataByStatus(data, filter) {
  if (filter === 'all') return data;
  
  return data.filter(item => {
    if (filter === 'acquired') return item.statutClass === 'acquired';
    if (filter === 'review') return item.statutClass === 'review';
    if (filter === 'progress') return item.statutClass === 'progress';
    return true;
  });
}

/**
 * Met à jour les compteurs de filtres
 */
function updateFilterCounts(data) {
  const counts = {
    all: data.length,
    acquired: data.filter(item => item.statutClass === 'acquired').length,
    review: data.filter(item => item.statutClass === 'review').length,
    progress: data.filter(item => item.statutClass === 'progress').length
  };
  
  safeSetContent('count-all', `(${counts.all})`);
  safeSetContent('count-acquired', `(${counts.acquired})`);
  safeSetContent('count-review', `(${counts.review})`);
  safeSetContent('count-progress', `(${counts.progress})`);
  
  console.log('📊 Compteurs mis à jour:', counts);
}

// ============================================================================
// UTILITAIRES
// ============================================================================

/**
 * Définit le contenu d'un élément de manière sécurisée
 */
function safeSetContent(elementId, content) {
  const element = document.getElementById(elementId);
  if (element) {
    element.textContent = content;
  } else {
    console.warn(`⚠️ Élément #${elementId} introuvable`);
  }
}

/**
 * Récupère une traduction avec fallback
 */
function getTranslation(key, fallback) {
  if (typeof t === 'function') {
    return t(key);
  }
  return fallback;
}

/**
 * Fonction de placeholder pour la bulle de validation (legacy)
 */
function showValidationBubble(charCard, validation, seuil) {
  charCard.style.position = "relative";
  // Implémentation à compléter si nécessaire
}

// ============================================================================
// EXPORT (si module ES6)
// ============================================================================

if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    generateGarden,
    filterStats,
    renderStatsTable,
    updateFilterCounts,
    openGardenModal,
    closeGardenModal
  };
}
// ============================================================================
// 🎨 SECTION 10 : ANIMATIONS & EFFETS VISUELS
// ============================================================================

// --- Variables animations ---
let activeSparks = [];
let globalParticleCount = 0;
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
const MAX_ACTIVE_PARTICLES = isMobile ? 15 : 30;

// --- Fonctions animations ---
function createSparkles() {
  const sparkleEmojis = ["✨", "⭐", "💫", "🌟", "✦"];
  const resultDiv = document.getElementById("result");
  const sparkleCount = 12;      // Nombre de particules
  const sparkleSize = 0.8;      // Taille en rem
  const sparkleOpacity = 0.3;   // Opacité (30%)
  
  for (let i = 0; i < sparkleCount; i++) {
    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    
    // Choisir un emoji d'étincelle aléatoire
    const sparkleChar = sparkleEmojis[Math.floor(Math.random() * sparkleEmojis.length)];
    sparkle.textContent = sparkleChar;
    
    // Appliquer la taille
    sparkle.style.fontSize = sparkleSize + 'rem';
    
    // Position de départ au centre
    sparkle.style.left = '50%';
    sparkle.style.top = '50%';
    
    // Direction aléatoire en cercle
    const angle = (Math.PI * 2 * i) / sparkleCount;
    const distance = 80 + Math.random() * 40;
    const tx = Math.cos(angle) * distance;
    const ty = Math.sin(angle) * distance;
    
    sparkle.style.setProperty('--tx', `${tx}px`);
    sparkle.style.setProperty('--ty', `${ty}px`);
    sparkle.style.setProperty('--sparkle-opacity', sparkleOpacity);
    
    // Délai aléatoire pour effet échelonné
    sparkle.style.animationDelay = `${Math.random() * 0.2}s`;
    
    resultDiv.appendChild(sparkle);
    
    // Nettoyer après l'animation
    setTimeout(() => sparkle.remove(), 1000);
  }
}
function createSparklesForPlant(container) {
  const sparkleEmojis = ["✨", "⭐", "💫", "🌟", "✦"];
  const sparkleCount = 12;
  const sparkleSize = 0.6;
  const sparkleOpacity = 0.4;
  
  for (let i = 0; i < sparkleCount; i++) {
    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    sparkle.style.position = 'absolute';
    sparkle.style.pointerEvents = 'none';
    
    const sparkleChar = sparkleEmojis[Math.floor(Math.random() * sparkleEmojis.length)];
    sparkle.textContent = sparkleChar;
    
    sparkle.style.fontSize = sparkleSize + 'rem';
    sparkle.style.left = '50%';
    sparkle.style.top = '50%';
    
    const angle = (Math.PI * 2 * i) / sparkleCount;
    const distance = 60 + Math.random() * 30;
    const tx = Math.cos(angle) * distance;
    const ty = Math.sin(angle) * distance;
    
    sparkle.style.setProperty('--tx', `${tx}px`);
    sparkle.style.setProperty('--ty', `${ty}px`);
    sparkle.style.setProperty('--sparkle-opacity', sparkleOpacity);
    sparkle.style.animationDelay = `${Math.random() * 0.1}s`;
    
    container.appendChild(sparkle);
    
    setTimeout(() => sparkle.remove(), 800);
  }
}
function spawnSparklesInFlashcard(container, type) {
  const icons =
    type === "flower"
      ? ["✨","🌸","💖","⭐"]
      : ["🍃","💨","✨"];

  const count = 14 + Math.floor(Math.random() * 6);

  for (let i = 0; i < count; i++) {
    const s = document.createElement("div");
    s.className = "sparkle-flashcard";
    s.textContent = icons[Math.floor(Math.random() * icons.length)];
    s.style.position = "absolute";
    s.style.fontSize = "22px";
    s.style.pointerEvents = "none";
    s.style.left = "50%";
    s.style.top = "50%";
    s.style.setProperty("--x", `${(Math.random() - .5) * 240}px`);
    s.style.setProperty("--y", `${(Math.random() - .8) * 240}px`);
    s.style.animation = "sparkleFlashcard 1.3s ease-out forwards";
    
    container.appendChild(s);
    setTimeout(() => s.remove(), 1300);
  }
}
function triggerSakuraFall(container) {
for (let i = 0; i < 30; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}
}
function triggerLevelUpAnimation(container) {
  const toHide = ['#question', '#choices1', '#choices2'];
  toHide.forEach(id => {
    const el = document.querySelector(id);
    if (el) el.style.visibility = 'hidden';
  });
  
  triggerSakuraFall(container);
  
  setTimeout(() => {
    toHide.forEach(id => {
      const el = document.querySelector(id);
      if (el) {
        el.style.visibility = 'visible';
        // ❌ SUPPRIME cette ligne : el.style.opacity = 0;
        
        el.animate([
          { opacity: 0 },
          { opacity: 1 }
        ], {
          duration: 600,
          fill: 'forwards'
        }).onfinish = () => {
          // ✅ AJOUTE ça : reset l'opacity inline après l'animation
          el.style.opacity = '';
        };
      }
    });
  }, 3000);
  
  const msgWrapper = document.createElement("div");
  msgWrapper.style.position = "fixed";
  msgWrapper.style.top = "40%";
  msgWrapper.style.left = "0";
  msgWrapper.style.width = "100vw";
  msgWrapper.style.textAlign = "center";
  msgWrapper.style.zIndex = 9999;
  msgWrapper.style.pointerEvents = "none";
  document.body.appendChild(msgWrapper);
  
  const msg = document.createElement("div");
  msg.innerText = t('msg_level_up');
  msg.style.display = "inline-block";
  msg.style.fontSize = "3em";
  msg.style.fontWeight = "bold";
  msg.style.color = "#8B6F47";
  msg.style.textShadow = "0 0 20px #A8D5BA, 0 0 40px #FDC1C5";
  msg.style.writingMode = "horizontal-tb";
  msg.style.whiteSpace = "nowrap";
  msgWrapper.appendChild(msg);
  
  msg.animate([
    { transform: "translateY(0)", opacity: 1 },
    { transform: "translateY(-40px)", opacity: 0 }
  ], {
    duration: 3000,
    easing: "ease-out"
  }).onfinish = () => msgWrapper.remove();
  
  const marker = document.querySelector(".progress-marker");
  if (marker) {
    marker.animate([
      { transform: "translate(-50%, -50%) rotate(0deg) scale(1)" },
      { transform: "translate(-50%, -50%) rotate(180deg) scale(4)" },
      { transform: "translate(-50%, -50%) rotate(360deg) scale(1)" }
    ], {
      duration: 1000,
      easing: "ease-in-out"
    });
  }
}
// --- Fireworks ---
function drawStar(ctx, x, y, radius, rotation = 0) {
const points = 5;
const outerRadius = radius;
const innerRadius = radius / 2;
ctx.beginPath();
for (let i = 0; i < points * 2; i++) {
const r = i % 2 === 0 ? outerRadius : innerRadius;
const angle = (i * Math.PI / points) + rotation - Math.PI / 2;
ctx.lineTo(
x + r * Math.cos(angle),
y + r * Math.sin(angle)
);
}
ctx.closePath();
ctx.fill();
}
function triggerAdvancedFirework(container) {
  console.log('🎆 triggerAdvancedFirework APPELÉE', { 
    container, 
    activeSparks: activeSparks.length,
    MAX: MAX_ACTIVE_PARTICLES 
  });  
initAudio();
const validatedCount = getValidatedCountForLevel(niveauActif);
const canvas = document.createElement('canvas');
canvas.style.position = 'absolute';
canvas.style.left = '50%';
canvas.style.top = '50%';
canvas.style.transform = 'translate(-50%, -50%)';
canvas.style.pointerEvents = 'none';
canvas.style.zIndex = '100000';
canvas.width = 400;
canvas.height = 400;
document.body.appendChild(canvas);  // ✅ Ajouter au body au lieu du container

// Et ajuste la position
const rect = container.getBoundingClientRect();
canvas.style.position = 'fixed';  // ✅ fixed au lieu de absolute
canvas.style.left = rect.left + rect.width / 2 + 'px';
canvas.style.top = rect.top + rect.height / 2 + 'px';
const ctx = canvas.getContext('2d');

const colorPalettes = [
['#6B8E23', '#9ACD32', '#32CD32', '#228B22', '#008000', '#006400'], // Palette verte
['#A8D5BA', '#76FF03', '#64DD17', '#00C853', '#AEEA00', '#00E676'],
['#FDC1C5', '#F48FB1', '#EC407A', '#D81B60', '#AD1457', '#FF80AB'],
];
const colors = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

const maxLifeBase = isMobile ? 30 : 50;
const numParticles = isMobile ? 9 : 12;
const numSalvos = isMobile ? 3 : 3;
const gravity = 0.1;
const salvoDelay = 150;
const dispersionBase = 3;
const itemCount = getItemCountForLevel(niveauActif);
const particles = [];
const trails = [];

const halo = document.createElement('div');
halo.style.position = 'absolute';
halo.style.left = '50%';
halo.style.top = '50%';
halo.style.width = '20px';
halo.style.height = '20px';
halo.style.borderRadius = '50%';
halo.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.05))';
halo.style.transform = 'translate(-50%, -50%) scale(1)';
halo.style.opacity = '1';
halo.style.zIndex = '100000';
halo.style.pointerEvents = 'none';
document.body.appendChild(halo);
halo.style.position = 'fixed';
halo.style.left = `${rect.left + rect.width / 2}px`;
halo.style.top = `${rect.top + rect.height / 2}px`;
halo.animate([
{ transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
{ transform: 'translate(-50%, -50%) scale(6)', opacity: 0 }
], {
duration: 700,
easing: 'ease-out'
}).onfinish = () => halo.remove();

console.log("🎯 nbre d'items dans le niveau =", itemCount, "niveau =", niveauActif);
console.log("🎯 nbre d'items validés =", validatedCount, "niveau =", niveauActif);  
if (validatedCount === itemCount-1) {
  playLevelUp();
  triggerLevelUpAnimation(document.body);
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 0) {
playFireworkSound();
}

for (let salvo = 0; salvo < numSalvos; salvo++) {
setTimeout(() => {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`⚠️ Salvo ${salvo} annulée - limite atteinte`);
return;
}

const biasDirection = Math.random() < 0.5 ? -1 : 1;
const biasMagnitude = (Math.random() * 0.2 - 0.1) * biasDirection;

for (let i = 0; i < numParticles; i++) {
if (activeSparks.length >= MAX_ACTIVE_PARTICLES) {
console.warn(`🛑 Particule ${i} du salvo ${salvo} ignorée - limite atteinte`);
break;
}

const angleOffset = (Math.random() * 10 - 5) * (Math.PI / 180);
const angle = angleOffset + (i * (360 / numParticles)) * (Math.PI / 180);
const isUpward = (angle >= 3 * Math.PI / 2 || angle <= Math.PI / 2);
let speed = dispersionBase + Math.random() * 3;
if (isUpward) {
speed = Math.max(7, speed);
if ((angle >= 3 * Math.PI / 2 && biasDirection === -1) || (angle <= Math.PI / 2 && biasDirection === 1)) {
speed *= (1 + biasMagnitude);
}
}

const v0x = speed * Math.cos(angle);
const v0y = speed * Math.sin(angle) * -1;
const color = colors[Math.floor(Math.random() * colors.length)];

particles.push({
x: canvas.width / 2,
y: canvas.height / 2,
vx: v0x,
vy: v0y,
life: maxLifeBase + Math.random() * 20,
maxLife: maxLifeBase + Math.random() * 20,
color: color,
rotation: Math.random() * Math.PI * 2
});
activeSparks.push({ canvas });
globalParticleCount++;

}
}, salvo * salvoDelay);
}

function animate() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

if (!isMobile) {
particles.forEach(p => {
if (Math.random() < 0.2) {
trails.push({
x: p.x,
y: p.y,
color: p.color,
life: 10
});
}
});
}

trails.forEach((t, i) => {
t.life--;
if (t.life <= 0) {
trails.splice(i, 1);
return;
}
ctx.fillStyle = t.color;
ctx.globalAlpha = t.life / 10 * 0.3;
ctx.beginPath();
ctx.arc(t.x, t.y, isMobile ? 2 : 3, 0, 2 * Math.PI);
ctx.fill();
});

particles.forEach((p, i) => {
p.x += p.vx;
p.y += p.vy;
p.vy += gravity;
p.life--;
p.rotation += 0.05;
if (p.life <= 0) {
particles.splice(i, 1);
activeSparks.splice(i, 1);
globalParticleCount--;
return;
}
ctx.fillStyle = p.color;
ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
ctx.save();
ctx.translate(p.x, p.y);
drawStar(ctx, 0, 0, isMobile ? 4 : 6, p.rotation);
ctx.restore();
});

if (particles.length > 0 || Date.now() < Date.now() + numSalvos * salvoDelay) {
requestAnimationFrame(animate);
} else {
canvas.remove();
activeSparks = activeSparks.filter(spark => spark.canvas !== canvas);
globalParticleCount = Math.max(0, globalParticleCount - particles.length);
console.log('Animation terminée');
}
}
requestAnimationFrame(animate);
}
function triggerLightFirework(card) {
const halo = document.createElement("div");
halo.style.position = "absolute";
halo.style.width = "30px";
halo.style.height = "30px";
halo.style.borderRadius = "50%";
halo.style.background = "radial-gradient(circle, rgba(253,193,197,0.9), rgba(253,193,197,0.1))";
halo.style.transform = "translate(-50%, -50%) scale(1)";
halo.style.opacity = "1";
halo.style.pointerEvents = "none";
halo.style.zIndex = "10";

const rect = card.getBoundingClientRect();
const cx = rect.left + rect.width / 2;
const cy = rect.top + rect.height / 2;

halo.style.left = `${cx}px`;
halo.style.top = `${cy}px`;
document.body.appendChild(halo);

halo.animate([
{ transform: "translate(-50%, -50%) scale(1)", opacity: 1 },
{ transform: "translate(-50%, -50%) scale(4)", opacity: 0 }
], {
duration: 800,
easing: "ease-out"
}).onfinish = () => halo.remove();

// Utiliser l'effet de chute de sakura depuis le haut de l'écran
for (let i = 0; i < 30; i++) {
const sakura = document.createElement("div");
sakura.className = "sakura";
sakura.style.left = Math.random() * 100 + "vw";
sakura.style.top = "-10px";
sakura.style.animationDelay = Math.random() * 1.5 + "s";
sakura.style.animationDuration = 2.5 + Math.random() * 1.5 + "s";
document.body.appendChild(sakura);
setTimeout(() => sakura.remove(), 4000);
}
const validatedCount = getValidatedCountForLevel(niveauActif);
const itemCount = getItemCountForLevel(niveauActif);
console.log("🎯 nbre d'items dans le niveau =", itemCount, "niveau =", niveauActif);
console.log("🎯 nbre d'items validés =", validatedCount, "niveau =", niveauActif);  


if (validatedCount === itemCount-1) {
  playLevelUp();
  triggerLevelUpAnimation(document.body);
} else if (validatedCount === 3) {
playfireworksound4();
} else if (validatedCount === 2) {
playfireworksound3();
} else if (validatedCount === 1) {
playfireworksound2();
} else if (validatedCount === 0) {
playFireworkSound();
}
 
}
function cleanupOldParticles() {
// Supprimer les particules les plus anciennes si on dépasse la limite
while (activeSparks.length > MAX_ACTIVE_PARTICLES) {
const oldSpark = activeSparks.shift();
if (oldSpark && oldSpark.canvas && oldSpark.canvas.parentNode) {
oldSpark.canvas.remove();
globalParticleCount--;
}
}
// Nettoyer les particules orphelines
activeSparks = activeSparks.filter(spark => {
if (!spark.canvas || !spark.canvas.parentNode) {
globalParticleCount--;
return false;
}
return true;
});
console.log(`🧹 Nettoyage: ${activeSparks.length} particules actives, ${globalParticleCount} compteur global`);
}




// ============================================================================
// 💬 SECTION 11 : FLASHCARDS & MODALES
// ============================================================================

let modalCloseTimer = null;
// ============================================================================TEST
let recentInsectMessageKeys = [];
const MAX_RECENT_INSECT_MESSAGES = 2;
function getRandomInsectMessage() {
  let available = insectMessages.filter(
    msg => !recentInsectMessageKeys.includes(msg.key)
  );

  // Sécurité : si tout a été utilisé récemment
  if (available.length === 0) {
    available = [...insectMessages];
    recentInsectMessageKeys = [];
  }

  const selected = available[Math.floor(Math.random() * available.length)];

  // Mise à jour mémoire courte
  recentInsectMessageKeys.push(selected.key);
  if (recentInsectMessageKeys.length > MAX_RECENT_INSECT_MESSAGES) {
    recentInsectMessageKeys.shift();
  }

  return selected;
}

  
  // 🐞 Insectes – clés de messages (i18n)
const insectMessages = [
  { emoji: '🐞', key: 'insect_msg_01' },
  { emoji: '🦋', key: 'insect_msg_02' },
  { emoji: '🐝', key: 'insect_msg_03' },
  { emoji: '🐛', key: 'insect_msg_04' },
  { emoji: '🐜', key: 'insect_msg_05' }
];

function openInsectFlashcard(forcedEmoji = null) {
  const modal = document.getElementById('insect-modal');
  const emojiDiv = document.getElementById('insect-emoji');
  const textDiv = document.getElementById('insect-text');

  if (!modal || !emojiDiv || !textDiv) return;

  const message = getRandomInsectMessage();

  emojiDiv.textContent = forcedEmoji || message.emoji;
  textDiv.textContent = t(message.key);

  modal.classList.add('visible');

  setTimeout(() => {
    safeConvertEmojis(modal);
  }, 50);

  setTimeout(closeInsectFlashcard, 2500);
}


function closeInsectFlashcard() {
  const modal = document.getElementById('insect-modal');
  if (modal) modal.classList.remove('visible');
}
// ============================================================================TEST

  
// --- Fonctions flashcards ---
function openRevisionFlashcard(item, emoji, isCorrect, oldValidation, newValidation, animateStatusChange = false, animateScore = false) {
  const portal = document.getElementById('modal-portal');
  
  // Emoji de l'ancienne plante (pour l'animation de changement de statut)
  const oldPlant = animateStatusChange ? getPlantEmoji(oldValidation) : emoji;

  // ✅ Déterminer quel caractère afficher (inverse de la question)
  const displayChar = revisionMode.currentItem.type === 'hiragana' 
    ? getLocalizedKatakana(item)  // Si question était Hiragana → afficher Katakana
    : item.Hiragana;                // Si question était Katakana → afficher Hiragana

  // ✅ Déterminer le type de transformation (flower ou leaf)
  const isUpgrade = newValidation > oldValidation; // 🌿 → 🌸
  const isDowngrade = newValidation < oldValidation; // 🌸 → 🌿

  // Construire le contenu de la flashcard
  portal.innerHTML = `
    <div class="revision-flashcard" style="background-color: ${isCorrect ? '#d4edda' : '#f8d7da'};">
      
      <!-- 1️⃣ LIGNE 1 : ROMAJI (principal) -->
      <div class="romaji-display" style="font-size: 4em; font-weight: bold; color: #333; margin-bottom: 0.5em;">
        ${item.Romaji}
      </div>
      
<!-- 2️⃣ LIGNE 2 : KATAKANA ou HIRAGANA (opposé de la question) -->
<div class="char-display" style="font-size: 4em !important; font-weight: bold; color: #8B6F47; margin-bottom: 0.5em;">
      
        ${displayChar}
      </div>
      
      <!-- 3️⃣ LIGNE 3 : SCORE + ANIMATION (ou EMOJI si changement de statut) -->
      <div id="line3-container" style="position: relative; min-height: 100px; display: flex; align-items: center; justify-content: center;">
        
        ${animateStatusChange ? `
          <!-- CAS A : Animation de changement de statut (score → emoji) -->
          <div id="score-container" style="font-size: 2.4em; font-weight: bold; color: #8B6F47;">
            Score : 
            <div style="display: inline-block; position: relative; width: 90px; height: 70px; overflow: hidden; margin-left: 12px; vertical-align: middle;">
              <div id="score-old" style="position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 1em; color: #333; line-height: 70px;">
                ${oldValidation}
              </div>
              <div id="score-new" style="position: absolute; left: 0; width: 100%; text-align: center; font-size: 1em; color: #333; font-weight: bold; line-height: 70px; top: ${isCorrect ? '70px' : '-70px'};">
                ${newValidation}
              </div>
            </div>
          </div>
          
          <!-- ✅ Container plante CENTRÉ avec position relative pour les sparkles -->
          <div id="plant-game" style="position: absolute; opacity: 0; display: flex; align-items: center; justify-content: center;">
            <span id="plant-emoji" class="plant-emoji" style="font-size: 4.5em; position: relative; z-index: 2; filter: drop-shadow(0 12px 24px rgba(0,0,0,.2));">${oldPlant}</span>
          </div>
        ` : `
          <!-- CAS B : Animation de score simple (pas de changement de statut) -->
          <div style="font-size: 2.4em; font-weight: bold; color: #8B6F47;">
            Score : 
            <div style="display: inline-block; position: relative; width: 90px; height: 70px; overflow: hidden; margin-left: 12px; vertical-align: middle;">
              <div id="score-old" style="position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 1em; color: #333; line-height: 70px;">
                ${oldValidation}
              </div>
              <div id="score-new" style="position: absolute; left: 0; width: 100%; text-align: center; font-size: 1em; color: #333; font-weight: bold; line-height: 70px; top: ${isCorrect ? '70px' : '-70px'};">
                ${newValidation}
              </div>
            </div>
          </div>
        `}
        
      </div>
    </div>
  `;

  // Activer le portal
  portal.classList.add('active');
  safeConvertEmojis(portal);

  // Fade vers blanc après 0.3s
  setTimeout(() => {
    const flashcard = portal.querySelector('.revision-flashcard');
    if (flashcard) {
      flashcard.style.transition = 'background-color 0.5s ease-out';
      flashcard.style.backgroundColor = '#ffffff';
    }
  }, 300);

  // Son
  if (voiceEnabled) {
    new Audio(`https://emmanuel971-source.github.io/hirakataquizz/${encodeURIComponent(item.Hiragana)}.mp3`)
      .play()
      .catch(() => {});
  }

  // === ANIMATIONS APRÈS LE FADE VERS BLANC (0.8s) ===
  setTimeout(() => {
    // 1. Animation du score (compteur à rouleaux)
if (animateScore && oldValidation !== newValidation) {  // ✅ Ajout de la condition
  const oldS = document.getElementById('score-old');
  const newS = document.getElementById('score-new');
  
if (animateScore) {
  const oldS = document.getElementById('score-old');
  const newS = document.getElementById('score-new');
  
  if (oldS && newS) {
    const diff = Math.abs(newValidation - oldValidation);
    const isGoingUp = newValidation > oldValidation;
    
    if (diff > 1) {
      // ✅ SOLUTION SIMPLE : Enchaîner plusieurs animations
      let currentValue = oldValidation;
      const direction = isGoingUp ? 1 : -1;
      
      function rollNext() {
        if (currentValue !== endValue) {
          const nextValue = currentValue + direction;
          
          // Créer les deux divs pour cette étape
          oldS.textContent = currentValue;
          newS.textContent = nextValue;
          
          // Reset positions
          oldS.style.animation = 'none';
          newS.style.animation = 'none';
          oldS.style.top = '0';
          newS.style.top = isGoingUp ? '70px' : '-70px';
          
          // Forcer le reflow
          void oldS.offsetHeight;
          
          // Lancer l'animation
          if (isGoingUp) {
            oldS.style.animation = 'rollDown 0.35s ease-in-out forwards';
            newS.style.animation = 'rollInDown 0.35s ease-in-out forwards';
          } else {
            oldS.style.animation = 'rollUp 0.35s ease-in-out forwards';
            newS.style.animation = 'rollInUp 0.35s ease-in-out forwards';
          }
          
          currentValue = nextValue;
          
          // Attendre la fin de l'animation avant la prochaine
          setTimeout(rollNext, 350);
        }
      }
      
      const endValue = newValidation;
      rollNext();
      
    } else {
      // Animation simple si diff = 1
      if (isGoingUp) {
        oldS.style.animation = 'rollDown 0.7s ease-in-out forwards';
        newS.style.animation = 'rollInDown 0.7s ease-in-out forwards';
      } else {
        oldS.style.animation = 'rollUp 0.7s ease-in-out forwards';
        newS.style.animation = 'rollInUp 0.7s ease-in-out forwards';
      }
    }
  }
}
}
    // 2. Animation de changement de statut AVEC TES VRAIES ANIMATIONS 🎊
    if (animateStatusChange) {
      const scoreContainer = document.getElementById('score-container');
      const plantGame = document.getElementById('plant-game');
      const plantEmoji = document.getElementById('plant-emoji');
      
      // Attendre la fin de l'animation du score (0.7s) puis transition
      setTimeout(() => {
        // Faire disparaître le score
        if (scoreContainer) {
          scoreContainer.style.transition = 'opacity 0.3s ease-out';
          scoreContainer.style.opacity = '0';
        }
        
        // ✅ FAIRE APPARAÎTRE LE CONTAINER PLANTE
        if (plantGame && plantEmoji) {
          plantGame.style.opacity = '1';
          plantGame.style.transition = 'opacity 0.3s ease-in';
          
          setTimeout(() => {
            // 🌿 → 🌸 (UPGRADE)
            if (isUpgrade) {
              plantEmoji.classList.add('wobble');
              
              setTimeout(() => {
                plantEmoji.classList.add('explode');
                spawnSparklesInFlashcard(plantGame, "flower");
                
                if (soundEnabled) {
                 // happySoundFlashcard();
                 playOkSound();
                }
                
                setTimeout(() => {
                  plantEmoji.textContent = emoji;
                  plantEmoji.className = 'plant-emoji pop';
                  safeConvertEmojis(plantEmoji);
                }, 60);
                
              }, 500); // Durée du wobble
            }
            
            // 🌸 → 🌿 (DOWNGRADE)
            else if (isDowngrade) {
              plantEmoji.classList.add('jelly');
              spawnSparklesInFlashcard(plantGame, "leaf");
              
              if (soundEnabled) {
                sadSoundFlashcard();
              }
              
              const shine = document.createElement("div");
              shine.className = "shine-flashcard";
              plantGame.appendChild(shine);
              setTimeout(() => shine.remove(), 800);
              
              setTimeout(() => {
                plantEmoji.textContent = emoji;
                safeConvertEmojis(plantEmoji);
              }, 300);
            }
          }, 100);
        }
      }, 700); // Attendre fin animation score
    }
  }, 800);

  // ✅ Fermeture adaptative selon le type d'animation
const closingDelay = animateStatusChange 
  ? (isUpgrade ? 2900 : 2800)  // Upgrade = 2.5s trop court test à 2900 pour voir, Downgrade = 2.8s (jelly plus long)
  : 1500;  // Pas de changement = fermeture rapide après le score

setTimeout(() => {
  closeRevisionFlashcard();
}, closingDelay);
}

function closeRevisionFlashcard() {
  const portal = document.getElementById('modal-portal');
  const flashcard = portal.querySelector('.revision-flashcard');
  
  if (flashcard) {
    flashcard.style.transition = 'all 0.4s ease-in';
    flashcard.style.opacity = '0';
    flashcard.style.transform = 'scale(0.8)';
  }
  
  setTimeout(() => {
    portal.classList.remove('active');
    portal.innerHTML = '';
    startRevisionQuestion();
  }, 400);
}
function showUnlockFlashcard(featureName, emoji, message) {
  console.log('🎭 showUnlockFlashcard appelée avec:', featureName);
  const portal = document.getElementById('modal-portal');
  console.log('🎭 Portal trouvé:', portal ? 'OUI' : 'NON');
  
  portal.innerHTML = `
    <div class="revision-flashcard unlock-flashcard" style="background: linear-gradient(135deg, #d4edda 0%, #f8f1e9 100%); animation: popIn 0.6s ease-out forwards;">
      <div class="unlock-sparkles" style="position: absolute; top: 10%; left: 10%; font-size: 2em; animation: sparkle 2s ease-in-out infinite;">✨</div>
      <div class="unlock-sparkles" style="position: absolute; top: 10%; right: 10%; font-size: 2em; animation: sparkle 2s ease-in-out infinite; animation-delay: 0.3s;">✨</div>
      <div class="unlock-sparkles" style="position: absolute; bottom: 15%; left: 15%; font-size: 2em; animation: sparkle 2s ease-in-out infinite; animation-delay: 0.6s;">✨</div>
      <div class="unlock-sparkles" style="position: absolute; bottom: 15%; right: 15%; font-size: 2em; animation: sparkle 2s ease-in-out infinite; animation-delay: 0.9s;">✨</div>
      
      <div style="font-size: 5em; animation: kawaii-bounce 1s ease-in-out infinite; display: inline-block; margin-bottom: 0.3em;">${emoji}</div>
      <div style="font-size: 2em; font-weight: bold; color: #8B6F47; margin: 0.5em 0; text-shadow: 0 2px 4px rgba(0,0,0,0.1);">${featureName}</div>
      <div style="font-size: 1.3em; color: #636E72; margin-top: 1em;">${message}</div>
    </div>
  `;
  
  portal.classList.add('active');
  safeConvertEmojis(portal);
  // Son de célébration
  if (soundEnabled) {
    playLevelUp();
  }
  
  // Fermer après 3 secondes
  setTimeout(() => {
    const flashcard = portal.querySelector('.revision-flashcard');
    if (flashcard) {
      flashcard.style.transition = 'all 0.4s ease-in';
      flashcard.style.opacity = '0';
      flashcard.style.transform = 'scale(0.8)';
    }
    
    setTimeout(() => {
      portal.classList.remove('active');
      portal.innerHTML = '';
    }, 400);
  }, 3000);
}


// ============================================================================
// 🎯 SECTION 12 : NAVIGATION & UI GÉNÉRALE
// ============================================================================

// --- Variables navigation ---
let lastSectionOpened = null;
const menuEmojis = ['🍵', '🪷', '🪴', '🐾', '🌱', '🍃', '🐞', '⛩️', '🐼', '🗾', '🪵', '🗻']

// --- Fonctions navigation ---
function showSection(sectionId) {
  console.log('🔍 showSection appelée avec:', sectionId);
  
  // ✅ Arrêter le Quiz Flash si on quitte cette section
  if (sectionId !== 'quiz-flash' && typeof quizFlashState !== 'undefined' && quizFlashState.timerInterval) {
    console.log('🛑 Arrêt du Quiz Flash (changement de section)');
    clearInterval(quizFlashState.timerInterval);
    quizFlashState.timerInterval = null;
  }
  // ✅ CORRECTION : Gestion de l'affichage du hamburger avec classe
  const hamburger = document.querySelector('.hamburger');
  const sectionsWithHamburger = ['quiz', 'mode2', 'account', 'stats', 'options', 
                                'options-difficulty', 'options-sound', 'options-language', 'login', 'quiz-flash'];
  
  if (hamburger) {
    if (sectionsWithHamburger.includes(sectionId)) {
      hamburger.classList.remove('hidden');
    } else {
      hamburger.classList.add('hidden');
    }
  }

  // NOUVEAU : Vérifier le blocage seulement lors du retour au menu depuis le mode révision
  if (sectionId === 'menu-section' && revisionMode.isActive) {
    const wasBlocked = hasShownBlockedMenu; // État précédent
    const isNowBlocked = isApprentissageBloque();
    
    // Mettre à jour l'état des boutons
    updateApprendreButtonState();
    
    // Afficher message approprié
    if (isNowBlocked && !wasBlocked) {
      // Passage de débloqué à bloqué
      setTimeout(() => {
        const menu = document.getElementById('menu');
        const menuMessage = document.getElementById('menu-message');
        menu.classList.add('active');
        menuMessage.innerText = t('menu_msg_blocked'); // ✅ MODIFIÉ
        hasShownBlockedMenu = true;
      }, 500);
    } else if (!isNowBlocked && wasBlocked) {
      // Passage de bloqué à débloqué
      setTimeout(() => {
        const menu = document.getElementById('menu');
        const menuMessage = document.getElementById('menu-message');
        menu.classList.add('active');
        menuMessage.innerText = t('menu_msg_unblocked'); // ✅ MODIFIÉ
        hasShownBlockedMenu = false;
        hasShownUnblockedMenu = true;
      }, 500);
    } else if (isNowBlocked) {
      // Toujours bloqué
      setTimeout(() => {
        const menuMessage = document.getElementById('menu-message');
        if (menuMessage) {
          menuMessage.innerText = t('menu_msg_still_blocked'); // ✅ MODIFIÉ
        }
      }, 500);
    }
    // Si on quitte le mode révision
  if (sectionId !== 'mode2') { // 'mode2' est l'ID de la section révision
    revisionMode.isActive = false;
    hasUnlockedInRevision = false; // Réinitialiser pour la prochaine session
  }
  }

  // NOUVEAU : Vérifier systématiquement l'état du bouton Apprendre à chaque passage par le menu
  if (sectionId === 'menu-section') {
    updateApprendreButtonState();
    updateMenuSectionMessage();
  }

  // Vérifier si on essaie d'accéder au mode révision
  if (sectionId === 'mode2' && !isRevisionModeAvailable()) {
    console.log('Mode révision non disponible');
    return;
  }

  // SUPPRIMER la redirection automatique vers le mode révision
  // Le bouton bloqué ne doit plus rediriger, il doit juste être inopérant
  
document.querySelectorAll('.section').forEach(section => {
    section.classList.remove('active');
  });
  document.getElementById(sectionId).classList.add('active');
  // ✅ Reset des Options à chaque entrée
if (sectionId === 'options') {
  resetOptionsView();
}

  if (sectionId === 'create-account') {
    initPseudoCache();
    generateNewPseudo();
  }
  
  // Démarrer le mode révisions si c'est le mode sélectionné
  if (sectionId === 'mode2') {
    wasBlockedWhenEnteringRevision = isApprentissageBloque();
    if (wasBlockedWhenEnteringRevision) {
      deficitInitialRevision = calculerDeficitValidation();
      pointsGagnesEnRevision = 0;
      console.log(`🎯 Déficit initial capturé: ${deficitInitialRevision} points`);
    }
    hasUnlockedInRevision = false;
    revisionMode.isActive = true;
    setTimeout(() => {
      initRevisionKeyboard();
      startRevisionQuestion();
      updateUnlockProgress(); // ✅ AJOUTE cette ligne
    }, 100);
  } else {
    revisionMode.isActive = false;
    wasBlockedWhenEnteringRevision = false;
  }
  
  // ✅ NOUVEAU : Générer une question quand on ouvre le mode Apprendre
if (sectionId === 'quiz') {
  updateLevelProgress(HiraganaList, niveauActif);
  renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
  renderHiraganaCards(HiraganaList, niveauActif);

  if (!localStorage.getItem('quizTutorialSeen')) {
    localStorage.setItem('quizTutorialSeen', 'true');
    const wait = () => {
      if (document.querySelectorAll('.hiragana-card').length > 0) {
        setTimeout(startQuizTutorial, 500);
      } else {
        requestAnimationFrame(wait);
      }
    };
    wait();
  } else {
    nextQuestion();
  }
}
    // ✅ NOUVEAU : Générer les stats quand on ouvre la page stats
if (sectionId === 'stats') {
    setTimeout(generateGarden, 100);
  }
  // ✅ CORRECTION : Ne fermer le menu que s'il est ouvert
  if (sectionId !== 'create-account') {
    const menu = document.getElementById('menu');
    
    // Ne toggle que si le menu est actuellement ouvert
    if (menu && menu.classList.contains('active')) {
      toggleMenu();
    }
    
    // Réafficher le hamburger
    setTimeout(() => {
      const hamburger = document.querySelector('.hamburger');
      if (hamburger && sectionsWithHamburger.includes(sectionId)) {
        hamburger.classList.remove('hidden'); // ✅ Changé
      }
    }, 100);
  }



}
function toggleMenu() {
  const menu = document.getElementById('menu');
  const hamburger = document.querySelector('.hamburger');
  
if (!menu.classList.contains('active')) { // Si on OUVRE le menu
  console.log('🔍 Ouverture du menu - arrêt du Quiz Flash');
  stopQuizFlash();

  }
  
  menu.classList.toggle('active');
  
  // ✅ CORRECTION : Utiliser une classe au lieu de style.display
  if (hamburger) {
    if (menu.classList.contains('active')) {
      hamburger.classList.add('hidden');
    } else {
      hamburger.classList.remove('hidden');
    }
  }
if (menu.classList.contains('active')) {
  setMenuEmojiOnOpen();
}


  // ✅ NOUVEAU : Fermer les modales contact si elles sont ouvertes
  if (menu.classList.contains('active')) {
    const contactFormModal = document.getElementById('contact-form-modal');
    const contactInboxModal = document.getElementById('contact-inbox-modal');
    
    if (contactFormModal && contactFormModal.classList.contains('active')) {
      contactFormModal.style.display = 'none';
      contactFormModal.classList.remove('active');
    }
    
    if (contactInboxModal && contactInboxModal.classList.contains('active')) {
      contactInboxModal.style.display = 'none';
      contactInboxModal.classList.remove('active');
    }
  }
  
  // Vérifier l'état des boutons à chaque ouverture du menu
  if (menu.classList.contains('active')) {
    updateMenuButtonStates();
  }
}

function setMenuEmoji(emoji) {
  const el = document.getElementById('menu-emoji');
  if (!el) return;

  el.style.opacity = '0';

  setTimeout(() => {
    el.textContent = emoji;
    el.style.opacity = '1';
     safeConvertEmojis(el);
  }, 180);
}

function setMenuEmojiOnOpen() {
  if (lastSectionOpened === 'options') {
    setMenuEmoji('⚙️');
  } else {
    const randomEmoji =
      menuEmojis[Math.floor(Math.random() * menuEmojis.length)];
    setMenuEmoji(randomEmoji);
  }
}
function backToMenu() {
  showSection('menu-section');
  toggleMenu();
}
function backToOptions() {
  // Masquer toutes les sous-rubriques
  document.querySelectorAll('.options-sub').forEach(div => {
    div.classList.remove("active");
    div.classList.add("hidden");
  });

  // Réafficher le menu principal Options
  const menu = document.querySelector(".options-menu");
  menu.classList.remove("hidden");
}

// --- Fonctions menu ---
function updateMenuButtonStates() {
  updateApprendreButtonState();
  updateRevisionButtonState();
  updateStatsButtonState(); // ✅ NOUVEAU
}
function updateApprendreButtonState() {
  const apprendreButton = document.querySelector('button[onclick="showSection(\'quiz\')"]');
  if (!apprendreButton) return;
  
  if (isApprentissageBloque()) {
    apprendreButton.classList.add('disabled');
    // Complètement bloquer le clic
    apprendreButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      // Optionnel : feedback visuel ou sonore pour indiquer que c'est bloqué
      console.log('Mode apprentissage bloqué - utilisez le mode révision');
      return false;
    };
    apprendreButton.title = 'Mode bloqué - Pratiquez le mode révision pour débloquer';
    apprendreButton.style.opacity = '0.5';
    apprendreButton.style.cursor = 'not-allowed';
  } else {
    apprendreButton.classList.remove('disabled');
    apprendreButton.onclick = () => showSection('quiz');
    apprendreButton.title = '';
    apprendreButton.style.opacity = '1';
    apprendreButton.style.cursor = 'pointer';
  }
}
function updateRevisionButtonState() {
  const revisionButton = document.getElementById('revision-button');
  if (!revisionButton) return;
  
  if (isRevisionModeAvailable()) {
    revisionButton.classList.remove('disabled');
    revisionButton.onclick = () => showSection('mode2');
    revisionButton.title = '';
  } else {
    revisionButton.classList.add('disabled');
    revisionButton.onclick = (e) => {
      e.preventDefault();
      // Optionnel : afficher un message
      console.log('Mode révision disponible à partir du niveau 4');
    };
   // revisionButton.title = 'Disponible à partir du niveau 4';
  }
}

function updateStatsButtonState() {
  const statsButton = document.querySelector('button[onclick="showSection(\'stats\')"]');
  if (!statsButton) return;
  
  if (niveauActif >= 5) {
    statsButton.classList.remove('disabled');
    statsButton.onclick = () => showSection('stats');
    statsButton.title = '';
    statsButton.style.opacity = '1';        // ✅ AJOUTE cette ligne
    statsButton.style.cursor = 'pointer';   // ✅ AJOUTE cette ligne
  } else {
    statsButton.classList.add('disabled');
    statsButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('Mon jardin disponible à partir du niveau 5');
      return false;
    };
  //  statsButton.title = 'Disponible à partir du niveau 5';
    statsButton.style.opacity = '0.5';
    statsButton.style.cursor = 'not-allowed';
  }
}
function updateMenuMessage() {
  const menuMessage = document.getElementById('menu-message');
  if (menuMessage && menuMessage.innerText === '') {
    // Messages neutres multilingues (les emojis sont universels)
    const messages = [
      '⛩️ Kanas-Zen-Garden ⛩️',
      '🎌 Kanas-Zen-Garden 🎌',
      '🍃 Kanas-Zen-Garden 🍵',
    ];
    menuMessage.innerText = messages[Math.floor(Math.random() * messages.length)];
  }
}
function updateMenuSectionMessage() {
  const messages = [
    'Continues à apprendre ! 🌸',
    'Explores les options ! ⚙️',
    'Progresses chaque jour ! 🐼',
    'Un pas après l\'autre 🌸',
    'Bravo, tu progresses 🎌'
  ];
  const menuMessage = document.getElementById('menu-message');
  if (menuMessage) {
    menuMessage.innerText = messages[Math.floor(Math.random() * messages.length)];
  }
} 
function forceRevisionMode() {
  document.querySelectorAll('.section').forEach(section => {
    section.classList.remove('active');
  });
  document.getElementById('mode2').classList.add('active');
  
  revisionMode.isActive = true;
  setTimeout(() => {
    initRevisionKeyboard();
    startRevisionQuestion();
    updateUnlockProgress(); // Ajouter cette ligne
  }, 100);
}


// ============================================================================
// ⚙️ SECTION 13 : OPTIONS & PARAMÈTRES
// ============================================================================

// --- Fonctions options ---
function showSubOptions(section) {
  // Masquer le menu principal
  document.querySelector(".options-menu").classList.add("hidden");

  // Masquer toutes les sous-rubriques
  document.querySelectorAll('.options-sub').forEach(div => {
    div.classList.remove("active");
    div.classList.add("hidden");
  });

  // Afficher la sous-rubrique choisie avec animation
  const sub = document.getElementById('options-' + section);
  sub.classList.remove("hidden");
  setTimeout(() => sub.classList.add("active"), 10);
   // ✅ NOUVEAU : Initialiser les étoiles de difficulté
  if (section === 'difficulty') {
    updateDifficultyButtons(seuilValidation);
  }
}
function resetOptionsView() {
  // Réafficher le menu Options principal
  const optionsMenu = document.querySelector(".options-menu");
  if (optionsMenu) {
    optionsMenu.classList.remove("hidden");
  }

  // Masquer toutes les sous-sections
  document.querySelectorAll(".options-sub").forEach(div => {
    div.classList.remove("active");
    div.classList.add("hidden");
  });
}
function setDifficulty(value) {
  seuilValidation = value; 
  localStorage.setItem("difficulty", value);

  // Mise à jour visuelle des boutons
  updateDifficultyButtons(value);

  // Mise à jour du bouton Apprendre
  updateApprendreButtonState();

  niveauActif = determineNiveauActif(HiraganaList);
  document.getElementById("levelDisplay").innerText = `Niveau actuel : ${niveauActif}`;
  updateLevelProgress(HiraganaList, niveauActif);
  renderProgressBar(niveauActif, getMaxLevel(HiraganaList));
  nextQuestion();
}
function loadDifficulty() {
  const saved = localStorage.getItem("difficulty");
  if (saved) {
    seuilValidation = parseInt(saved, 10);
    console.log("Difficulté restaurée :", seuilValidation);
  } else {
    // valeur par défaut si rien n'est encore enregistré
    seuilValidation = 6; // Moyen par défaut
  }
}
function updateDifficultyButtons(selectedValue) {
  const buttons = document.querySelectorAll('.difficulty-btn');
  
  buttons.forEach(btn => {
    const btnValue = parseInt(btn.getAttribute('data-difficulty'));
    const stars = btn.querySelectorAll('.difficulty-star');
    
    if (btnValue === selectedValue) {
      // Bouton sélectionné
      btn.classList.add('difficulty-selected');
      stars.forEach(star => {
        star.classList.remove('unlit');
        star.classList.add('lit');
      });
    } else {
      // Boutons non sélectionnés
      btn.classList.remove('difficulty-selected');
      stars.forEach(star => {
        star.classList.remove('lit');
        star.classList.add('unlit');
      });
    }
  });
}


// ============================================================================
// 📱 SECTION 14 : CONTACT & SUPPORT
// ============================================================================

// --- Variables contact ---
let unreadMessagesCount = 0;

// --- Fonctions contact ---
function initContactListeners() {
  // Compteur de caractères pour message simple
  const messageText = document.getElementById('message-text');
  if (messageText) {
    messageText.addEventListener('input', (e) => {
      const count = e.target.value.length;
      document.getElementById('char-count').textContent = count;
    });
  }
  
  // Compteur pour bug description
  const bugDescription = document.getElementById('bug-description');
  if (bugDescription) {
    bugDescription.addEventListener('input', (e) => {
      const count = e.target.value.length;
      document.getElementById('bug-char-count').textContent = count;
    });
  }
  
  // Vérifier les messages non lus au démarrage
  checkUnreadMessages();
}

function showContactForm(type) {
  const formModal = document.getElementById('contact-form-modal');
  const messageForm = document.getElementById('message-form');
  const bugForm = document.getElementById('bug-form');
  const title = document.getElementById('contact-form-title');
  
  // Masquer la section options
  document.getElementById('options').classList.remove('active');
  
  // Afficher le formulaire approprié
  formModal.style.display = 'flex';
  formModal.classList.add('active');
  
if (type === 'message') {
  messageForm.style.display = 'block';
  bugForm.style.display = 'none';
  title.setAttribute('data-i18n', 'contact_send_message');
} else if (type === 'bug') {
  messageForm.style.display = 'none';
  bugForm.style.display = 'block';
  title.setAttribute('data-i18n', 'contact_report_bug');
}

// ✅ Mettre à jour tous les textes traduits
updateAllTexts();
  
  // Réinitialiser les formulaires
  resetContactForms();
}
function closeContactForm() {
  const formModal = document.getElementById('contact-form-modal');
  formModal.style.display = 'none';
  formModal.classList.remove('active');
  
  // Retourner à la section contact
  document.getElementById('options').classList.add('active');
  showSubOptions('contact');
}
function resetContactForms() {
  // Message simple
  document.getElementById('message-text').value = '';
  document.getElementById('message-category').value = 'suggestion';
  document.getElementById('char-count').textContent = '0';
  document.getElementById('message-error').style.display = 'none';
  document.getElementById('message-success').style.display = 'none';
  
  // Bug report (sans screenshot)
  document.getElementById('bug-email').value = '';
  document.getElementById('bug-description').value = '';
  document.getElementById('bug-steps').value = '';
  document.getElementById('bug-char-count').textContent = '0';
  document.getElementById('bug-error').style.display = 'none';
  document.getElementById('bug-success').style.display = 'none';
}
async function submitMessage() {
  const messageText = document.getElementById('message-text').value.trim();
  const category = document.getElementById('message-category').value;
  const errorDiv = document.getElementById('message-error');
  const successDiv = document.getElementById('message-success');
  
  // Validation
  if (messageText.length < 10) {
    errorDiv.textContent = t('contact_error_short');
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
    return;
  }
  
  try {
    const result = await callAPI('submitMessage', {
      token: userToken || 'anonymous',
      type: 'message',
      category: category,
      message: messageText
    });
    
    if (result.success) {
      successDiv.textContent = t('contact_success_message');
      successDiv.style.display = 'block';
      errorDiv.style.display = 'none';
      
      // ✅ Réinitialiser le formulaire
      document.getElementById('message-text').value = '';
      
      setTimeout(() => {
        closeContactForm();
      }, 2000);
    } else {
      // ✅ Gestion des codes d'erreur
      if (result.errorCode === 'LIMIT_REACHED') {
        errorDiv.textContent = t('contact_limit_reached');
      } else if (result.errorCode === 'USER_NOT_IDENTIFIED') {
        errorDiv.textContent = t('contact_user_not_identified');
      } else {
        errorDiv.textContent = result.error || t('contact_error_network');
      }
      errorDiv.style.display = 'block';
      successDiv.style.display = 'none';
    }
  } catch (error) {
    console.error('Erreur submitMessage:', error);
    errorDiv.textContent = t('contact_error_network');
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
  }
}
async function submitBugReport() {
  const email = document.getElementById('bug-email').value.trim();
  const description = document.getElementById('bug-description').value.trim();
  const steps = document.getElementById('bug-steps').value.trim();
  const errorDiv = document.getElementById('bug-error');
  const successDiv = document.getElementById('bug-success');
  
  // Validation
  if (!email || !email.includes('@')) {
    errorDiv.textContent = t('contact_error_email');
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
    return;
  }
  
  if (description.length < 20) {
    errorDiv.textContent = t('contact_error_bug_short');
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
    return;
  }
  
  try {
    // ✅ Collecter les infos techniques
    const technicalInfo = {
      userAgent: navigator.userAgent,
      screenSize: `${window.screen.width}x${window.screen.height}`,
      windowSize: `${window.innerWidth}x${window.innerHeight}`,
      language: navigator.language,
      platform: navigator.platform,
      currentLevel: niveauActif,
      timestamp: new Date().toISOString()
    };
    
    const result = await callAPI('submitBugReport', {
      token: userToken || 'anonymous',
      email: email,
      description: description,
      steps: steps,
      technicalInfo: JSON.stringify(technicalInfo)
    });
    
    if (result.success) {
      successDiv.textContent = t('contact_success_bug');
      successDiv.style.display = 'block';
      errorDiv.style.display = 'none';
      
      // ✅ Réinitialiser le formulaire
      document.getElementById('bug-email').value = '';
      document.getElementById('bug-description').value = '';
      document.getElementById('bug-steps').value = '';
      
      setTimeout(() => {
        closeContactForm();
      }, 2000);
    } else {
      // ✅ Gestion des codes d'erreur
      if (result.errorCode === 'LIMIT_REACHED') {
        errorDiv.textContent = t('contact_limit_reached');
      } else if (result.errorCode === 'USER_NOT_IDENTIFIED') {
        errorDiv.textContent = t('contact_user_not_identified');
      } else {
        errorDiv.textContent = result.error || t('contact_error_network');
      }
      errorDiv.style.display = 'block';
      successDiv.style.display = 'none';
    }
  } catch (error) {
    console.error('Erreur submitBugReport:', error);
    errorDiv.textContent = t('contact_error_network');
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
  }
}
async function showContactInbox() {
  const inboxModal = document.getElementById('contact-inbox-modal');
  const loading = document.getElementById('inbox-loading');
  const empty = document.getElementById('inbox-empty');
  const messagesDiv = document.getElementById('inbox-messages');
  
  document.getElementById('options').classList.remove('active');
  
  inboxModal.style.display = 'flex';
  inboxModal.classList.add('active');
  
  loading.style.display = 'flex';
  empty.style.display = 'none';
  messagesDiv.innerHTML = '';
  
  try {
    const result = await callAPI('getUserMessages', {
      token: userToken || 'anonymous'
    });
    
    loading.style.display = 'none';
    
    if (result.success && result.messages && result.messages.length > 0) {
      renderMessages(result.messages);
      
      await markAllMessagesAsRead();
      updateUnreadBadge(0);
    } else {
      empty.style.display = 'block';
    }
  } catch (error) {
    console.error('Erreur showContactInbox:', error);
    loading.style.display = 'none';
    empty.innerHTML = `<p>${t('contact_inbox_error')}</p>`;
    empty.style.display = 'block';
  }
}
function closeContactInbox() {
  const inboxModal = document.getElementById('contact-inbox-modal');
  inboxModal.style.display = 'none';
  inboxModal.classList.remove('active');
  
  // Retourner à la section contact
  document.getElementById('options').classList.add('active');
  showSubOptions('contact');
}
function renderMessages(messages) {
  const messagesDiv = document.getElementById('inbox-messages');
  messagesDiv.innerHTML = '';
  
  messages.forEach(msg => {
    const card = document.createElement('div');
    card.className = `message-card ${msg.isRead ? '' : 'unread'}`;
    
    const typeLabel = {
      'suggestion': '' + t('contact_cat_suggestion'),
      'question': '' + t('contact_cat_question'),
      'feedback': '' + t('contact_cat_feedback'),
      'other': '' + t('contact_cat_other'),
      'bug': '🐛 Bug'
    }[msg.category] || '📝 ' + t('contact_cat_other');
    
    const date = new Date(msg.date).toLocaleDateString(currentLanguage === 'fr' ? 'fr-FR' : currentLanguage === 'es' ? 'es-ES' : 'en-US', {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    });
    
    card.innerHTML = `
      <div class="message-header">
        <span class="message-type">${typeLabel}</span>
        <span class="message-date">${date}</span>
      </div>
      <div class="message-content">${msg.message}</div>
      ${msg.response ? `
        <div class="message-response">
          <div class="response-header">
            ${t('contact_response_header')}
          </div>
          <div class="response-text">${msg.response}</div>
        </div>
      ` : `<p style="color: #999; font-style: italic;">${t('contact_waiting_response')}</p>`}
    `;
    
    messagesDiv.appendChild(card);
  });
}
async function checkUnreadMessages() {
  if (!userToken) return;
  
  try {
    const result = await callAPI('getUnreadCount', {
      token: userToken
    });
    
    if (result.success) {
      updateUnreadBadge(result.count);
    }
  } catch (error) {
    console.error('Erreur checkUnreadMessages:', error);
  }
}
function updateUnreadBadge(count) {
  unreadMessagesCount = count;
  const btn = document.getElementById('contact-inbox-btn');
  
  // Supprimer l'ancien badge s'il existe
  const oldBadge = btn.querySelector('.notification-badge');
  if (oldBadge) oldBadge.remove();
  
  // Ajouter le nouveau badge si count > 0
  if (count > 0) {
    const badge = document.createElement('span');
    badge.className = 'notification-badge';
    badge.textContent = count;
    btn.appendChild(badge);
  }
}

async function markAllMessagesAsRead() {
  if (!userToken) return;
  
  try {
    await callAPI('markMessagesRead', {
      token: userToken
    });
  } catch (error) {
    console.error('Erreur markAllMessagesAsRead:', error);
  }
}


// ============================================================================
// 🎨 SECTION 15 : EMOJIS & TWEMOJI
// ============================================================================

const EMOJIS_USED = [
  '🦋', '🸏', '🌵', '🌴', '🍀', '🌿', '🌱', '💩', '💻', '😸', '😽', '👽', '🌈',
  '🻻', '🞛', '🌌', '🌞', '✅', '🧠', '🶏', '🵻', '🗾', '🪵', '🗻', '🍀', '🜏'
];

// --- Fonctions emojis ---
window.safeConvertEmojis = function(element, attempt = 0) { /* ... */ };
function preloadEmojis() { /* ... */ }


// ============================================================================
// 🚀 SECTION 16 : INITIALISATION & CHARGEMENT
// ============================================================================

// --- Fonctions initialisation ---
async function initGame() {
  try {
    gameDataLoaded = false;
    console.log('🛠️ Initialisation du jeu avec chunking...');
// Récupération du token (déjà existant dans ton code, on le garde ici)
    const userTokenFromStorage = localStorage.getItem('userToken'); // ← renommé pour éviter conflit

    // ==================================================================
    // DÉTECTION DE LA LANGUE SELON NEW / RETURNING USER
    // ==================================================================
    let finalLanguage;

    if (!userTokenFromStorage) {
      // NEW USER → on force la langue du navigateur
      const browserLang = (navigator.language || navigator.userLanguage || "en")
        .toLowerCase().split('-')[0];

      if (browserLang.startsWith("fr")) finalLanguage = "fr";
      else if (browserLang.startsWith("es")) finalLanguage = "es";
      else finalLanguage = "en";

      console.log("NEW USER → Langue forcée par navigateur :", finalLanguage);

      // On sauvegarde pour cohérence (même si c'est un new user)
      localStorage.setItem('appLanguage', finalLanguage);

    } else {
      // RETURNING USER → on prend la langue qu'il a choisie dans les Options
      const savedLang = localStorage.getItem('appLanguage');
      finalLanguage = savedLang || "en"; // fallback au cas où

      console.log("RETURNING USER → Langue restaurée depuis localStorage :", finalLanguage);
    }

    // Application finale de la langue
    currentLanguage = finalLanguage;

    // Mise à jour IMMÉDIATE de tous les textes (avant tout affichage !)
    updateAllTexts();
    console.log("Langue appliquée au démarrage :", currentLanguage);

    // ==================================================================
    // Suite de ton initGame() existant (ne touche à rien en dessous)
    // ==================================================================
    // Masquer le texte "Chargement..." classique
    document.getElementById("loadingText").style.display = "none";
    
    // Afficher la barre de progression
    const progressContainer = document.getElementById('loading-progress-container');
    progressContainer.style.display = 'block';
    
    // ==========================================
    // PHASE 1 : DÉTECTION PROFIL (0-15%)
    // ==========================================
    updateLoadingProgress(5, "Connexion au serveur...");
    
    const token = localStorage.getItem('userToken');
    const profileResult = await callAPI('getProfile', { token: token || '' });
    
    if (!profileResult.success) {
      throw new Error('Erreur détection profil');
    }
    
    const profile = profileResult.profile;
    console.log('👤 Profil détecté:', profile);
    updateLoadingProgress(15, "Profil détecté !");
    
    // ==========================================
    // PHASE 2 : CHARGEMENT PRIORITAIRE (15-60%)
    // ==========================================
    
// ✅ NOUVEAU : Charger WordLists EN PRIORITÉ pour TOUS (NEW + RETURNING)
updateLoadingProgress(20, "Chargement des listes de mots...");
const wordListsResult = await callAPI('getWordLists');
if (wordListsResult.success) {
  localStorage.setItem('wordLists', JSON.stringify(wordListsResult.words));
  console.log(`📚 ${wordListsResult.count} mots chargés`);
} else {
  console.warn('⚠️ Échec chargement WordLists, fallback sera utilisé');
}

if (profile.isNew) {
  // 🆕 NEW USER : Niveaux 1-3
  updateLoadingProgress(35, "Chargement niveaux 1-3...");
      const chunk1Result = await callAPI('getHiraganaChunk', { startLevel: 1, endLevel: 3 });
      
      if (chunk1Result.success) {
        HiraganaList = chunk1Result.data.map(item => ({
          ...item,
          Validation: 0,
          Tentatives: 0,
          Réussites: 0
        }));
        console.log(`📊 Chunk 1: ${chunk1Result.count} items chargés (niveaux ${chunk1Result.startLevel}-${chunk1Result.endLevel})`);
      }
      
      updateLoadingProgress(60, "Prêt à jouer !");
      

       } else {
      // 🔁 RETURNING USER – NO CHUNK YET

      // Récupération profil et user (on en a besoin pour totalLevels et pseudo)
      updateLoadingProgress(40, "Récupération de votre profil...");
      userToken = token;
      const userResult = await callAPI('getUserByToken', { token: token });
      if (userResult.success) {
        currentUser = userResult.user;
        console.log('👤 Utilisateur récupéré:', currentUser.pseudo);
      }

      // Résolution définitive : qui est en avance ? Sync si besoin
      updateLoadingProgress(50, "Vérification de vos progrès...");
      await ensureLatestProgress(); // ← clientTruth est maintenant la vérité absolue

      // Maintenant on sait EXACTEMENT quel niveau utiliser
      const trustedNiveau = clientTruth.niveau_atteint || 1;
      const maxLevel = Math.min(trustedNiveau + 2, profile.totalLevels || 46);

      console.log(`🛠️ Chunk initial décidé APRÈS clientTruth : niveaux 1-${maxLevel} (basé sur niveau ${trustedNiveau})`);

      updateLoadingProgress(55, `Chargement niveaux 1-${maxLevel}...`);
      const chunkResult = await callAPI('getHiraganaChunk', { startLevel: 1, endLevel: maxLevel });

      if (chunkResult.success) {
        HiraganaList = chunkResult.data.map(item => ({
          ...item,
          Validation: 0,
          Tentatives: 0,
          Réussites: 0
        }));
        console.log(`📊 Chunk initial chargé : ${chunkResult.count} items (niveaux 1-${maxLevel})`);
      } else {
        console.error('Erreur chunk initial');
      }

      // Merge des stats (serveur à jour après éventuelle sync)
      updateLoadingProgress(58, "Application de vos statistiques...");
      await applyUserProgress();

      updateLoadingProgress(60, "Profil chargé !");
    }
    // ==========================================
    // PHASE 3 : INTERFACE JOUABLE (60-80%)
    // ==========================================
    updateLoadingProgress(70, "Initialisation de l'interface...");
    
    // Initialiser le système utilisateur
// ✅ Mettre à jour l'affichage du compte (pour new + returning)
if (currentUser) {
  updateAccountDisplay();
}
    
    // Déterminer niveau actif
    niveauActif = determineNiveauActif(HiraganaList);
    console.log(`🎮 Niveau actif calculé: ${niveauActif}`);
    
    // Initialiser l'UI
    document.getElementById("levelDisplay").innerText = `${t('quiz_level')} ${niveauActif}`;
    updateLevelProgress(HiraganaList, niveauActif);
    const totalLevels = profile.totalLevels || 46; // 46 = valeur par défaut si pas de profil
renderProgressBar(niveauActif, totalLevels);
    renderHiraganaCards(HiraganaList, niveauActif);
    updateMenuButtonStates();
    
    updateLoadingProgress(80, "Presque prêt...");
    
    // ==========================================
    // PHASE 4 : CHARGEMENT BACKGROUND (80-100%)
    // ==========================================
    gameDataLoaded = true;
    updateLoadingProgress(90, "Finalisation...");
    
    // Afficher le panda et masquer la barre
    const panda = document.querySelector(".panda-logo");
    const loadingText = document.getElementById("loadingText");
    if (panda && loadingText) {
      panda.style.opacity = "1";
      panda.style.pointerEvents = "auto";
      loadingText.textContent = t('welcome_touch');
      loadingText.style.display = "block";
    }
    
    updateLoadingProgress(100, "Chargement terminé !");
    
    // Masquer la barre après 500ms
    setTimeout(() => {
      progressContainer.style.display = 'none';
    }, 500);
    
    console.log('✅ initGame terminé avec succès');
    
    // ==========================================
    // PHASE 5 : CHARGEMENT EN ARRIÈRE-PLAN
    // ==========================================
    loadRemainingDataInBackground(profile);
    
  } catch (error) {
    console.error('❌ Erreur dans initGame:', error.message);
    document.getElementById('loading-message').textContent = 'Erreur : ' + error.message;
    document.getElementById('loading-message').style.color = '#dc3545';
    gameDataLoaded = false;
  }

}

async function loadRemainingDataInBackground(profile) {
  if (backgroundLoadingInProgress) return;
  backgroundLoadingInProgress = true;
  
  console.log('🔄 Démarrage chargement background...');
  
  try {
    if (profile.isNew) {
      // Charger niveaux 4-46 par paquets de 10
      for (let start = 4; start <= profile.totalLevels; start += 10) {
        const end = Math.min(start + 9, profile.totalLevels);
        console.log(`📥 Background: chargement niveaux ${start}-${end}...`);
        
        const chunkResult = await callAPI('getHiraganaChunk', { startLevel: start, endLevel: end });
        
        if (chunkResult.success) {
          const newItems = chunkResult.data.map(item => ({
            ...item,
            Validation: 0,
            Tentatives: 0,
            Réussites: 0
          }));
          
          HiraganaList.push(...newItems);
          
          // 🆕 MISE À JOUR DES CACHES POUR LES NOUVEAUX ITEMS
          newItems.forEach(item => {
            const id = parseInt(item.ID);
            validationCache[id] = 0; // Validation initiale à 0
            
            statsCache.items[id] = statsCache.items[id] || { tentatives: 0, reussites: 0, pourcentage: 0 };
            statsCache.items[id].tentatives = 0;
            statsCache.items[id].reussites = 0;
            statsCache.items[id].pourcentage = 0;
          });
          
          // Recalcul global des stats (propre mais pas obligatoire)
          const totalTentatives = Object.values(statsCache.items).reduce((sum, item) => sum + item.tentatives, 0);
          const totalReussites = Object.values(statsCache.items).reduce((sum, item) => sum + item.reussites, 0);
          statsCache.globalPourcentage = totalTentatives > 0 ? (totalReussites / totalTentatives * 100) : 0;
          
          console.log(`✅ Background: ${newItems.length} items ajoutés + caches initialisés (total: ${HiraganaList.length})`);
        }
        
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
    } else {
      // RETURNING USER
      const trustedNiveau = clientTruth?.niveau_atteint || profile.niveau || 1;
      const currentMax = Math.min(trustedNiveau + 2, profile.totalLevels || 46);
      
      if (currentMax < profile.totalLevels) {
        console.log(`📥 Background: chargement niveaux ${currentMax + 1}-${profile.totalLevels}...`);
        
        const chunkResult = await callAPI('getHiraganaChunk', { 
          startLevel: currentMax + 1, 
          endLevel: profile.totalLevels 
        });
        
        if (chunkResult.success) {
          const newItems = chunkResult.data.map(item => ({
            ...item,
            Validation: 0,
            Tentatives: 0,
            Réussites: 0
          }));
          
          HiraganaList.push(...newItems);
          
          // 🆕 MISE À JOUR DES CACHES POUR LES NOUVEAUX ITEMS
          newItems.forEach(item => {
            const id = parseInt(item.ID);
            validationCache[id] = 0;
            
            statsCache.items[id] = statsCache.items[id] || { tentatives: 0, reussites: 0, pourcentage: 0 };
            statsCache.items[id].tentatives = 0;
            statsCache.items[id].reussites = 0;
            statsCache.items[id].pourcentage = 0;
          });
          
          // Recalcul global
          const totalTentatives = Object.values(statsCache.items).reduce((sum, item) => sum + item.tentatives, 0);
          const totalReussites = Object.values(statsCache.items).reduce((sum, item) => sum + item.reussites, 0);
          statsCache.globalPourcentage = totalTentatives > 0 ? (totalReussites / totalTentatives * 100) : 0;
          
          console.log(`✅ Background: ${newItems.length} items ajoutés + caches initialisés (total: ${HiraganaList.length})`);
        }
      }
      

    }
    
    // Régénération tables
    revisionRomajiTable = generateRevisionRomajiTable(HiraganaList);
    revisionKatakanaTable = generateRevisionKatakanaTable(HiraganaList);
    console.log(`📚 Tables régénérées: Romaji=${Object.keys(revisionRomajiTable).length}, Katakana=${Object.keys(revisionKatakanaTable).length}`);
    
    console.log('✅ Chargement background terminé !');
    
  } catch (error) {
    console.error('❌ Erreur chargement background:', error.message);
  } finally {
    backgroundLoadingInProgress = false;
  }
}
function updateLoadingProgress(percent, message) {
  const fill = document.getElementById('loading-progress-fill');
  const msg = document.getElementById('loading-message');
  
  if (fill) fill.style.width = percent + '%';
  if (msg) msg.textContent = message;
  
  console.log(`📊 ${percent}% - ${message}`);
}

function startApp() {
  if (!gameDataLoaded) {
    document.getElementById("loadingText").textContent = t('welcome_loading'); // ✅ MODIFIÉ
    return;
  }
  
  updateMenuMessage();
}
// === FONCTION UNIVERSELLE SÉCURISÉE AVEC LIMITE ===
// === FONCTION UNIVERSELLE SÉCURISÉE AVEC TES EMOJIS ===
window.safeConvertEmojis = function(element, attempt = 0) {
  const MAX_ATTEMPTS = 20;
  
  if (!element) return;
  
  if (typeof twemoji === 'undefined') {
    if (attempt < MAX_ATTEMPTS) {
      console.log(`⏳ Tentative ${attempt + 1}/${MAX_ATTEMPTS} - Attente de Twemoji...`);
      setTimeout(() => safeConvertEmojis(element, attempt + 1), 200);
    } else {
      console.warn('❌ Twemoji n\'a pas pu être chargé après', MAX_ATTEMPTS, 'tentatives');
    }
    return;
  }
  
  console.log('✅ Twemoji chargé, conversion avec emojis Fluent 3D...');
  twemoji.parse(element, { 
    folder: '', // ✅ Chaîne vide = pas de sous-dossier
    ext: '.png',
    base: 'https://emmanuel971-source.github.io/hirakataquizz/emojis/',
    // ✅ AJOUTE CETTE LIGNE pour forcer à ne pas utiliser de sous-dossier de taille
    callback: function(icon, options) {
      return options.base + icon + options.ext;
    }
  });
};
// --- Fonctions utilitaires UI ---
function setAppHeight() {
  const doc = document.documentElement;
  doc.style.setProperty('--app-height', `${window.innerHeight}px`);
}

// Appeler immédiatement
setAppHeight();

// Recalculer lors du resize et de l'orientation
window.addEventListener('resize', setAppHeight);
window.addEventListener('orientationchange', () => {
  setTimeout(setAppHeight, 200);
});

// Déclencher un scroll minimal pour cacher la barre
setTimeout(() => {
  window.scrollTo(0, 10);
}, 100);



function adjustStatsTableOffset() {
  const menu = document.getElementById('thead');
  const container = document.querySelector('.stats-table-container');

  if (!menu || !container) return;

  // Hauteur réelle du menu
  const menuHeight = menu.offsetHeight;

  // Appliquer un padding équivalent
  container.style.paddingTop = menuHeight + 'px';
}

// Lancer quand la page est chargée
window.addEventListener('load', adjustStatsTableOffset);

// Lancer lors d’un changement de taille (mobile -> landscape)
window.addEventListener('resize', adjustStatsTableOffset);



// --- Fonction helper ---
function logError(msg) {
console.warn(msg);
}


// ============================================================================
// 🎬 SECTION 17 : DÉMARRAGE APPLICATION
// ============================================================================


// Listener global
document.addEventListener('click', (event) => {
  // ✅ EXCLUSION : Boutons du sous-menu Quiz Flash
  const isQuizFlashButton = event.target.closest('#options-quiz-flash-choice button');
  if (isQuizFlashButton) {
    return; // Pas de son pour ces boutons
  }
  
  // ✅ PRIORITÉ 1 : Boutons de réponse du quiz (son spécifique)
  const quizAnswer = event.target.closest('.answer-btn, #choices1 button, #choices2 button');
  if (quizAnswer) {
    playQuizAnswerClick();
    return;
  }
  
  // ✅ PRIORITÉ 2 : Autres boutons (son général)
  const target = event.target.closest('.arcade-button, .hamburger, .difficulty-btn, .emoji-button, .switch, button, .hiragana-card');
  
  if (target) {
    playButtonClick();
  }
});


// --- Event listeners globaux ---
document.addEventListener('click', () => userInteractions.clicks++);
document.addEventListener('keydown', () => userInteractions.keystrokes++);
document.addEventListener('mousemove', () => {
  if (userInteractions.mouseMovements < 50) {
    userInteractions.mouseMovements++;
  }
});

// --- Setters layout ---
setAppHeight();
window.addEventListener('resize', setAppHeight);
window.addEventListener('orientationchange', () => {
  setTimeout(setAppHeight, 200);
});

setTimeout(() => {
  window.scrollTo(0, 10);
}, 100);



// --- Initialisation au chargement ---
window.onload = () => {
  // Gestion de la langue
  if (!localStorage.getItem('appLanguage')) {
    const detectedLang = detectBrowserLanguage();
    currentLanguage = detectedLang;
    localStorage.setItem('appLanguage', detectedLang);
  } else {
    currentLanguage = localStorage.getItem('appLanguage');
  }
  
  updateAllTexts();
  loadSoundSettings();
  updateSoundUI();
  initGame();
  
  setTimeout(preloadEmojis, 500);
  setTimeout(() => safeConvertEmojis(document.body), 1000);
};

// --- Synthèse vocale ---
speechSynthesis.onvoiceschanged = () => {
  console.log("🔢 Voix disponibles :", speechSynthesis.getVoices());
};

// --- Nettoyage particules ---
setInterval(cleanupOldParticles, 3000);


// ============================================================================
// 🐼 SECTION 18 : ÉVÉNEMENTS PANDA & ÉCRAN D'ACCUEIL
// ============================================================================

document.addEventListener("DOMContentLoaded", async () => {
  const panda = document.querySelector(".panda-logo");
  if (!panda) return;
  
  // Préchargement image panda
  const pandaImg = new Image();
  pandaImg.src = 'https://emmanuel971-source.github.io/hirakataquizz/emojis/1f43c.png';
  
  await new Promise((resolve) => {
    pandaImg.onload = () => {
      console.log('✅ Panda Fluent 3D préchargé');
      resolve();
    };
    pandaImg.onerror = () => {
      console.warn('⚠️ Erreur chargement panda');
      resolve();
    };
    setTimeout(resolve, 500);
  });
  
  safeConvertEmojis(panda);
  
  setTimeout(() => {
    panda.classList.add('loaded');
  }, 200);
  
 // Événement click panda
panda.addEventListener("click", async () => { // ✅ Ajout de async
  document.getElementById("welcome").classList.add("hidden");
  loadDifficulty();
  updateMenuMessage();
  updateApprendreButtonState();
  
  const menuBtn = document.querySelector(".hamburger");
  if (menuBtn) menuBtn.classList.remove("hidden");
  
  if (!userToken || !currentUser) {
    showSection('create-account');
    await initPseudoCache(); // ✅ Maintenant valide
  } else {
    showReturningUserWelcome(currentUser.pseudo);
  }
  
  if (isApprentissageBloque()) {
    console.log('🚫 Mode Apprendre bloqué détecté au démarrage');
    wasBlockedWhenEnteringRevision = true;
    deficitInitialRevision = calculerDeficitValidation();
    pointsGagnesEnRevision = 0;
    
    setTimeout(() => {
      showSection('mode2');
    }, 100);
  }
  
  nextQuestion();
});
  
  updateAllTexts();
});

// --- Setup initial hamburger ---
document.addEventListener("DOMContentLoaded", () => {
  const panda = document.querySelector(".panda-logo");
  const menuBtn = document.querySelector(".hamburger");

  if (menuBtn) menuBtn.classList.add("hidden");
  
  if (panda) {
    panda.style.pointerEvents = "none";
    panda.style.opacity = "0.2";
  }
});

// --- Ajustement table stats ---
window.addEventListener('load', adjustStatsTableOffset);
window.addEventListener('resize', adjustStatsTableOffset);

// --- Override showSection pour stats ---
const originalShowSection = showSection;
showSection = function(sectionId) {
  originalShowSection(sectionId);
  if (sectionId === 'stats') {
    setTimeout(generateGarden, 100);
  }
}

// --- Support tactile révision ---
document.querySelectorAll('.revision-key').forEach(key => {
  key.addEventListener('touchstart', function() {
    this.classList.add('active');
    setTimeout(() => {
      this.classList.remove('active');
    }, 300);
  });
});

// =============================================================================
// =============================================================================
//                            SECTION 19 : TUTORIEL MODE QUIZ
// =============================================================================
// =============================================================================

const quizTutorialSteps = [
  {
    title: "tuto_step1_title",  // 👈 Clé de traduction
    text: "tuto_step1_text",    // 👈 Clé de traduction
    animate: () => {}
  },
  {
    title: "tuto_step2_title",
    text: "tuto_step2_text",
    animate: () => {
      const marker = document.querySelector(".progress-marker");
      if (!marker) return;
      const orig = getComputedStyle(marker).left;
      let interval = setInterval(() => {
        marker.style.transition = "left 1s ease";
        marker.style.left = "100%";
        setTimeout(() => {
          marker.style.transition = "none";
          marker.style.left = orig;
          setTimeout(() => {
            marker.style.transition = "left 1s ease";
          }, 50);
        }, 1200);
      }, 2500);
      return () => clearInterval(interval);
    }
  },
  {
    title: "tuto_step3_title",
    text: "tuto_step3_text",
    animate: () => {
      const cards = document.querySelectorAll(".hiragana-card");
      if (cards.length === 0) return;
      const target = cards[Math.floor(cards.length / 2)];
      
      const stars = target.querySelectorAll(".star");
      
      let interval = null;
      let timeouts = [];
      
      const animateStars = () => {
        stars.forEach(s => {
          s.classList.remove("filled", "new-star");
          s.style.background = "var(--gray-very-light)";
        });
        
        stars.forEach((star, i) => {
          const timeout1 = setTimeout(() => {
            star.classList.add("filled", "new-star");
            star.style.background = "var(--pink-primary)";
            
            const timeout2 = setTimeout(() => {
              star.classList.remove("new-star");
            }, 1200);
            
            timeouts.push(timeout2);
          }, i * 1200);
          
          timeouts.push(timeout1);
        });
        
        const completedTimeout = setTimeout(() => {
          target.classList.add("completed");
        }, stars.length * 1200 + 1200);
        
        timeouts.push(completedTimeout);
      };
      
      animateStars();
      interval = setInterval(() => {
        timeouts.forEach(t => clearTimeout(t));
        timeouts = [];
        animateStars();
      }, stars.length * 1200 + 2000);
      
      target.classList.add("pulsing");
      
      return () => {
        if (interval) clearInterval(interval);
        timeouts.forEach(t => clearTimeout(t));
        timeouts = [];
        target.classList.remove("completed", "pulsing");
        stars.forEach(star => {
          star.classList.remove("filled", "new-star");
          star.style.background = "var(--gray-very-light)";
        });
      };
    }
  },
  {
    title: "tuto_step4_title",
    text: "tuto_step4_text",
    animate: () => {
      const question = document.getElementById("question");
      if (question) {
        question.classList.add("tutorial-highlight", "pulsing");
      }
    }
  },
  {
    title: "tuto_step5_title",
    text: "tuto_step5_text",
    animate: () => {
      const buttons = document.querySelectorAll(".answers button");
      if (buttons.length === 0) return;
    }
  },
  {
    title: "tuto_step6_title",
    text: "tuto_step6_text",
    animate: playIncorrectAnswerDemo
  },
  {
    title: "tuto_step7_title",
    text: "tuto_step7_text",
    animate: playCorrectAnswerDemo
  },
  {
    title: "tuto_step8_title",
    text: "tuto_step8_text",
    animate: () => {}
  },
  {
    title: "tuto_step9_title",
    text: "tuto_step9_text",
  }
];
let tutorialStep = 0;
let tutorialActive = false;
let currentCleanup = null;
function startQuizTutorial() {
  if (tutorialActive) return;
  tutorialActive = true;
  tutorialStep = 0;

  // Désactive les boutons pour que l'utilisateur puisse jouer
  document.querySelectorAll(".answers button").forEach(b => {
    b.style.pointerEvents = "none";
  });
  
  // 👇 AJOUT : Désactiver le bouton hamburger
  const hamburger = document.querySelector(".hamburger");
  if (hamburger) {
    hamburger.style.pointerEvents = "none";
  //  hamburger.style.opacity = "0.5";
  }
  
  document.getElementById("quiz-tutorial-overlay").style.display = "flex";
  const dots = document.getElementById("tutorial-progress-dots");
  dots.innerHTML = "";
  quizTutorialSteps.forEach((_, i) => {
    const d = document.createElement("div");
    d.className = "tutorial-dot" + (i === 0 ? " active" : "");
    dots.appendChild(d);
  });
  showTutorialStep();
}


function showTutorialStep() {
  // Nettoyage...
  if (currentCleanup) {
    currentCleanup();
    currentCleanup = null;
  }

  const step = quizTutorialSteps[tutorialStep];

  // 👇 Utilise la fonction de traduction t()
  document.getElementById("tutorial-title").textContent = t(step.title);
  document.getElementById("tutorial-text").textContent = t(step.text);


  // Reset question
  const q = document.getElementById("question");
  if (q) {
    q.textContent = "あ";
  }

  // 👇 Maintenant le reste du code (reset cartes, etc.)
  const resultDiv = document.getElementById("result");
  if (resultDiv && tutorialStep !== 6) {
    resultDiv.style.zIndex = "";
  }

  // Reset complet de la carte avec étoiles
  if (tutorialStep !== 2) {
    document.querySelectorAll(".hiragana-card").forEach(card => {
      card.classList.remove("completed", "pulsing");
      card.querySelectorAll(".star").forEach(star => {
        star.classList.remove("filled", "new-star");
        star.style.background = "var(--gray-very-light)";
      });
    });
  } else {
    // À l'arrivée sur l'étape 2, reset aussi
    document.querySelectorAll(".hiragana-card").forEach(card => {
      card.classList.remove("completed", "pulsing");
      card.querySelectorAll(".star").forEach(star => {
        star.classList.remove("filled", "new-star");
        star.style.background = "var(--gray-very-light)";
      });
    });
  }

  // Mise à jour des points de progression
  document.querySelectorAll(".tutorial-dot").forEach((d, i) => {
    d.classList.toggle("active", i === tutorialStep);
  });




  // Retrait des highlights et animations générales
// Retrait des highlights et animations générales
document.querySelectorAll(".tutorial-highlight, .tutorial-highlight-hamburger, .pulsing, .completed").forEach(el => {
  el.classList.remove("tutorial-highlight", "tutorial-highlight-hamburger", "pulsing", "completed");
});

  // Nettoyage spécifique des boutons de réponses
  document.querySelectorAll(".answers button").forEach(b => {
    b.classList.remove("clicked-glow", "clicked", "correct", "incorrect");
  });

  // Positionnement de la carte du tutoriel
  const card = document.getElementById("quiz-tutorial-card");
  card.style.transform = "translateY(0)"; // reset

  if (tutorialStep === 1) {
    card.style.transform = "translateY(0)";
  } else if (tutorialStep === 2) {
    card.style.transform = "translateY(5vh)";
  } else if (tutorialStep === 3) {
    card.style.transform = "translateY(20vh)";
  } else if (tutorialStep === 4) {
    card.style.transform = "translateY(-28vh)";
  } else if (tutorialStep === 5) {
    card.style.transform = "translateY(-28vh)";
  } else if (tutorialStep === 6) {
    card.style.transform = "translateY(-28vh)";
    card.style.zIndex = "5"; // 👈 AJOUT : Passe sous les sparkles (z-index 10)
  } else if (tutorialStep === 7) {
    card.style.transform = "translateY(0)";
  } else {
    card.style.transform = "translateY(0)";
  }

// Highlight de la zone concernée
//const highlightSelector = tutorialStep === 1 ? "#progressBarContainer" :
//                          tutorialStep === 2 ? ".hiraganas-grid" :
//                          tutorialStep === 3 ? "#question" :
//                        //  tutorialStep === 4 ? ".quiz-container > div:has(.answers)" :  // 👈 Parent des 2 rangées
//                        //  tutorialStep === 5 ? ".quiz-container > div:has(.answers)" :  // 👈 Parent des 2 rangées
//                        //  tutorialStep === 6 ? ".quiz-container > div:has(.answers)" :  // 👈 Parent des 2 rangées
//                          tutorialStep === 4 ? ".answers" :
//                          tutorialStep === 5 ? ".answers" :
//                          tutorialStep === 6 ? ".answers" :
//         tutorialStep === 7 ? null :
//                            null;


 // if (highlightSelector) {
 //   document.querySelectorAll(highlightSelector).forEach(el => {
 //     el.classList.add("tutorial-highlight");
 //   });
 // }
// Highlight de la zone concernée
// Highlight de la zone concernée
if (tutorialStep === 1) {
  document.querySelector("#progressBarContainer")?.classList.add("tutorial-highlight");
} else if (tutorialStep === 2) {
  document.querySelector(".hiraganas-grid")?.classList.add("tutorial-highlight");
} else if (tutorialStep === 3) {
  document.querySelector("#question")?.classList.add("tutorial-highlight");
} else if (tutorialStep === 4 || tutorialStep === 5 || tutorialStep === 6) {
  const choices1 = document.querySelector("#choices1");
  const choices2 = document.querySelector("#choices2");
  
  if (choices1 && choices2) {
    const parent = choices1.parentElement;
    if (parent) {
      parent.classList.add("tutorial-highlight");
    }
  }
} else if (tutorialStep === 7) {
  // 👇 Utilise la classe spéciale pour le hamburger
  document.querySelector(".hamburger")?.classList.add("tutorial-highlight-hamburger");
}
  // === LANCEMENT DE L'ANIMATION DE L'ÉTAPE ===
 if (tutorialStep >= 1 && tutorialStep <= 6) {
    // Pour les étapes ❌ et ✅ : on utilise une question fixe ultra-fiable
    setupTutorialDemoQuestion();

    // Petit délai pour que les boutons soient bien dans le DOM
    setTimeout(() => {
      if (step.animate) {
        currentCleanup = step.animate() || null;
      }
    }, 50);

  } else {
    // Toutes les autres étapes : animation immédiate (comme avant)
    if (step.animate) {
      currentCleanup = step.animate() || null;
    }
  }

  // Texte du bouton Suivant / Commencer
  document.getElementById("tutorial-next").textContent =
    tutorialStep === quizTutorialSteps.length - 1 ? t('tuto_start') : t('tuto_next');
}
function nextTutorialStep() {
  tutorialStep++;
  if (tutorialStep >= quizTutorialSteps.length) {
    endQuizTutorial();
  } else {
    showTutorialStep();
  }
}
function endQuizTutorial() {
  tutorialActive = false;
  document.getElementById("quiz-tutorial-overlay").style.display = "none";
  if (currentCleanup) currentCleanup();
// Retrait des highlights et animations générales
document.querySelectorAll(".tutorial-highlight, .tutorial-highlight-hamburger, .pulsing, .completed").forEach(el => {
  el.classList.remove("tutorial-highlight", "tutorial-highlight-hamburger", "pulsing", "completed");
});
 
  // ✅ Réactive les boutons pour que l'utilisateur puisse jouer
  document.querySelectorAll(".answers button").forEach(b => {
    b.disabled = false;
    b.style.pointerEvents = "auto";
  });
   // 👇 AJOUT : Réactiver le bouton hamburger
  const hamburger = document.querySelector(".hamburger");
  if (hamburger) {
    hamburger.style.pointerEvents = "auto";
    hamburger.style.opacity = "1";
  }
// localStorage.removeItem('quizTutorialSeen');
  nextQuestion();
}
// Fonctions utilitaires
function simulateTutorialAnswer(correct) {
  const rows = [document.getElementById("choices1"), document.getElementById("choices2")];
  rows.forEach(row => {
    row.querySelectorAll("button").forEach(b => b.disabled = true);
  });
  rows.forEach((row, idx) => {
    const btns = row.querySelectorAll("button");
    const good = btns[idx % btns.length];
    const chosen = correct ? good : btns[(idx + 1) % btns.length];
    setTimeout(() => {
      chosen.classList.add("clicked-glow", correct ? "correct" : "incorrect");
      good.classList.add("correct");
    }, idx * 400);
  });
  if (correct) {
  }
}
function resetTutorialButtons() {
  document.querySelectorAll(".answers button").forEach(b => {
    b.className = "arcade-button";
    b.disabled = false;
  });
}
// Fonction pour simuler une réponse correcte (étape du tuto)
function playCorrectAnswerDemo() {
  const correctKatakana = "ア";
  const correctRomaji = "a";

  const correctBtn1 = [...document.querySelectorAll("#choices1 button")].find(b => b.innerText === correctKatakana);
  const correctBtn2 = [...document.querySelectorAll("#choices2 button")].find(b => b.innerText === correctRomaji);

  if (!correctBtn1 || !correctBtn2) {
    console.warn("Boutons corrects non trouvés (démo bonne réponse)");
    return () => {};
  }

  // 1️⃣ Premier bouton cliqué + son + grisage des autres
  setTimeout(() => {
    correctBtn1.classList.add("clicked-glow", "clicked");
    playTwinkle();
    
    // Griser tous les autres boutons de la ligne 1
    document.querySelectorAll("#choices1 button").forEach(btn => {
      if (btn !== correctBtn1) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
      }
    });
  }, 300);

  // 2️⃣ Deuxième bouton cliqué + son + grisage des autres
  setTimeout(() => {
    correctBtn2.classList.add("clicked-glow", "clicked");
    playTwinkle();
    
    // Griser tous les autres boutons de la ligne 2
    document.querySelectorAll("#choices2 button").forEach(btn => {
      if (btn !== correctBtn2) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
      }
    });
  }, 800);

  // 3️⃣ Validation quasi-immédiate (comme dans le vrai jeu)
  setTimeout(() => {
    correctBtn1.classList.remove("clicked-glow");
    correctBtn1.classList.add("correct");
    correctBtn2.classList.remove("clicked-glow");
    correctBtn2.classList.add("correct");

    // 🎉 ANIMATION DE SUCCÈS (immédiatement après validation)
    const questionDiv = document.getElementById("question");
    const resultDiv = document.getElementById("result");
    const container = document.querySelector('.quiz-container');
    
    if (!questionDiv || !resultDiv || !container) return;
    
    const questionRect = questionDiv.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // Positionnement du résultat à la place de la question
    resultDiv.style.position = "absolute";
    resultDiv.style.top = (questionRect.top - containerRect.top) + "px";
    resultDiv.style.left = "0";
    resultDiv.style.right = "0";
    resultDiv.style.height = questionRect.height + "px";
    resultDiv.style.zIndex = "10";
    questionDiv.style.visibility = "hidden";

    // Emojis de succès
    const emojisOK = ["🦋","🐸","🍀","💩","👻","😸","😽","🌈","🐻","🌞","✅","🧠","🐶","🐵"];
    const emoji = emojisOK[Math.floor(Math.random() * emojisOK.length)];
    const text = t('tuto_perfect'); 

    setTimeout(() => {
      resultDiv.className = 'anim-combo';
      resultDiv.innerHTML = `<div class="result-line">
        <div class="result-text">${text}</div>
        <div class="result-emoji">${emoji}</div>
      </div>`;
      
      // Conversion des emojis si twemoji est chargé
      if (window.safeConvertEmojis) {
        safeConvertEmojis(resultDiv);
      }
      
      // Création des sparkles
      setTimeout(() => {
        if (window.createSparkles) {
          createSparkles();
        }
      }, 100);
    }, 10);

    // Nettoyage après animation
    setTimeout(() => {
      questionDiv.style.visibility = "visible";
      resultDiv.style.opacity = "0";
      setTimeout(() => { 
        resultDiv.innerHTML = ""; 
        resultDiv.style = ""; 
      }, 500);
    }, 1800);
  }, 900);

  // Fonction de cleanup
  return () => {
    const resultDiv = document.getElementById("result");
    if (resultDiv) {
      resultDiv.innerHTML = "";
      resultDiv.style = "";
    }
    const questionDiv = document.getElementById("question");
    if (questionDiv) {
      questionDiv.style.visibility = "visible";
    }
    document.querySelectorAll(".answers button").forEach(btn => {
      btn.classList.remove("clicked-glow", "clicked", "correct", "incorrect");
      btn.disabled = false;
      btn.style.opacity = "";
    });
  };
}

function playIncorrectAnswerDemo() {
  const correctKatakana = "ア";
  const correctRomaji = "a";

  const buttons1 = [...document.querySelectorAll("#choices1 button")];
  const buttons2 = [...document.querySelectorAll("#choices2 button")];

  const correctBtn1 = buttons1.find(b => b.innerText === correctKatakana);
  const correctBtn2 = buttons2.find(b => b.innerText === correctRomaji);

  // On prend un mauvais bouton (pas le bon)
  const wrongBtn1 = buttons1.find(b => b.innerText !== correctKatakana);
  const wrongBtn2 = buttons2.find(b => b.innerText !== correctRomaji);

  if (!correctBtn1 || !correctBtn2 || !wrongBtn1 || !wrongBtn2) {
    console.warn("Boutons manquants (démo mauvaise réponse)");
    return () => {};
  }

  // 1️⃣ Premier mauvais bouton → cliqué + son + grisage
  setTimeout(() => {
    wrongBtn1.classList.add("clicked-glow", "clicked");
    playTwinkle();
    
    // Griser tous les autres boutons de la ligne 1
    document.querySelectorAll("#choices1 button").forEach(btn => {
      if (btn !== wrongBtn1) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
      }
    });
  }, 300);

  // 2️⃣ Deuxième mauvais bouton → cliqué + son + grisage
  setTimeout(() => {
    wrongBtn2.classList.add("clicked-glow", "clicked");
    playTwinkle();
    
    // Griser tous les autres boutons de la ligne 2
    document.querySelectorAll("#choices2 button").forEach(btn => {
      if (btn !== wrongBtn2) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
      }
    });
  }, 800);

  // 3️⃣ Résolution : rouges + verts + son (juste après le 2ème clic)
  setTimeout(() => {
    // Retrait glow
    wrongBtn1.classList.remove("clicked-glow");
    wrongBtn2.classList.remove("clicked-glow");

    // Mauvaises réponses → rouge
    wrongBtn1.classList.add("incorrect");
    wrongBtn2.classList.add("incorrect");

    // Bonnes réponses → vert (simultané)
    correctBtn1.classList.add("correct");
    correctBtn2.classList.add("correct");

    // Rendre les bonnes réponses bien visibles
    correctBtn1.style.opacity = "1";
    correctBtn2.style.opacity = "1";

    // Son d'erreur
    playSoftError();
  }, 900);

  return () => {
    document.querySelectorAll(".answers button").forEach(btn => {
      btn.classList.remove("clicked-glow", "clicked", "correct", "incorrect");
      btn.disabled = false;
      btn.style.opacity = "";
    });
  };
}
// Événements boutons
document.getElementById("tutorial-next").onclick = nextTutorialStep;
function setupTutorialDemoQuestion() {
  // Question fixe pour le tutoriel : on prend "ア" (a en romaji) → simple et visuel

  // 1. Mise à jour du kana affiché dans la question
  const questionEl = document.getElementById("question");
  if (questionEl) {
    questionEl.textContent = "あ";  // Le kana affiché
  }

  // 2. Vidage des conteneurs de réponses
  const choices1 = document.getElementById("choices1");
  const choices2 = document.getElementById("choices2");
  if (choices1) choices1.innerHTML = "";
  if (choices2) choices2.innerHTML = "";

  // 3. Création des boutons pour la ligne Katakana (choices1)
  // Bonne réponse : "ア" → on la met en position 0 pour simplifier
  const katakanaOptions = ["ウ", "イ", "ア", "エ"];
  katakanaOptions.forEach(text => {
    const btn = document.createElement("button");
    btn.className = "arcade-button";
    btn.innerText = text;
    choices1.appendChild(btn);
  });

  // 4. Création des boutons pour la ligne Romaji (choices2)
  // Bonne réponse : "a"
  const romajiOptions = ["i", "a", "e", "o"];
  romajiOptions.forEach(text => {
    const btn = document.createElement("button");
    btn.className = "arcade-button";
    btn.innerText = text;
    choices2.appendChild(btn);
  });
}
// =============================================================================
// =============================================================================
//                            SECTION 20 : FLASH QUIZZ
// =============================================================================
// =============================================================================

let quizFlashState = {
  currentGroup: 1,
  currentQuestionIndex: 0,
  questionsPool: [],
  isFlipped: false,
  timerInterval: null,
  timeRemaining: 0,
  totalTime: 0,
  usedTrophies: [] // ✅ NOUVEAU : mémoriser les trophées déjà utilisés
};

const GROUPES_flashquiz = {
  1: { niveaux: [1, 2, 4], nom: "Groupe 1" },           // 3 niveaux
  2: { niveaux: [6, 8, 9], nom: "Groupe 2" },           // 3 niveaux
  3: { niveaux: [13, 15, 18], nom: "Groupe 3" },        // 3 niveaux
  4: { niveaux: [19, 20, 23], nom: "Groupe 4" },        // 3 niveaux
  5: { niveaux: [28, 30, 34], nom: "Groupe 5" },        // 3 niveaux
  6: { niveaux: [40, 41, 42], nom: "Groupe 6" },        // 3 niveaux
  7: { niveaux: [43, 44, 45, 46], nom: "Groupe 7" }         // 3 niveaux
};

// === 4️⃣ FONCTIONS PRINCIPALES ===
function showQuizFlashMenu() {
  // Fermer le menu principal
  const menu = document.getElementById('menu');
  if (menu && menu.classList.contains('active')) {
    toggleMenu();
  }
  
  // Aller directement dans Options
  showSection('options');
  
  // Afficher immédiatement le sous-menu sans délai
  showSubOptions('quiz-flash-choice');
}
function startQuizFlash(groupNumber = 1, type = 'hiragana') {
  console.log(`🎴 Démarrage Quiz Flash - Groupe ${groupNumber} - Type: ${type}`);
  
  // ✅ NOUVEAU : Arrêter tout timer précédent avant de démarrer
  if (quizFlashState.timerInterval) {
    clearInterval(quizFlashState.timerInterval);
    quizFlashState.timerInterval = null;
  }
  
  // Réinitialiser l'état
  quizFlashState.currentGroup = groupNumber;
  quizFlashState.currentQuestionIndex = 0;
  quizFlashState.isFlipped = false;
  quizFlashState.type = type; // ⬅️ AJOUTER CETTE LIGNE
  
  // Charger le groupe
  loadQuizGroup(groupNumber, type); // ⬅️ PASSER LE TYPE
  
  // Afficher la section
  showSection('quiz-flash');
  
  // Démarrer la première question
  showNextQuestion();
}
function loadQuizGroup(groupNumber, type = 'hiragana') {
  const group = GROUPES_flashquiz[groupNumber];
  
  if (!group) {
    console.error(`❌ Groupe ${groupNumber} introuvable`);
    return;
  }
  
  console.log(`📚 Chargement ${group.nom} - Type: ${type} - Niveaux: ${group.niveaux.join(', ')}`);
  
  // ⬇️ UTILISER TOUJOURS HiraganaList (qui contient aussi les Katakana)
  const sourceList = HiraganaList;
  
  // Filtrer les items du groupe
  const groupItems = sourceList.filter(item => 
    group.niveaux.includes(parseInt(item.Niveau))
  );
  
  // Mélanger aléatoirement
  quizFlashState.questionsPool = shuffleArray([...groupItems]);
  
  console.log(`✅ ${quizFlashState.questionsPool.length} questions chargées`);
}
function showNextQuestion() {
  const { currentQuestionIndex, questionsPool, currentGroup, type } = quizFlashState; // ⬅️ AJOUTER type
    
  // Vérifier si le groupe est terminé
  if (currentQuestionIndex >= questionsPool.length) {
    console.log('🏆 Groupe terminé !');
    showTrophyFlashcard(currentGroup);
    return;
  }
  
  const item = questionsPool[currentQuestionIndex];
  
  // Mettre à jour le header
  document.getElementById('flashCounter').textContent = 
    `${currentQuestionIndex + 1}/${questionsPool.length}`;
  document.getElementById('flashGroupName').textContent = 
    GROUPES_flashquiz[currentGroup].nom;
  
  // Réinitialiser la carte (face avant)
  const card = document.getElementById('flashCard');

  // ✅ VIDER D'ABORD le contenu de la face arrière
  document.getElementById('flashHiraganaSmall').textContent = '';
  document.getElementById('flashRomaji').textContent = '';

  // Ensuite retirer la classe flipped
  card.classList.remove('flipped');
  quizFlashState.isFlipped = false;

  // Puis afficher le nouvel hiragana/katakana sur la face avant
  const kanaToShow = type === 'katakana' ? item.Katakana : item.Hiragana; // ⬅️ AJOUTER
  
  document.getElementById('flashHiragana').textContent = kanaToShow; // ⬅️ MODIFIER
  
  // ✅ ATTENDRE que l'animation soit terminée pour remplir la face arrière
  setTimeout(() => {
    document.getElementById('flashHiraganaSmall').textContent = kanaToShow; // ⬅️ MODIFIER
    document.getElementById('flashRomaji').textContent = item.Romaji;
    safeConvertEmojis(document.getElementById('flashHiraganaSmall'));
  }, 600);

  // Convertir les emojis
  safeConvertEmojis(document.getElementById('flashHiragana'));
  safeConvertEmojis(document.getElementById('flashHiraganaSmall'));
  

  
  // ✅ MODIFICATION 1 : Démarrer le timer APRÈS l'animation de flip (600ms)
  setTimeout(() => {
    startFlashTimer(item);
  }, 3);
    // Son de pop
   //if (soundEnabled) {
  //   playQuestionSound(); // ou un nom similaire
 // }
}

function startFlashTimer(item) {
  if (quizFlashState.timerInterval) {
    clearInterval(quizFlashState.timerInterval);
  }

  // ✅ ARRÊTER le son de timer précédent s'il existe
  if (quizFlashState.timerAudio) {
    quizFlashState.timerAudio.pause();
    quizFlashState.timerAudio.currentTime = 0;
  }

  const difficulty = parseInt(localStorage.getItem('difficulty')) || 6;
  const duration = difficulty <= 4 ? 5 : difficulty <= 6 ? 4 : 3;

  quizFlashState.totalTime = duration;
  quizFlashState.timeRemaining = duration;

  const timerBar = document.getElementById('flashTimerBar');

  // 🔒 Désactiver transitions et lueur
  timerBar.classList.add('no-transition', 'no-shine');
  timerBar.classList.remove('warning', 'danger', 'flash-start');

  // 🔄 Pop puis relancer le timer après 250ms
  setTimeout(() => {
    // ✅ EFFET POP sur toute la barre de timer
    const timerContainer = document.querySelector('.quiz-flash-timer');
    if (timerContainer) {
      timerContainer.classList.add('timer-pop-effect');
      setTimeout(() => {
        timerContainer.classList.remove('timer-pop-effect');
      }, 300);
    }

    // 💥 Flash initial DÉCALÉ de 100ms pour éviter la surcharge
    setTimeout(() => {
      timerBar.classList.add('flash-start');
      setTimeout(() => timerBar.classList.remove('flash-start'), 200);
    }, 100);

    // 🔊 NOUVEAU : Démarrer le son de timer
    setTimeout(() => {
      if (soundEnabled) {
        playMenuClicSound();
        
        // ✅ Démarrer le son de timer et le stocker
        quizFlashState.timerAudio = new Audio('https://emmanuel971-source.github.io/hirakataquizz/timer.mp3');
        quizFlashState.timerAudio.volume = 0.5; // Ajuste le volume
        quizFlashState.timerAudio.play().catch(err => console.log('Erreur timer audio:', err));
      }
    }, 100);

    timerBar.style.width = '100%';
    timerBar.offsetHeight; // force repaint

    timerBar.classList.remove('no-transition', 'no-shine');

    const startTime = Date.now();

    quizFlashState.timerInterval = setInterval(() => {
      const elapsed = (Date.now() - startTime) / 1000;
      const remaining = Math.max(0, duration - elapsed);
      const percentage = (remaining / duration) * 100;

      quizFlashState.timeRemaining = remaining;
      timerBar.style.width = percentage + '%';
      
      // ✅ Gestion de l'opacité de la lueur (si vous la gardez)
      const timerContainer = document.querySelector('.quiz-flash-timer');
      if (timerContainer) {
        timerContainer.style.setProperty('--shine-opacity', percentage > 0 ? '1' : '0');
      }

      timerBar.classList.remove('warning', 'danger');
      if (percentage <= 30) timerBar.classList.add('danger');
      else if (percentage <= 60) timerBar.classList.add('warning');

      // 🔥 STOP timer quand terminé
      if (remaining <= 0) {
        timerBar.classList.add('no-shine');
        clearInterval(quizFlashState.timerInterval);
        
        // ✅ ARRÊTER le son de timer
        if (quizFlashState.timerAudio) {
          quizFlashState.timerAudio.pause();
          quizFlashState.timerAudio.currentTime = 0;
        }
        
        flipCardAndReveal(item);
      }
    }, 50);

  }, 250);
}

function flipCardAndReveal(item) {
  const card = document.getElementById('flashCard');
  card.classList.add('flipped');
  quizFlashState.isFlipped = true;
  
  // Son de flip (réutilise un son existant)
  if (soundEnabled) {
    playQuestionSound(); // Son différent pour la révélation
  }
  
  // Jouer le son du romaji immédiatement
  if (voiceEnabled) {
    const audioUrl = `https://emmanuel971-source.github.io/hirakataquizz/${encodeURIComponent(item.Hiragana)}.mp3`;
    new Audio(audioUrl).play().catch(() => {
      console.warn('⚠️ Son romaji introuvable');
    });
  }
  
  // ✅ STOCKER le timeout pour pouvoir l'annuler
  quizFlashState.nextQuestionTimeout = setTimeout(() => {
    quizFlashState.currentQuestionIndex++;
    showNextQuestion();
  }, 2000);
}

function showTrophyFlashcard(completedGroup) {
  const portal = document.getElementById('modal-portal');
  
  // 🎨 Récupère les couleurs du paysage selon la saison
  const season = document.getElementById('season')?.value || 'spring';
  const timeOfDay = document.getElementById('timeOfDay')?.value || 'day';
  
  // Palettes de couleurs par saison
  const seasonColors = {
    spring: ['#FFB7C5', '#FFC8DD', '#98D8C8', '#C4E8C2'],
    summer: ['#87CEEB', '#FFD700', '#FFA500', '#FF6B6B'],
    autumn: ['#D2691E', '#FF8C42', '#CD853F', '#B8860B'],
    winter: ['#4682B4', '#B0C4DE', '#778899', '#ADD8E6']
  };
  
  // Ajuste selon moment de la journée (plus sombre la nuit)
  let colors = seasonColors[season] || seasonColors.spring;
  if (timeOfDay === 'night') {
    colors = colors.map(c => {
      // Assombrit les couleurs pour la nuit
      const rgb = parseInt(c.slice(1), 16);
      const r = Math.max(0, ((rgb >> 16) & 0xFF) * 0.6);
      const g = Math.max(0, ((rgb >> 8) & 0xFF) * 0.6);
      const b = Math.max(0, (rgb & 0xFF) * 0.6);
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    });
  }
  
  // Choisit 2 couleurs aléatoires pour le gradient
  const color1 = colors[Math.floor(Math.random() * colors.length)];
  const color2 = colors[Math.floor(Math.random() * colors.length)];
  
  // ✅ MODIFICATION 2 : Sélection d'un trophée unique (jamais utilisé)
  const trophyEmojis = ['🏆', '🎉', '🎏', '🎊', '🌟', '👑', '🏵️'];
  
  // Filtrer les trophées non utilisés
  const availableTrophies = trophyEmojis.filter(trophy => 
    !quizFlashState.usedTrophies.includes(trophy)
  );
  
  // Si tous ont été utilisés, réinitialiser
  if (availableTrophies.length === 0) {
    quizFlashState.usedTrophies = [];
    availableTrophies.push(...trophyEmojis);
  }
  
  // Choisir un trophée aléatoire parmi les disponibles
  const randomTrophy = availableTrophies[Math.floor(Math.random() * availableTrophies.length)];
  
  // Mémoriser ce trophée comme utilisé
  quizFlashState.usedTrophies.push(randomTrophy);
 
  portal.innerHTML = `
    <div class="revision-flashcard unlock-flashcard" style="background: linear-gradient(135deg, ${color1} 0%, ${color2} 100%);">
      <div class="unlock-sparkles" style="position: absolute; top: 10%; left: 10%;">✨</div>
      <div class="unlock-sparkles" style="position: absolute; top: 10%; right: 10%; animation-delay: 0.3s;">✨</div>
      <div class="unlock-sparkles" style="position: absolute; bottom: 15%; left: 15%; animation-delay: 0.6s;">✨</div>
      <div class="unlock-sparkles" style="position: absolute; bottom: 15%; right: 15%; animation-delay: 0.9s;">✨</div>
      
      <div style="font-size: 6em; margin-bottom: 0.3em;">${randomTrophy}</div>
      <div style="font-size: 2.2em; font-weight: bold; color: #fff; text-shadow: 0 4px 8px rgba(0,0,0,0.3); margin-bottom: 0.5em;">
        ${t('quiz_flash_group_complete')}
      </div>
      <div style="font-size: 1.5em; color: #fff; opacity: 0.9;">
        ${GROUPES_flashquiz[completedGroup].nom} terminé !
      </div>
    </div>
  `;
  
  portal.classList.add('active');
  safeConvertEmojis(portal);
  
  // Feu d'artifice
  setTimeout(() => {
    triggerAdvancedFirework(document.body);
  }, 300);
  
  // Son de niveau up
  if (soundEnabled) {
    playLevelUp();
  }
  
  // Fermer après 3 secondes et passer au groupe suivant
  setTimeout(() => {
    const flashcard = portal.querySelector('.revision-flashcard');
    if (flashcard) {
      flashcard.style.transition = 'all 0.4s ease-in';
      flashcard.style.opacity = '0';
      flashcard.style.transform = 'scale(0.8)';
    }
    
    setTimeout(() => {
      portal.classList.remove('active');
      portal.innerHTML = '';
      
// Passer au groupe suivant s'il existe
const nextGroup = completedGroup + 1;
if (GROUPES_flashquiz[nextGroup]) {
  const currentType = quizFlashState.type || 'hiragana'; // ⬅️ AJOUTER
  startQuizFlash(nextGroup, currentType); // ⬅️ PASSER LE TYPE
      } else {
        // Tous les groupes terminés - retour au menu
        console.log('🎉 TOUS LES GROUPES TERMINÉS !');
        // ✅ Réinitialiser les trophées utilisés
        quizFlashState.usedTrophies = [];
        showSection('menu');
      }
    }, 400);
  }, 3000);
}
// ✅ AJOUTER cette fonction dans votre code JavaScript (dans la section Quiz Flash)
function stopQuizFlash() {
  console.log('🛑 Tentative d\'arrêt du Quiz Flash...');
  
  if (quizFlashState && quizFlashState.timerInterval) {
    clearInterval(quizFlashState.timerInterval);
    quizFlashState.timerInterval = null;
    console.log('✅ Timer arrêté');
  }
  
  // ✅ Arrêter le timeout de passage à la question suivante
  if (quizFlashState && quizFlashState.nextQuestionTimeout) {
    clearTimeout(quizFlashState.nextQuestionTimeout);
    quizFlashState.nextQuestionTimeout = null;
    console.log('✅ Timeout next question arrêté');
  }
  
  // ✅ Arrêter le son de timer
  if (quizFlashState && quizFlashState.timerAudio) {
    quizFlashState.timerAudio.pause();
    quizFlashState.timerAudio.currentTime = 0;
  }
  
  // Réinitialiser l'état
  quizFlashState.isFlipped = false;
  quizFlashState.currentQuestionIndex = 0;
  
  console.log('🛑 Quiz Flash complètement arrêté');
}
// === 5️⃣ FONCTION UTILITAIRE ===

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

</script>
</html>






